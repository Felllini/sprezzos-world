# /etc/rc.status
# vim: syntax=sh
# Definition of boot script return messages
#
#   The bootscripts should use the variables rc_done and rc_failed to
#   report whether they failed or succeeded.  See /etc/init.d/skeleton for
#   an example how the shell functions rc_status and rc_reset are used.
#
#   These functions make use of the variables rc_done and rc_failed;
#   rc_done_up and rc_failed_up are the same as rc_done and rc_failed
#   but contain a terminal code to move up one line before the output
#   of the actual string. (This is particularly useful when the script
#    starts a daemon which produces user output with a newline character)
#
#   The variable rc_reset is used by the master resource control script
#   /etc/init.d/rc to turn off all attributes and switch to the standard
#   character set.
#
#    \033          ascii ESCape
#    \033[<NUM>G   move to column <NUM> (linux console, xterm, not vt100)
#    \033[<NUM>C   move <NUM> columns forward but only upto last column
#    \033[<NUM>D   move <NUM> columns backward but only upto first column
#    \033[<NUM>A   move <NUM> rows up
#    \033[<NUM>B   move <NUM> rows down
#    \033[1m       switch on bold
#    \033[31m      switch on red
#    \033[32m      switch on green
#    \033[33m      switch on yellow
#    \033[m        switch off color/bold
#    \017          exit alternate mode (xterm, vt100, linux console)
#    \033[10m      exit alternate mode (linux console)
#    \015          carriage return (without newline)
#

# Check if the service is used under systemd but not started with
if /bin/mountpoint -q /sys/fs/cgroup/systemd > /dev/null 2>&1 ; then
    if test $PPID -ne 1 -a $# -eq 1 ; then
	_rc_base=
	case "$0" in
	/etc/init.d/boot.*)
	    _rc_base=${0##*/boot.} ;;
	/etc/init.d/*)
	    _rc_base=${0##*/} ;;
	*/rc*)
	    _rc_base=${0##*/rc} ;;
	esac
	if test -n "$_rc_base" -a -x /bin/systemctl ; then
	    exec /bin/systemctl $1 "${_rc_base}.service"
	fi
	unset _rc_base
    fi
    if test -z "$REDIRECT" -a -x /sbin/showconsole ; then
	REDIRECT="$(/sbin/showconsole 2>/dev/null)"
	test -z "$CONSOLE" && CONSOLE=/dev/console
	export REDIRECT CONSOLE
    fi
fi

# Do _not_ be fooled by non POSIX locale
LC_ALL=POSIX
export LC_ALL

# Seek for terminal size and, if needed, set default size
rc_lc () {
    if test -n "$REDIRECT" ; then
	set -- $(stty size < "$REDIRECT"  2> /dev/null || echo 0 0)
    else
	set -- $(stty size 2> /dev/null || echo 0 0)
    fi
    LINES=$1
    COLUMNS=$2
    if test $LINES -eq 0 -o $COLUMNS -eq 0; then
	LINES=24
	COLUMNS=80
	TERM=dumb
    fi
}
trap 'rc_lc' SIGWINCH
test -n "$COLUMNS" -a -n "$LINES" || rc_lc
export LINES COLUMNS

# Make sure we have /sbin and /usr/sbin in PATH
case ":$PATH:" in 
    *:/sbin:*)
	;;
    *)
	PATH=/sbin:/usr/sbin:/usr/local/sbin:$PATH
	export PATH
	;;
esac

if test -t 1 -a "$TERM" != "raw" -a "$TERM" != "dumb"; then
	 esc=`echo -en "\033"`
        extd="${esc}[1m"
        warn="${esc}[1;31m"
        done="${esc}[1;32m"
        attn="${esc}[1;33m"
        norm=`echo -en "${esc}[m\017"`
        stat=`echo -en "\015${esc}[${COLUMNS}C${esc}[10D"`

     rc_done="${stat}${done}done${norm}"
  rc_running="${stat}${done}running${norm}"
   rc_failed="${stat}${warn}failed${norm}"
   rc_missed="${stat}${warn}missing${norm}"
  rc_skipped="${stat}${attn}skipped${norm}"
     rc_dead="${stat}${warn}dead${norm}"
   rc_unused="${stat}${extd}unused${norm}"
  rc_unknown="${stat}${attn}unknown${norm}"
  rc_done_up="${esc}[1A${rc_done}"
rc_failed_up="${esc}[1A${rc_failed}"
    rc_reset="${norm}${esc}[?25h"
     rc_save="${esc}7${esc}[?25l"
  rc_restore="${esc}8${esc}[?25h"
    rc_cuu () { test $1 -eq 0 && return; echo -en "\033[${1}A"; }
    rc_cud () { test $1 -eq 0 && return; echo -en "\033[${1}B"; }
    rc_timer_on () {
	# Draw seconds of running timout to column.
	# Two arguments: timeout in seconds and offset
	local n=$1
	local c=$2
	(trap "exit 0" SIGTERM
	 while test $((n--)) -gt 0; do
	    sleep 1;
	    if test $n -gt 9 ; then
		echo -en "\015${esc}[${c}C(${n}s) "
	    else
		echo -en "\015${esc}[${c}C( ${n}s) "
	    fi
	done) & _rc_timer_pid=$!
    }
    rc_timer_off () {
	if test -n "$_rc_timer_pid" ; then
	    kill -TERM $_rc_timer_pid > /dev/null 2>&1
	fi
	unset _rc_timer_pid
    }
else
	 esc=""
        extd=""
        warn=""
        done=""
        attn=""
        norm=""
        stat=""

     rc_done="..done"
  rc_running="..running"
   rc_failed="..failed"
   rc_missed="..missing"
  rc_skipped="..skipped"
     rc_dead="..dead"
   rc_unused="..unused"
  rc_unknown="..unknown"
  rc_done_up="${rc_done}"
rc_failed_up="${rc_failed}"
    rc_reset=""
     rc_save=""
  rc_restore=""
    rc_cuu () { return; }
    rc_cud () { return; }
    rc_timer_on  () { return; }
    rc_timer_off () { return; }
fi

_rc_service=${0##*/[SK][0-9][0-9]}
_rc_status=0
_rc_status_all=0
_rc_todo=$1

rc_check ()
{
    _rc_status_ret=$?
    test $_rc_status_ret -eq 0 || _rc_status=$_rc_status_ret
    test $_rc_status     -eq 0 || _rc_status_all=$_rc_status
    return $_rc_status_ret
}

rc_reset ()
{
    _rc_status=0
    _rc_status_all=0
    rc_check
    return 0
}

if   test "$_rc_todo" = "status" ; then
rc_status ()
{
    rc_check
    _rc_status_ret=$_rc_status
    local i
    for i ; do
	case "$i" in
	-v|-v[1-9]|-v[1-9][0-9])
	    local vrt=""
	    local out=1
	    local opt="en"

	    test -n "${i#-v}" && vrt=${esc:+"${esc}[${i#-v}A"} || opt="e"
	    case "$_rc_status" in
	    0)	vrt="$vrt$rc_running";		;; # service running
	    1)	vrt="$vrt$rc_dead"   ; out=2	;; # service dead (but has pid file)
	    2)	vrt="$vrt$rc_dead"   ; out=2	;; # service dead (but has lock file)
	    3)	vrt="$vrt$rc_unused" ;		;; # service not running
	    4)	vrt="$vrt$rc_unknown";		;; # status is unknown
	    esac
	    echo -$opt "$rc_save$vrt$rc_restore" 1>&$out

	    # reset _rc_status to 0 after verbose case
	    _rc_status=0 ;;
	-r) rc_reset ;;
	-s) echo -e "$rc_skipped" ; rc_failed 3 ;;
	-u) echo -e "$rc_unused"  ; rc_failed 3 ;;
	*)  echo "rc_status: Usage: [-v[<num>] [-r]|-s|-u]" 1>&2 ; return 0 ;;
	esac
    done
    return $_rc_status_ret
}
elif test -n "$_rc_todo" ; then
rc_status ()
{
    rc_check
    test "$_rc_status" -gt 7 && rc_failed 1
    _rc_status_ret=$_rc_status
    case "$_rc_todo" in
    stop)
	# program is not running which
	# is success if we stop service
	test "$_rc_status" -eq 7 && rc_failed 0 ;;
    esac
    local i
    for i ; do
	case "$i" in
	-v|-v[1-9]|-v[1-9][0-9])
	    local vrt=""
	    local out=1
	    local opt="en"

	    test -n "${i#-v}" && vrt=${esc:+"${esc}[${i#-v}A"} || opt="e"
	    case "$_rc_status" in
	    0)	vrt="$vrt$rc_done"   ;		;; # success
	    1)	vrt="$vrt$rc_failed" ; out=2	;; # generic or unspecified error
	    2)	vrt="$vrt$rc_failed" ; out=2	;; # invalid or excess args
	    3)	vrt="$vrt$rc_missed" ; out=2	;; # unimplemented feature
	    4)	vrt="$vrt$rc_failed" ; out=2	;; # insufficient privilege
	    5)	vrt="$vrt$rc_skipped"; out=2	;; # program is not installed
	    6)	vrt="$vrt$rc_unused" ; out=2	;; # program is not configured
	    7)	vrt="$vrt$rc_failed" ; out=2	;; # program is not running
	    *)	vrt="$vrt$rc_failed" ; out=2	;; # unknown (maybe used in future)
	    esac
	    echo -$opt "$rc_save$vrt$rc_restore" 1>&$out

	    # reset _rc_status to 0 after verbose case
	    _rc_status=0 ;;
	-r) rc_reset ;;
	-s) echo -e "$rc_skipped" 1>&2 ; rc_failed 5 ;;
	-u) echo -e "$rc_unused"  1>&2 ; rc_failed 6 ;;
	*)  echo "rc_status: Usage: [-v[<num>] [-r]|-s|-u]" 1>&2 ; return 0 ;;
	esac
    done
    return $_rc_status_ret
}
else
rc_status ()
{
    rc_check
    _rc_status_ret=$_rc_status
    local i
    for i ; do
	case "$i" in
	-v|-v[1-9]|-v[1-9][0-9])
	    local vrt=""
	    local out=1
	    local opt="en"

	    test -n "${i#-v}" && vrt=${esc:+"${esc}[${i#-v}A"} || opt="e"
	    case "$_rc_status" in
	    0)	vrt="$vrt$rc_done"  ;		;; # success
	    *)	vrt="$vrt$rc_failed"; out=2	;; # failed
	    esac
	    echo -$opt "$rc_save$vrt$rc_restore" 1>&$out

	    # reset _rc_status to 0 after verbose case
	    _rc_status=0 ;;
	-r) rc_reset ;;
	-s) echo -e "$rc_skipped"  ; return 0 ;;
	-u) echo -e "$rc_unused"   ; return 0 ;;
	*)  echo "rc_status: Usage: [-v[<num>] [-r]|-s|-u]" 1>&2 ; return 0 ;;
	esac
    done
    return $_rc_status_ret
}
fi

rc_failed ()
{
    rc_reset
    case "$1" in
    [0-7]) _rc_status=$1 ;;
    "")    _rc_status=1
    esac
    rc_check
    return $_rc_status
}

rc_exit ()
{
    exit $_rc_status_all
}

rc_confirm()
{
    local timeout="30"
    local answer=""
    local ret=0

    case "$1" in
    -t) timeout=$2; shift 2 ;;
    esac
    local message="$@, (Y)es/(N)o/(C)ontinue? [y] "
    : ${REDIRECT:=/dev/tty}

    while true ; do
	read -t ${timeout} -n 1 -p "${message}" answer < $REDIRECT > $REDIRECT 2>&1
	case "$answer" in
	[yY]|"") ret=0; break ;;
	[nN])	 ret=1; break ;;
	[cC])	 ret=2; break ;;
	*)	 echo; continue
	esac
    done
    echo
    return $ret
}

rc_active ()
{
    local link
    for link in /etc/init.d/*.d/S[0-9][0-9]${1} ; do
	test -e $link || break
	return 0
    done
    return 1
}

rc_splash()
{
    return 0
}

# Wait between last SIGTERM and the next SIGKILL
# any argument specify a *path* of a process which
# process identity should *not* be checked.
rc_wait()
{
    local -i etime=$SECONDS

    if test -f /fastboot ; then
	let etime+=2
    else
	let etime+=6
    fi

    local -i pid
    local -i ppid=$$
    local comm state rest
    local parent_processes="$ppid"

    while test $ppid -gt 1; do
	read -t 1 pid comm state ppid rest < /proc/$ppid/stat
	parent_processes="${parent_processes:+$parent_processes:}${ppid}"
    done
    for comm ; do
	test -s $comm || continue
	ppid="$(/sbin/pidofproc $comm 2> /dev/null)" || continue
	parent_processes="${parent_processes:+$parent_processes:}${ppid}"
    done
    unset comm state ppid rest

    local -i busy
    while test $SECONDS -lt $etime; do
	let busy=0
	for proc in /proc/[0-9]* ; do
	    test -e $proc/exe || continue
	    let pid=${proc##*/}
	    case ":${parent_processes}:" in
	    *:${pid}:*) continue
	    esac
	    let busy=pid
	    break
	done
	test $busy -ne 0 || return 0
	usleep 500000
    done
}

rc_runlevel()
{
    test -z "$RUNLEVEL" || return
    set -- $(/sbin/runlevel)
    PREVLEVEL=$1
    RUNLEVEL=$2
    export PREVLEVEL RUNLEVEL
}

cmdline=""
rc_cmdline()
{
    local arg cmd key val
    test -e /proc/cmdline || mount -nt proc proc /proc
    test -n "$cmdline"    || read -t 2 cmdline < /proc/cmdline
    for arg; do
	for cmd in $cmdline ; do
	    key="${cmd%%=*}"
	    key="${key//-/_}"
	    case "${key}" in
	    $arg)
		case "$cmd" in
		*=*) val="${cmd#*=}" ;;
		*)   val=yes
		esac
		echo $key=$val
		return 0
	    esac
	done
    done
    return 1
}

# /lib/lsb/init-functions for Debian -*- shell-script -*-
#
#Copyright (c) 2002-08 Chris Lawrence
#All rights reserved.
#
#Redistribution and use in source and binary forms, with or without
#modification, are permitted provided that the following conditions
#are met:
#1. Redistributions of source code must retain the above copyright
#   notice, this list of conditions and the following disclaimer.
#2. Redistributions in binary form must reproduce the above copyright
#   notice, this list of conditions and the following disclaimer in the
#   documentation and/or other materials provided with the distribution.
#3. Neither the name of the author nor the names of other contributors
#   may be used to endorse or promote products derived from this software
#   without specific prior written permission.
#
#THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
#IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
#ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
#LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
#CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
#SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
#BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
#WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
#OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
#EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

start_daemon () {
    local force nice pidfile exec args OPTIND
    force=""
    nice=0
    pidfile=/dev/null

    OPTIND=1
    while getopts fn:p: opt ; do
        case "$opt" in
            f)  force="force";;
            n)  nice="$OPTARG";;
            p)  pidfile="$OPTARG";;
        esac
    done
    
    shift $(($OPTIND - 1))
    if [ "$1" = '--' ]; then
        shift
    fi

    exec="$1"; shift

    args="--start --nicelevel $nice --quiet --oknodo"
    if [ "$force" ]; then
        /sbin/start-stop-daemon $args \
	    --chdir "$PWD" --startas $exec --pidfile /dev/null -- "$@"
    elif [ $pidfile ]; then
        /sbin/start-stop-daemon $args \
	    --chdir "$PWD" --exec $exec --oknodo --pidfile "$pidfile" -- "$@"
    else
        /sbin/start-stop-daemon $args --chdir "$PWD" --exec $exec -- "$@"
    fi
}

pidofproc () {
    local pidfile base status specified pid OPTIND
    pidfile=
    specified=
    
    OPTIND=1
    while getopts p: opt ; do
        case "$opt" in
            p)  pidfile="$OPTARG"
                specified="specified"
		;;
        esac
    done
    shift $(($OPTIND - 1))

    base=${1##*/}
    if [ ! "$specified" ]; then
        pidfile="/var/run/$base.pid"
    fi

    if [ -n "${pidfile:-}" ]; then
     if [ -e "$pidfile" ]; then
      if [ -r "$pidfile" ]; then
        read pid < "$pidfile"
        if [ -n "${pid:-}" ]; then
            if $(kill -0 "${pid:-}" 2> /dev/null); then
                echo "$pid" || true
                return 0
            elif ps "${pid:-}" >/dev/null 2>&1; then
                echo "$pid" || true
                return 0 # program is running, but not owned by this user
            else
                return 1 # program is dead and /var/run pid file exists
            fi
        fi
      else
        return 4 # pid file not readable, hence status is unknown.
      fi
     else
       # pid file doesn't exist, try to find the pid nevertheless
       if [ -x /bin/pidof ] && [ ! "$specified" ]; then
         status="0"
         /bin/pidof -o %PPID -x $1 || status="$?"
         if [ "$status" = 1 ]; then
             return 3 # program is not running
         fi
         return 0
       fi
       return 3 # specified pid file doesn't exist, program probably stopped
     fi
    fi
    if [ "$specified" ]; then
        return 3 # almost certain it's not running
    fi
    return 4 # Unable to determine status
}

# start-stop-daemon uses the same algorithm as "pidofproc" above.
killproc () {
    local pidfile sig status base name_param is_term_sig OPTIND
    pidfile=
    name_param=
    is_term_sig=

    OPTIND=1
    while getopts p: opt ; do
        case "$opt" in
            p)  pidfile="$OPTARG";;
        esac
    done
    shift $(($OPTIND - 1))

    base=${1##*/}
    if [ ! $pidfile ]; then
        name_param="--name $base --pidfile /var/run/$base.pid"
    else
        name_param="--pidfile $pidfile"
    fi

    sig=$(echo ${2:-} | sed -e 's/^-\(.*\)/\1/')
    sig=$(echo $sig | sed -e 's/^SIG\(.*\)/\1/')
    if [ "$sig" = 15 ] || [ "$sig" = TERM ]; then
        is_term_sig="terminate_signal"
    fi
    status=0
    if [ ! "$is_term_sig" ]; then
        if [ -n "$sig" ]; then
            /sbin/start-stop-daemon --stop --signal "$sig" \
		--quiet $name_param || status="$?"
        else
            /sbin/start-stop-daemon --stop \
		--retry 5 \
		--quiet $name_param || status="$?"
        fi
    else
        /sbin/start-stop-daemon --stop --quiet \
	    --oknodo $name_param || status="$?"
    fi
    if [ "$status" = 1 ]; then
        if [ -z "$sig" ]; then
            return 0
        fi
        return 3 # program is not running
    fi

    if [ "$status" = 0 ] && [ "$is_term_sig" ] && [ "$pidfile" ]; then
        pidofproc -p "$pidfile" "$1" >/dev/null || rm -f "$pidfile"
    fi
    return 0
}

# Return LSB status
status_of_proc () {
    local pidfile daemon name status OPTIND

    pidfile=
    OPTIND=1
    while getopts p: opt ; do
        case "$opt" in
            p)  pidfile="$OPTARG";;
        esac
    done
    shift $(($OPTIND - 1))

    if [ -n "$pidfile" ]; then
        pidfile="-p $pidfile"
    fi
    daemon="$1"
    name="$2"

    status="0"
    pidofproc $pidfile $daemon >/dev/null || status="$?"
    if [ "$status" = 0 ]; then
        log_success_msg "$name is running"
        return 0
    elif [ "$status" = 4 ]; then
        log_failure_msg "could not access PID file for $name"
        return $status
    else
        log_failure_msg "$name is not running"
        return $status
    fi
}

log_use_fancy_output () {
    TPUT=/usr/bin/tput
    EXPR=/usr/bin/expr
    if  [ -t 1 ] &&
	[ "x${TERM:-}" != "x" ] &&
	[ "x${TERM:-}" != "xdumb" ] &&
	[ -x $TPUT ] && [ -x $EXPR ] &&
	$TPUT hpa 60 >/dev/null 2>&1 &&
	$TPUT setaf 1 >/dev/null 2>&1
    then
        [ -z $FANCYTTY ] && FANCYTTY=1 || true
    else
        FANCYTTY=0
    fi
    case "$FANCYTTY" in
        1|Y|yes|true)   true;;
        *)              false;;
    esac
}

log_success_msg () {
    if [ -n "${1:-}" ]; then
        log_begin_msg $@
    fi
    log_end_msg 0
}

log_failure_msg () {
    if [ -n "${1:-}" ]; then
        log_begin_msg $@ "..."
    fi
    log_end_msg 1 || true
}

log_warning_msg () {
    if [ -n "${1:-}" ]; then
        log_begin_msg $@ "..."
    fi
    log_end_msg 255 || true
}

#
# NON-LSB HELPER FUNCTIONS
#
# int get_lsb_header_val (char *scriptpathname, char *key)
get_lsb_header_val () {
        if [ ! -f "$1" ] || [ -z "${2:-}" ]; then
                return 1
        fi
        LSB_S="### BEGIN INIT INFO"
        LSB_E="### END INIT INFO"
        sed -n "/$LSB_S/,/$LSB_E/ s/# $2: \(.*\)/\1/p" $1
}

# If the currently running init daemon is upstart, return zero; if the
# calling init script belongs to a package which also provides a native
# upstart job, it should generally exit non-zero in this case.
init_is_upstart()
{
   if [ -x /sbin/initctl ] && /sbin/initctl version | /bin/grep -q upstart; then
       return 0
   fi
   return 1
}

# int log_begin_message (char *message)
log_begin_msg () {
    log_begin_msg_pre "$@"
    if [ -z "${1:-}" ]; then
        return 1
    fi
    /bin/echo -n "$@" || true
    log_begin_msg_post "$@"
}

# Sample usage:
# log_daemon_msg "Starting GNOME Login Manager" "gdm"
#
# On Debian, would output "Starting GNOME Login Manager: gdm"
# On Ubuntu, would output " * Starting GNOME Login Manager..."
#
# If the second argument is omitted, logging suitable for use with
# log_progress_msg() is used:
#
# log_daemon_msg "Starting remote filesystem services"
#
# On Debian, would output "Starting remote filesystem services:"
# On Ubuntu, would output " * Starting remote filesystem services..."

log_daemon_msg () {
    if [ -z "${1:-}" ]; then
        return 1
    fi
    log_daemon_msg_pre "$@"

    if [ -z "${2:-}" ]; then
        /bin/echo -n "$1:" || true
        return
    fi
    
    /bin/echo -n "$1: $2" || true
    log_daemon_msg_post "$@"
}

# #319739
#
# Per policy docs:
#
#     log_daemon_msg "Starting remote file system services"
#     log_progress_msg "nfsd"; start-stop-daemon --start --quiet nfsd
#     log_progress_msg "mountd"; start-stop-daemon --start --quiet mountd
#     log_progress_msg "ugidd"; start-stop-daemon --start --quiet ugidd
#     log_end_msg 0
#
# You could also do something fancy with log_end_msg here based on the
# return values of start-stop-daemon; this is left as an exercise for
# the reader...
#
# On Ubuntu, one would expect log_progress_msg to be a no-op.
log_progress_msg () {
    if [ -z "${1:-}" ]; then
        return 1
    fi
    /bin/echo -n " $@" || true
}


# int log_end_message (int exitstatus)
log_end_msg () {
    # If no arguments were passed, return
    if [ -z "${1:-}" ]; then
        return 1
    fi

    local retval
    retval=$1

    log_end_msg_pre "$@"

    # Only do the fancy stuff if we have an appropriate terminal
    # and if /usr is already mounted
    if log_use_fancy_output; then
        RED=$( $TPUT setaf 1)
        YELLOW=$( $TPUT setaf 3)
        NORMAL=$( $TPUT op)
    else
        RED=''
        YELLOW=''
        NORMAL=''
    fi

    if [ $1 -eq 0 ]; then
        echo "." || true
    elif [ $1 -eq 255 ]; then
        /bin/echo -e " ${YELLOW}(warning).${NORMAL}" || true
    else
        /bin/echo -e " ${RED}failed!${NORMAL}" || true
    fi
    log_end_msg_post "$@"
    return $retval
}

log_action_msg () {
    log_action_msg_pre "$@"
    echo "$@." || true
    log_action_msg_post "$@"
}

log_action_begin_msg () {
    log_action_begin_msg_pre "$@"
    /bin/echo -n "$@..." || true
    log_action_begin_msg_post "$@"
}

log_action_cont_msg () {
    /bin/echo -n "$@..." || true
}

log_action_end_msg () {
    local end
    log_action_end_msg_pre "$@"
    if [ -z "${2:-}" ]; then
        end="."
    else
        end=" ($2)."
    fi

    if [ $1 -eq 0 ]; then
        echo "done${end}" || true
    else
        if log_use_fancy_output; then
            RED=$( $TPUT setaf 1)
            NORMAL=$( $TPUT op)
            /bin/echo -e "${RED}failed${end}${NORMAL}" || true
        else
            echo "failed${end}" || true
        fi
    fi
    log_action_end_msg_post "$@"
}

# Pre&Post empty function declaration, to be overriden from /lib/lsb/init-functions.d/*
log_daemon_msg_pre () { :; }
log_daemon_msg_post () { :; }
log_begin_msg_pre () { :; }
log_begin_msg_post () { :; }
log_end_msg_pre () { :; }
log_end_msg_post () { :; }
log_action_msg_pre () { :; }
log_action_msg_post () { :; }
log_action_begin_msg_pre () { :; }
log_action_begin_msg_post () { :; }
log_action_end_msg_pre () { :; }
log_action_end_msg_post () { :; }

# Include hooks from other packages in /lib/lsb/init-functions.d
for hook in $(run-parts --lsbsysinit --list /lib/lsb/init-functions.d 2>/dev/null); do
    [ -r $hook ] && . $hook || true
done

FANCYTTY=
[ -e /etc/lsb-base-logging.sh ] && . /etc/lsb-base-logging.sh || true
