From: intrigeri <intrigeri@boum.org>
Date: Fri, 29 Jun 2012 17:25:02 +0200
Subject: Disable t/sharelite.t (Closes: #625828).

According to Ben Hutchings, "Mapping the same shared memory twice in one process
is stupid, anyway." (Message #99 on bug #679449).
---
 t/sharelite.t          |   88 ------------------------------------------------
 t/sharelite.t.disabled |   88 ++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 88 insertions(+), 88 deletions(-)
 delete mode 100644 t/sharelite.t
 create mode 100644 t/sharelite.t.disabled

diff --git a/t/sharelite.t b/t/sharelite.t
deleted file mode 100644
index b2d02b5..0000000
--- a/t/sharelite.t
+++ /dev/null
@@ -1,88 +0,0 @@
-use strict;
-use warnings;
-use Test::More tests => 14;
-use File::Spec;
-
-my $log_file = $ENV{IPC_SHARELITE_LOG}
- = File::Spec->catfile( 't', "sl-$$.log" );
-
-use_ok 'IPC::ShareLite', qw( LOCK_EX LOCK_SH LOCK_UN LOCK_NB );
-
-######################### End of black magic.
-
-# If a semaphore or shared memory segment already uses this
-# key, all tests will fail
-my $KEY = 192;
-
-# Test object construction
-ok my $share = IPC::ShareLite->new(
-  -key     => $KEY,
-  -create  => 'yes',
-  -destroy => 'yes',
-  -size    => 100
- ),
- 'new';
-
-isa_ok $share, 'IPC::ShareLite';
-
-is $share->version, 1, 'version';
-
-# Store value
-ok $share->store( 'maurice' ), 'store';
-
-is $share->version, 2, 'version inc';
-
-# Retrieve value
-is $share->fetch, 'maurice', 'fetch';
-
-# Fragmented store
-ok $share->store( "X" x 200 ), 'frag store';
-
-is $share->version, 3, 'version inc';
-
-# Check number of segments
-is $share->num_segments, 3, 'num_segments';
-
-# Fragmented fetch
-is $share->fetch, ( 'X' x 200 ), 'frag fetch';
-
-$share->store( 0 );
-
-is $share->version, 4, 'version inc';
-
-my $pid = fork;
-defined $pid or die $!;
-if ( $pid == 0 ) {
-  $share->destroy( 0 );
-  for ( 1 .. 1000 ) {
-    $share->lock( LOCK_EX() ) or die $!;
-    my $val = $share->fetch;
-    $share->store( ++$val ) or die $!;
-    $share->unlock or die $!;
-  }
-  exit;
-}
-else {
-  for ( 1 .. 1000 ) {
-    $share->lock( LOCK_EX() ) or die $!;
-    my $val = $share->fetch;
-    $share->store( ++$val ) or die $!;
-    $share->unlock or die $!;
-  }
-  wait;
-}
-
-is $share->fetch,   2000, 'lock';
-is $share->version, 2004, 'version inc';
-
-if ( -f $log_file ) {
-  if ( -s $log_file ) {
-    open my $lh, '<', $log_file or die "Can't read $log_file ($!)\n";
-    while ( <$lh> ) {
-      chomp;
-      diag $_;
-    }
-  }
-  unlink $log_file;
-}
-
diff --git a/t/sharelite.t.disabled b/t/sharelite.t.disabled
new file mode 100644
index 0000000..b2d02b5
--- /dev/null
+++ b/t/sharelite.t.disabled
@@ -0,0 +1,88 @@
+use strict;
+use warnings;
+use Test::More tests => 14;
+use File::Spec;
+
+my $log_file = $ENV{IPC_SHARELITE_LOG}
+ = File::Spec->catfile( 't', "sl-$$.log" );
+
+use_ok 'IPC::ShareLite', qw( LOCK_EX LOCK_SH LOCK_UN LOCK_NB );
+
+######################### End of black magic.
+
+# If a semaphore or shared memory segment already uses this
+# key, all tests will fail
+my $KEY = 192;
+
+# Test object construction
+ok my $share = IPC::ShareLite->new(
+  -key     => $KEY,
+  -create  => 'yes',
+  -destroy => 'yes',
+  -size    => 100
+ ),
+ 'new';
+
+isa_ok $share, 'IPC::ShareLite';
+
+is $share->version, 1, 'version';
+
+# Store value
+ok $share->store( 'maurice' ), 'store';
+
+is $share->version, 2, 'version inc';
+
+# Retrieve value
+is $share->fetch, 'maurice', 'fetch';
+
+# Fragmented store
+ok $share->store( "X" x 200 ), 'frag store';
+
+is $share->version, 3, 'version inc';
+
+# Check number of segments
+is $share->num_segments, 3, 'num_segments';
+
+# Fragmented fetch
+is $share->fetch, ( 'X' x 200 ), 'frag fetch';
+
+$share->store( 0 );
+
+is $share->version, 4, 'version inc';
+
+my $pid = fork;
+defined $pid or die $!;
+if ( $pid == 0 ) {
+  $share->destroy( 0 );
+  for ( 1 .. 1000 ) {
+    $share->lock( LOCK_EX() ) or die $!;
+    my $val = $share->fetch;
+    $share->store( ++$val ) or die $!;
+    $share->unlock or die $!;
+  }
+  exit;
+}
+else {
+  for ( 1 .. 1000 ) {
+    $share->lock( LOCK_EX() ) or die $!;
+    my $val = $share->fetch;
+    $share->store( ++$val ) or die $!;
+    $share->unlock or die $!;
+  }
+  wait;
+}
+
+is $share->fetch,   2000, 'lock';
+is $share->version, 2004, 'version inc';
+
+if ( -f $log_file ) {
+  if ( -s $log_file ) {
+    open my $lh, '<', $log_file or die "Can't read $log_file ($!)\n";
+    while ( <$lh> ) {
+      chomp;
+      diag $_;
+    }
+  }
+  unlink $log_file;
+}
+
