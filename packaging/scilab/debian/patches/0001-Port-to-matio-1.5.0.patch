From dcbfdc689e39aac0282dfea170c4731f38ae4598 Mon Sep 17 00:00:00 2001
From: Sylvestre Ledru <sylvestre.ledru@scilab-enterprises.com>
Date: Mon, 12 Mar 2012 13:31:38 +0100
Subject: [PATCH] * Port to matio 1.5.0 * Code cleaning * Prepare code for
 Scilab 6 (YaSp branch merge)

Change-Id: Ib15dd089e6172ebb84f5f3b6dbd93741cba0db53
---
 scilab/configure                                   |   40 +-
 scilab/configure.ac                                |    9 +-
 scilab/modules/core/includes/machine.h.in          |    3 -
 scilab/modules/matio/sci_gateway/c/gw_matio.c      |   32 +-
 .../matio/sci_gateway/c/sci_matfile_close.c        |  121 ++---
 .../matio/sci_gateway/c/sci_matfile_listvar.c      |   22 +-
 .../modules/matio/sci_gateway/c/sci_matfile_open.c |  264 +++++------
 .../matio/sci_gateway/c/sci_matfile_varreadnext.c  |  198 +++++----
 .../matio/sci_gateway/c/sci_matfile_varwrite.c     |  245 +++++-----
 scilab/modules/matio/src/c/CreateBooleanVariable.c |  143 +++---
 scilab/modules/matio/src/c/CreateCellVariable.c    |  139 +++---
 scilab/modules/matio/src/c/CreateCharVariable.c    |  158 +++----
 scilab/modules/matio/src/c/CreateDoubleVariable.c  |  107 +++--
 .../matio/src/c/CreateHyperMatrixVariable.c        |   98 ++--
 scilab/modules/matio/src/c/CreateIntegerVariable.c |  467 ++++++++++++--------
 scilab/modules/matio/src/c/CreateMatlabVariable.c  |  135 +++---
 scilab/modules/matio/src/c/CreateMatlabVariable.h  |   73 +--
 scilab/modules/matio/src/c/CreateSparseVariable.c  |  343 +++++++-------
 scilab/modules/matio/src/c/CreateStructVariable.c  |  205 +++++----
 scilab/modules/matio/src/c/GetCellVariable.c       |  118 +++--
 scilab/modules/matio/src/c/GetCharVariable.c       |  144 +++---
 scilab/modules/matio/src/c/GetDoubleVariable.c     |  186 +++++---
 scilab/modules/matio/src/c/GetIntegerVariable.c    |  296 ++++++++-----
 scilab/modules/matio/src/c/GetMatlabVariable.c     |   80 ++--
 scilab/modules/matio/src/c/GetMatlabVariable.h     |   48 +-
 scilab/modules/matio/src/c/GetMlistVariable.c      |  136 +++---
 scilab/modules/matio/src/c/GetSparseVariable.c     |  131 ++++--
 scilab/modules/matio/src/c/GetStructVariable.c     |   45 +-
 scilab/modules/matio/src/c/matfile_manager.c       |  102 ++---
 .../matio/tests/nonreg_tests/bug_5462.dia.ref      |    5 +-
 .../modules/matio/tests/nonreg_tests/bug_5462.tst  |    4 +-
 31 files changed, 2320 insertions(+), 1777 deletions(-)

diff --git a/configure b/configure
index 44c4a19..628e5fe 100755
--- a/configure
+++ b/configure
@@ -25544,7 +25544,7 @@ MATIO_ENABLE=no
 if test "$with_matio" != no; then
    if test -n "$with_matio_include" -o -n "$with_matio_library" ; then
       MATIO_CFLAGS="$with_matio_include"
-      MATIO_LIBS="$with_matio_library -lm -lz -lmatio"
+      MATIO_LIBS="$with_matio_library -lm -lz -lmatio -lhdf5"
    else
 
 pkg_failed=no
@@ -25556,12 +25556,12 @@ if test -n "$PKG_CONFIG"; then
         pkg_cv_MATIO_CFLAGS="$MATIO_CFLAGS"
     else
         if test -n "$PKG_CONFIG" && \
-    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"matio >= 1.3.3\""; } >&5
-  ($PKG_CONFIG --exists --print-errors "matio >= 1.3.3") 2>&5
+    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"matio >= 1.5.0\""; } >&5
+  ($PKG_CONFIG --exists --print-errors "matio >= 1.5.0") 2>&5
   ac_status=$?
   $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
   test $ac_status = 0; }; then
-  pkg_cv_MATIO_CFLAGS=`$PKG_CONFIG --cflags "matio >= 1.3.3" 2>/dev/null`
+  pkg_cv_MATIO_CFLAGS=`$PKG_CONFIG --cflags "matio >= 1.5.0" 2>/dev/null`
 else
   pkg_failed=yes
 fi
@@ -25574,12 +25574,12 @@ if test -n "$PKG_CONFIG"; then
         pkg_cv_MATIO_LIBS="$MATIO_LIBS"
     else
         if test -n "$PKG_CONFIG" && \
-    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"matio >= 1.3.3\""; } >&5
-  ($PKG_CONFIG --exists --print-errors "matio >= 1.3.3") 2>&5
+    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"matio >= 1.5.0\""; } >&5
+  ($PKG_CONFIG --exists --print-errors "matio >= 1.5.0") 2>&5
   ac_status=$?
   $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
   test $ac_status = 0; }; then
-  pkg_cv_MATIO_LIBS=`$PKG_CONFIG --libs "matio >= 1.3.3" 2>/dev/null`
+  pkg_cv_MATIO_LIBS=`$PKG_CONFIG --libs "matio >= 1.5.0" 2>/dev/null`
 else
   pkg_failed=yes
 fi
@@ -25598,14 +25598,14 @@ else
         _pkg_short_errors_supported=no
 fi
         if test $_pkg_short_errors_supported = yes; then
-	        MATIO_PKG_ERRORS=`$PKG_CONFIG --short-errors --errors-to-stdout --print-errors "matio >= 1.3.3"`
+	        MATIO_PKG_ERRORS=`$PKG_CONFIG --short-errors --errors-to-stdout --print-errors "matio >= 1.5.0"`
         else
-	        MATIO_PKG_ERRORS=`$PKG_CONFIG --errors-to-stdout --print-errors "matio >= 1.3.3"`
+	        MATIO_PKG_ERRORS=`$PKG_CONFIG --errors-to-stdout --print-errors "matio >= 1.5.0"`
         fi
 	# Put the nasty error message in config.log where it belongs
 	echo "$MATIO_PKG_ERRORS" >&5
 
-	as_fn_error $? "Package requirements (matio >= 1.3.3) were not met:
+	as_fn_error $? "Package requirements (matio >= 1.5.0) were not met:
 
 $MATIO_PKG_ERRORS
 
@@ -25644,13 +25644,12 @@ fi
    CFLAGS="$CFLAGS $MATIO_CFLAGS"
    LIBS="$LIBS $MATIO_LIBS"
 
-   for ac_header in matio.h matioConfig.h
+   for ac_header in matio.h
 do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
-if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  ac_fn_c_check_header_mongrel "$LINENO" "matio.h" "ac_cv_header_matio_h" "$ac_includes_default"
+if test "x$ac_cv_header_matio_h" = xyes; then :
   cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+#define HAVE_MATIO_H 1
 _ACEOF
 
 else
@@ -25722,6 +25721,9 @@ fi
 $as_echo "#define WITH_MATIO /**/" >>confdefs.h
 
    MATIO_ENABLE=yes
+
+
+
 fi
 
 
@@ -25791,7 +25793,7 @@ $as_echo_n "checking saxon... " >&6; }
             export ac_java_classpath="$jar_resolved:$ac_java_classpath"
 
     cat << \EOF > conftest.java
-// #line 25794 "configure"
+// #line 25796 "configure"
 import java.util.regex.Pattern;
 
 import com.icl.saxon.Loader;
@@ -25908,7 +25910,7 @@ $as_echo_n "checking jlatexmath-fop... " >&6; }
             export ac_java_classpath="$jar_resolved:$ac_java_classpath"
 
     cat << \EOF > conftest.java
-// #line 25911 "configure"
+// #line 25913 "configure"
 import java.util.regex.Pattern;
 
 import org.scilab.forge.jlatexmath.fop.JLaTeXMathObj;
@@ -32336,7 +32338,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 32339 "configure"
+#line 32341 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -32442,7 +32444,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 32445 "configure"
+#line 32447 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
diff --git a/configure.ac b/configure.ac
index 5005667..6226d8f 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1556,9 +1556,9 @@ MATIO_ENABLE=no
 if test "$with_matio" != no; then
    if test -n "$with_matio_include" -o -n "$with_matio_library" ; then
       MATIO_CFLAGS="$with_matio_include"
-      MATIO_LIBS="$with_matio_library -lm -lz -lmatio"
+      MATIO_LIBS="$with_matio_library -lm -lz -lmatio -lhdf5"
    else
-      PKG_CHECK_MODULES(MATIO, [matio >= 1.3.3])
+      PKG_CHECK_MODULES(MATIO, [matio >= 1.5.0])
    fi
 
    save_CFLAGS="$CFLAGS"
@@ -1567,7 +1567,7 @@ if test "$with_matio" != no; then
    CFLAGS="$CFLAGS $MATIO_CFLAGS"
    LIBS="$LIBS $MATIO_LIBS"
 
-   AC_CHECK_HEADERS([matio.h matioConfig.h], [],
+   AC_CHECK_HEADERS([matio.h], [],
      [AC_MSG_ERROR([Invalid MATIO_CFLAGS returned by pkg-config. Try to define MATIO_CFLAGS.])])
    AC_CHECK_LIB([matio], [Mat_Open], [],
      [AC_MSG_ERROR([Invalid MATIO_LIBS returned by pkg-config. Try to define MATIO_LIBS.])])
@@ -1577,6 +1577,9 @@ if test "$with_matio" != no; then
 
    AC_DEFINE([WITH_MATIO], [], [With the MATIO library])
    MATIO_ENABLE=yes
+
+   AC_SUBST(MATIO_LIBS)
+   AC_SUBST(MATIO_CFLAGS)
 fi
 
 
diff --git a/modules/core/includes/machine.h.in b/modules/core/includes/machine.h.in
index c08feab..a783dfa 100644
--- a/modules/core/includes/machine.h.in
+++ b/modules/core/includes/machine.h.in
@@ -176,9 +176,6 @@
 /* Define to 1 if you have the <malloc.h> header file. */
 #undef HAVE_MALLOC_H
 
-/* Define to 1 if you have the <matioConfig.h> header file. */
-#undef HAVE_MATIOCONFIG_H
-
 /* Define to 1 if you have the <matio.h> header file. */
 #undef HAVE_MATIO_H
 
diff --git a/modules/matio/sci_gateway/c/gw_matio.c b/modules/matio/sci_gateway/c/gw_matio.c
index 5e83921..787fdc4 100644
--- a/modules/matio/sci_gateway/c/gw_matio.c
+++ b/modules/matio/sci_gateway/c/gw_matio.c
@@ -1,26 +1,24 @@
 /*
  * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
- * Copyright (C) 2008 - INRIA - Vincent COUVERT 
- * 
+ * Copyright (C) 2008 - INRIA - Vincent COUVERT
+ *
  * This file must be used under the terms of the CeCILL.
  * This source file is licensed as described in the file COPYING, which
  * you should have received as part of this distribution.  The terms
- * are also available at    
+ * are also available at
  * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
  *
  */
 
-/*-----------------------------------------------------------------------------------*/ 
+/*-----------------------------------------------------------------------------------*/
 #include <math.h>
 #include <string.h>
-/*-----------------------------------------------------------------------------------*/ 
+/*-----------------------------------------------------------------------------------*/
 #include "gw_matio.h"
 #include "api_scilab.h"
 #include "MALLOC.h"
 #include "callFunctionFromGateway.h"
-/*-----------------------------------------------------------------------------------*/ 
-int gw_matio(void);
-/*-----------------------------------------------------------------------------------*/ 
+/*-----------------------------------------------------------------------------------*/
 static gw_generic_table Tab[] =
 {
   {sci_matfile_open,"matfile_open"},
@@ -29,19 +27,19 @@ static gw_generic_table Tab[] =
   {sci_matfile_varreadnext,"matfile_varreadnext"},
   {sci_matfile_varwrite,"matfile_varwrite"}
 };
-/*-----------------------------------------------------------------------------------*/  
+/*-----------------------------------------------------------------------------------*/
 int gw_matio(void)
 {
-	Rhs = Max(0, Rhs);
+    Rhs = Max(0, Rhs);
 
     if(pvApiCtx == NULL)
-	{
-		pvApiCtx = (StrCtx*)MALLOC(sizeof(StrCtx));
-	}
+    {
+        pvApiCtx = (StrCtx*)MALLOC(sizeof(StrCtx));
+    }
 
-	pvApiCtx->pstName = (char*)Tab[Fin-1].name;
-	callFunctionFromGateway(Tab, SIZE_CURRENT_GENERIC_TABLE(Tab));
-	return 0;
+    pvApiCtx->pstName = (char*)Tab[Fin-1].name;
+    callFunctionFromGateway(Tab, SIZE_CURRENT_GENERIC_TABLE(Tab));
+    return 0;
 }
-/*-----------------------------------------------------------------------------------*/ 
+/*-----------------------------------------------------------------------------------*/
 
diff --git a/modules/matio/sci_gateway/c/sci_matfile_close.c b/modules/matio/sci_gateway/c/sci_matfile_close.c
index b70fc48..00a67d8 100644
--- a/modules/matio/sci_gateway/c/sci_matfile_close.c
+++ b/modules/matio/sci_gateway/c/sci_matfile_close.c
@@ -1,86 +1,95 @@
 /*
  * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
- * Copyright (C) 2008 - INRIA - Vincent COUVERT 
+ * Copyright (C) 2008 - INRIA - Vincent COUVERT
  * Copyright (C) 2010 - DIGITEO - Yann COLLETTE
- * 
+ *
  * This file must be used under the terms of the CeCILL.
  * This source file is licensed as described in the file COPYING, which
  * you should have received as part of this distribution.  The terms
- * are also available at    
+ * are also available at
  * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
  *
  */
 
 #include "matfile_manager.h"
 #include "localization.h"
+#include "gw_matio.h"
 #include "Scierror.h"
 #include "sciprint.h"
 
 #include "api_scilab.h"
 
-#define MATIO_ERROR if(_SciErr.iErr)	     \
-    {					     \
-      printError(&_SciErr, 0);		     \
-      return 0;				     \
-    }
-
 /*******************************************************************************
 Interface for MATIO function called Mat_Close
 Scilab function name : matfile_close
 *******************************************************************************/
 int sci_matfile_close(char *fname,unsigned long fname_len)
 {
-  mat_t * matfile = NULL;
-  int fileIndex = 0; 
-  int nbRow = 0, nbCol = 0;
-  int * fd_addr = NULL;
-  int flag = 1, var_type;
-  double * fd_val = NULL;
-  SciErr _SciErr;
-  
-  CheckRhs(1, 1);
-  CheckLhs(1, 1);
-  
-  /* First Rhs is the index of the file to close */
-  
-  _SciErr = getVarAddressFromPosition(pvApiCtx, 1, &fd_addr); MATIO_ERROR;
-  _SciErr = getVarType(pvApiCtx, fd_addr, &var_type); MATIO_ERROR;
-  
-  if (var_type == sci_matrix)
+    mat_t * matfile = NULL;
+    int fileIndex = 0; 
+    int nbRow = 0, nbCol = 0;
+    int * fd_addr = NULL;
+    int flag = 1, var_type;
+    double * fd_val = NULL;
+    SciErr sciErr;
+
+    CheckRhs(1, 1);
+    CheckLhs(1, 1);
+
+    /* First Rhs is the index of the file to close */
+    sciErr = getVarAddressFromPosition(pvApiCtx, 1, &fd_addr);
+    if(sciErr.iErr)
+    {
+        printError(&sciErr, 0);
+        return 0;
+    }
+    sciErr = getVarType(pvApiCtx, fd_addr, &var_type);
+    if(sciErr.iErr)
+    {
+        printError(&sciErr, 0);
+        return 0;
+    }
+
+    if (var_type == sci_matrix)
     {
-      _SciErr = getMatrixOfDouble(pvApiCtx, fd_addr, &nbRow, &nbCol, &fd_val); MATIO_ERROR;
-      if (nbRow * nbCol != 1)
-	{
-	  Scierror(999, _("%s: Wrong size for first input argument: Single double expected.\n"), fname);
-	  return FALSE;
-	}
-      fileIndex = (int)*fd_val;
+        sciErr = getMatrixOfDouble(pvApiCtx, fd_addr, &nbRow, &nbCol, &fd_val);
+        if(sciErr.iErr)
+        {
+            printError(&sciErr, 0);
+            return 0;
+        }
+        if (nbRow * nbCol != 1)
+        {
+            Scierror(999, _("%s: Wrong size for first input argument: Single double expected.\n"), fname);
+            return FALSE;
+        }
+        fileIndex = (int)*fd_val;
     }
-  else
+    else
     {
-      Scierror(999, _("%s: Wrong type for first input argument: Double expected.\n"), fname);
-      return FALSE;
+        Scierror(999, _("%s: Wrong type for first input argument: Double expected.\n"), fname);
+        return FALSE;
     }
-  
-  /* Gets the corresponding matfile to close it */
-  /* The manager clears its static matfile table */
-  matfile_manager(MATFILEMANAGER_DELFILE, &fileIndex, &matfile);
-  
-  /* If the file has not already been closed, it's closed */
-  if(matfile!=NULL)
+
+    /* Gets the corresponding matfile to close it */
+    /* The manager clears its static matfile table */
+    matfile_manager(MATFILEMANAGER_DELFILE, &fileIndex, &matfile);
+
+    /* If the file has not already been closed, it's closed */
+    if(matfile!=NULL)
     {
-      flag = Mat_Close(matfile);
+        flag = Mat_Close(matfile);
     }
-  else /* The user is informed */
-    sciprint("File already closed.\n");
-  
-  /* Return execution flag */
-  var_type = (flag == 0);
-  createScalarBoolean(pvApiCtx, Rhs+1, var_type); MATIO_ERROR;
-  
-  LhsVar(1) = Rhs+1;
-  
-  PutLhsVar();
-  
-  return TRUE;
+    else /* The user is informed */
+        sciprint("File already closed.\n");
+
+    /* Return execution flag */
+    var_type = (flag == 0);
+    createScalarBoolean(pvApiCtx, Rhs+1, var_type);
+
+    LhsVar(1) = Rhs+1;
+
+    PutLhsVar();
+
+    return TRUE;
 }
diff --git a/modules/matio/sci_gateway/c/sci_matfile_listvar.c b/modules/matio/sci_gateway/c/sci_matfile_listvar.c
index 8663163..bc75094 100644
--- a/modules/matio/sci_gateway/c/sci_matfile_listvar.c
+++ b/modules/matio/sci_gateway/c/sci_matfile_listvar.c
@@ -82,7 +82,7 @@ int sci_matfile_listvar(char *fname, unsigned long fname_len)
     /* Back to the beginning of the file */
     if (Mat_Rewind(matfile) != 0)
     {
-        Scierror(999, _("%s: Could not rewind the file %s.\n"), "matfile_listvar", matfile->filename);
+        Scierror(999, _("%s: Could not rewind the file %s.\n"), "matfile_listvar", Mat_GetFilename(matfile));
         return FALSE;
     }
 
@@ -122,10 +122,10 @@ int sci_matfile_listvar(char *fname, unsigned long fname_len)
     nbRow = nbvar;
     nbCol = 1;
     sciErr = createMatrixOfString(pvApiCtx, Rhs + 1, nbRow, nbCol, varnames);
-    if (sciErr.iErr)
+    if(sciErr.iErr)
     {
-        printError(&sciErr, 0);
-        return 0;
+      printError(&sciErr, 0);
+      return 0;
     }
     LhsVar(1) = Rhs + 1;
 
@@ -133,7 +133,19 @@ int sci_matfile_listvar(char *fname, unsigned long fname_len)
     if (Lhs >= 2)
     {
         sciErr = createMatrixOfDouble(pvApiCtx, Rhs + 2, nbRow, nbCol, varclasses);
-        if (sciErr.iErr)
+        if(sciErr.iErr)
+        {
+            printError(&sciErr, 0);
+            return 0;
+        }
+        LhsVar(2) = Rhs + 2;
+    }
+
+    /* Return the variable types */
+    if (Lhs >= 3)
+    {
+        sciErr = createMatrixOfDouble(pvApiCtx, Rhs + 3, nbRow, nbCol, vartypes);
+        if(sciErr.iErr)
         {
             printError(&sciErr, 0);
             return 0;
diff --git a/modules/matio/sci_gateway/c/sci_matfile_open.c b/modules/matio/sci_gateway/c/sci_matfile_open.c
index efa956f..b506c00 100644
--- a/modules/matio/sci_gateway/c/sci_matfile_open.c
+++ b/modules/matio/sci_gateway/c/sci_matfile_open.c
@@ -1,12 +1,12 @@
 /*
  * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
- * Copyright (C) 2008 - INRIA - Vincent COUVERT 
+ * Copyright (C) 2008 - INRIA - Vincent COUVERT
  * Copyright (C) 2010 - DIGITEO - Yann COLLETTE
- * 
+ *
  * This file must be used under the terms of the CeCILL.
  * This source file is licensed as described in the file COPYING, which
  * you should have received as part of this distribution.  The terms
- * are also available at    
+ * are also available at
  * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
  *
  */
@@ -18,143 +18,157 @@
 #include "localization.h"
 #include "Scierror.h"
 
-
-
-#define MATIO_ERROR if(_SciErr.iErr) \
-    {				     \
-      printError(&_SciErr, 0);	     \
-      return 0;			     \
-    }
-
 /*******************************************************************************
    Interface for MATIO function called Mat_Open
    Scilab function name : matfile_open
 *******************************************************************************/
-int sci_matfile_open(char *fname,unsigned long fname_len)
+int sci_matfile_open(char *fname, unsigned long fname_len)
 {
-  int nbRow = 0, nbCol = 0;
-  mat_t *matfile;
-  int fileIndex = 0;
-  char * filename  = NULL;
-  char * optionStr = NULL;
-  int option = 0, var_type;
-  int * filename_addr = NULL, * option_addr = NULL;
-  SciErr _SciErr;
-  
-  CheckRhs(1, 2);
-  CheckLhs(1, 1);
-  
-  _SciErr = getVarAddressFromPosition(pvApiCtx, 1, &filename_addr); MATIO_ERROR;
-  _SciErr = getVarType(pvApiCtx, filename_addr, &var_type); MATIO_ERROR;
-  
-  if (var_type == sci_strings)
+    int nbRow = 0, nbCol = 0;
+    mat_t *matfile;
+    int fileIndex = 0;
+    char * filename  = NULL;
+    char * optionStr = NULL;
+    int option = 0, var_type;
+    int * filename_addr = NULL, * option_addr = NULL;
+    SciErr sciErr;
+
+    CheckRhs(1, 2);
+    CheckLhs(1, 1);
+
+    sciErr = getVarAddressFromPosition(pvApiCtx, 1, &filename_addr);
+    if(sciErr.iErr)
     {
-      getAllocatedSingleString(pvApiCtx, filename_addr, &filename);
-      _SciErr = getVarDimension(pvApiCtx, filename_addr, &nbRow, &nbCol); 
-      MATIO_ERROR;
-      
-      if (nbCol != 1) 
-	{
-	  Scierror(999, _("%s: Wrong size for first input argument: Single string expected.\n"), fname);
-	  
-	  freeAllocatedSingleString(filename);
-	  
-	  return FALSE;
-	}
+        printError(&sciErr, 0);
+        return 0;
     }
-  else
+    sciErr = getVarType(pvApiCtx, filename_addr, &var_type);
+    if(sciErr.iErr)
     {
-      Scierror(999, _("%s: Wrong type for first input argument: Single string expected.\n"), fname);
-      
-      freeAllocatedSingleString(filename);
-      
-      return FALSE;
+      printError(&sciErr, 0);
+      return 0;
     }
-  
-  if (Rhs == 2)
+
+    if (var_type == sci_strings)
     {
-      _SciErr = getVarAddressFromPosition(pvApiCtx, 2, &option_addr); MATIO_ERROR;
-      
-      _SciErr = getVarType(pvApiCtx, option_addr, &var_type); MATIO_ERROR;
-      
-      if (var_type == sci_strings)
-	{
-	  getAllocatedSingleString(pvApiCtx, option_addr, &optionStr);
-	  _SciErr = getVarDimension(pvApiCtx, option_addr, &nbRow, &nbCol); MATIO_ERROR;
-	  
-	  if (nbCol != 1) 
-	    {
-	      Scierror(999, _("%s: Wrong size for second input argument: Single string expected.\n"), fname);
-	      
-	      freeAllocatedSingleString(filename);
-	      freeAllocatedSingleString(optionStr);
-	      
-	      return FALSE;
-	    }
-	  
-	  if (strcmp(optionStr, "r")==0)
-	    {
-	      option = MAT_ACC_RDONLY;
-	    }
-	  else if (strcmp(optionStr, "w")==0)
-	    {
-	      option = 0; // MAT_ACC_RDWR option will be used for append mode
-	    }
-	  else
-	    {
-	      Scierror(999, _("%s: Wrong value for second input argument: 'r' or 'w' expected.\n"), fname);
-	      
-	      freeAllocatedSingleString(filename);
-	      freeAllocatedSingleString(optionStr);
-	      
-	      return FALSE;
-	    }
-	}
-      else
-	{
-	  Scierror(999, _("%s: Wrong type for second input argument: Single string expected.\n"), fname);
-	  
-	  freeAllocatedSingleString(filename);
-	  freeAllocatedSingleString(optionStr);
-	  
-	  return FALSE;
-	}
+        getAllocatedSingleString(pvApiCtx, filename_addr, &filename);
+        sciErr = getVarDimension(pvApiCtx, filename_addr, &nbRow, &nbCol);
+        if(sciErr.iErr)
+        {
+            printError(&sciErr, 0);
+            return 0;
+        }
+
+        if (nbCol != 1)
+        {
+            Scierror(999, _("%s: Wrong size for first input argument: Single string expected.\n"), fname);
+            freeAllocatedSingleString(filename);
+            return FALSE;
+        }
     }
-  else
+    else
     {
-      /* Default option value */
-      option = MAT_ACC_RDONLY;
+        Scierror(999, _("%s: Wrong type for first input argument: Single string expected.\n"), fname);
+        freeAllocatedSingleString(filename);
+        return FALSE;
     }
-  
-  /* Try to open the file (as a Matlab 5 file) */
-  matfile = Mat_Open(filename, option);
-  
-  if(matfile==NULL) /* Opening failed */
+
+    if (Rhs == 2)
     {
-      /* Try to open the file (as a Matlab 4 file) */
-      matfile = Mat_Open(filename, option | MAT_FT_MAT4);
-      
-      if(matfile==NULL) /* Opening failed */
-	{
-	  /* Function returns -1 */
-	  fileIndex = -1;
-	}
+        sciErr = getVarAddressFromPosition(pvApiCtx, 2, &option_addr);
+        if(sciErr.iErr)
+        {
+            printError(&sciErr, 0);
+            return 0;
+        }
+
+        sciErr = getVarType(pvApiCtx, option_addr, &var_type);
+        if(sciErr.iErr)
+        {
+            printError(&sciErr, 0);
+            return 0;
+        }
+
+        if (var_type == sci_strings)
+        {
+            getAllocatedSingleString(pvApiCtx, option_addr, &optionStr);
+            sciErr = getVarDimension(pvApiCtx, option_addr, &nbRow, &nbCol);
+            if(sciErr.iErr)
+            {
+                printError(&sciErr, 0);
+                return 0;
+            }
+
+            if (nbCol != 1)
+            {
+                Scierror(999, _("%s: Wrong size for second input argument: Single string expected.\n"), fname);
+                freeAllocatedSingleString(filename);
+                freeAllocatedSingleString(optionStr);
+
+                return FALSE;
+            }
+
+            if (strcmp(optionStr, "r") == 0)
+            {
+                option = MAT_ACC_RDONLY;
+            }
+            else if (strcmp(optionStr, "w") == 0)
+            {
+                option = MAT_ACC_RDWR;
+            }
+            else
+            {
+                Scierror(999, _("%s: Wrong value for second input argument: 'r' or 'w' expected.\n"), fname);
+                freeAllocatedSingleString(filename);
+                freeAllocatedSingleString(optionStr);
+
+                return FALSE;
+            }
+        }
+        else
+        {
+            Scierror(999, _("%s: Wrong type for second input argument: Single string expected.\n"), fname);
+            freeAllocatedSingleString(filename);
+            freeAllocatedSingleString(optionStr);
+
+            return FALSE;
+        }
+    }
+    else
+    {
+        /* Default option value */
+        option = MAT_ACC_RDONLY;
+    }
+
+    /* Try to open the file (as a Matlab 5 file) */
+    matfile = Mat_Open(filename, option);
+
+    if (matfile == NULL) /* Opening failed */
+    {
+        /* Try to open the file (as a Matlab 4 file) */
+        matfile = Mat_Open(filename, option | MAT_FT_MAT4);
+
+        if (matfile == NULL) /* Opening failed */
+        {
+            /* Function returns -1 */
+            fileIndex = -1;
+        }
     }
-  
-  if (matfile != NULL) /* Opening succeed */
+
+    if (matfile != NULL) /* Opening succeed */
     {
-      /* Add the file to the manager */
-      matfile_manager(MATFILEMANAGER_ADDFILE, &fileIndex, &matfile);
+        /* Add the file to the manager */
+        matfile_manager(MATFILEMANAGER_ADDFILE, &fileIndex, &matfile);
     }
-  
-  /* Return the index */
-  createScalarDouble(pvApiCtx, Rhs+1, (double)fileIndex);
-  
-  freeAllocatedSingleString(filename);
-  freeAllocatedSingleString(optionStr);
-
-  LhsVar(1) = Rhs+1;
-  PutLhsVar();
-  
-  return TRUE;
+
+    /* Return the index */
+    createScalarDouble(pvApiCtx, Rhs + 1, (double)fileIndex);
+
+    freeAllocatedSingleString(filename);
+    freeAllocatedSingleString(optionStr);
+
+    LhsVar(1) = Rhs + 1;
+    PutLhsVar();
+
+    return TRUE;
 }
diff --git a/modules/matio/sci_gateway/c/sci_matfile_varreadnext.c b/modules/matio/sci_gateway/c/sci_matfile_varreadnext.c
index 072a720..b41a0b2 100644
--- a/modules/matio/sci_gateway/c/sci_matfile_varreadnext.c
+++ b/modules/matio/sci_gateway/c/sci_matfile_varreadnext.c
@@ -1,12 +1,12 @@
 /*
  * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
- * Copyright (C) 2008 - INRIA - Vincent COUVERT 
+ * Copyright (C) 2008 - INRIA - Vincent COUVERT
  * Copyright (C) 2010 - DIGITEO - Yann COLLETTE
- * 
+ *
  * This file must be used under the terms of the CeCILL.
  * This source file is licensed as described in the file COPYING, which
  * you should have received as part of this distribution.  The terms
- * are also available at    
+ * are also available at
  * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
  *
  */
@@ -19,115 +19,119 @@
 #include "Scierror.h"
 #include "sciprint.h"
 
-
-#define MATIO_ERROR if(_SciErr.iErr)	     \
-    {					     \
-      printError(&_SciErr, 0);		     \
-      return 0;				     \
-    }
-
-enum matfile_errors {
-  NO_MORE_VARIABLES = -1,
-  UNKNOWN_VARIABLE_TYPE = 0
+enum matfile_errors
+{
+    NO_MORE_VARIABLES = -1,
+    UNKNOWN_VARIABLE_TYPE = 0
 };
 
-int sci_matfile_varreadnext(char *fname,unsigned long fname_len)
+int sci_matfile_varreadnext(char *fname, unsigned long fname_len)
 {
-  mat_t *matfile = NULL;
-  matvar_t *matvar = NULL;
-  int fileIndex = 0;
-  int returnedClass = 0, var_type;
-  int * fd_addr = NULL;
-  double tmp_dbl;
-  SciErr _SciErr;
-  
-  CheckRhs(1, 1);
-  CheckLhs(1, 3);
-  
-  /* Input argument is the index of the file to read */
-  
-  _SciErr = getVarAddressFromPosition(pvApiCtx, 1, &fd_addr); MATIO_ERROR;
-  _SciErr = getVarType(pvApiCtx, fd_addr, &var_type); MATIO_ERROR;
-  
-  if (var_type == sci_matrix)
+    mat_t *matfile = NULL;
+    matvar_t *matvar = NULL;
+    int fileIndex = 0;
+    int returnedClass = 0, var_type;
+    int * fd_addr = NULL;
+    double tmp_dbl;
+    SciErr sciErr;
+
+    CheckRhs(1, 1);
+    CheckLhs(1, 3);
+
+    /* Input argument is the index of the file to read */
+
+    sciErr = getVarAddressFromPosition(pvApiCtx, 1, &fd_addr);
+    if (sciErr.iErr)
+    {
+        printError(&sciErr, 0);
+        return 0;
+    }
+    sciErr = getVarType(pvApiCtx, fd_addr, &var_type);
+    if (sciErr.iErr)
+    {
+        printError(&sciErr, 0);
+        return 0;
+    }
+
+    if (var_type == sci_matrix)
     {
-      getScalarDouble(pvApiCtx, fd_addr, &tmp_dbl);
-      if (!isScalar(pvApiCtx, fd_addr))
-	{
-	  Scierror(999, _("%s: Wrong size for first input argument: Single double expected.\n"), fname);
-	  return FALSE;
-	}
-      fileIndex = (int)tmp_dbl;
+        getScalarDouble(pvApiCtx, fd_addr, &tmp_dbl);
+        if (!isScalar(pvApiCtx, fd_addr))
+        {
+            Scierror(999, _("%s: Wrong size for first input argument: Single double expected.\n"), fname);
+            return FALSE;
+        }
+        fileIndex = (int)tmp_dbl;
     }
-  else
+    else
     {
-      Scierror(999, _("%s: Wrong type for first input argument: Double expected.\n"), fname);
-      return FALSE;
+        Scierror(999, _("%s: Wrong type for first input argument: Double expected.\n"), fname);
+        return FALSE;
     }
-  
-  /* Gets the corresponding matfile */
-  matfile_manager(MATFILEMANAGER_GETFILE, &fileIndex, &matfile);
 
-  if (matfile == NULL)
+    /* Gets the corresponding matfile */
+    matfile_manager(MATFILEMANAGER_GETFILE, &fileIndex, &matfile);
+
+    if (matfile == NULL)
     {
-      Scierror(999, _("%s: Invalid file identifier.\n"), fname);
-      return FALSE;
+        Scierror(999, _("%s: Invalid file identifier.\n"), fname);
+        return FALSE;
     }
 
-  matvar = Mat_VarReadNext(matfile);
-  if ((matvar == NULL) || (matvar->name == NULL))
+    matvar = Mat_VarReadNext(matfile);
+    if ((matvar == NULL) || (matvar->name == NULL))
     {
-      /* Return empty name */
-      createSingleString(pvApiCtx, Rhs+1, "\0");
-      LhsVar(1) = Rhs+1;
-      
-      if (Lhs >= 2)
-	{
-	  /* Return empty value */
-	  createEmptyMatrix(pvApiCtx, Rhs+2);
-	  LhsVar(2) = Rhs+2;
-	}
-      
-      if (Lhs == 3)
-	{
-	  /* Return error flag instead of variable class */
-	  createScalarDouble(pvApiCtx, Rhs+3, NO_MORE_VARIABLES);
-	  LhsVar(3) = Rhs+3;
-	}
-      
-      PutLhsVar();
-      
-      return TRUE;
+        /* Return empty name */
+        createSingleString(pvApiCtx, Rhs + 1, "\0");
+        LhsVar(1) = Rhs + 1;
+
+        if (Lhs >= 2)
+        {
+            /* Return empty value */
+            createEmptyMatrix(pvApiCtx, Rhs + 2);
+            LhsVar(2) = Rhs + 2;
+        }
+
+        if (Lhs == 3)
+        {
+            /* Return error flag instead of variable class */
+            createScalarDouble(pvApiCtx, Rhs + 3, NO_MORE_VARIABLES);
+            LhsVar(3) = Rhs + 3;
+        }
+
+        PutLhsVar();
+
+        return TRUE;
     }
-  
-  /* To be sure isComplex is 0 or 1 */
-  matvar->isComplex =  matvar->isComplex != 0;
-  
-  /* Return the variable name */
-  createSingleString(pvApiCtx, Rhs+1, matvar->name);
-  LhsVar(1) = Rhs+1;
-  
-  returnedClass = matvar->class_type;
-  
-  if (Lhs >= 2)
+
+    /* To be sure isComplex is 0 or 1 */
+    matvar->isComplex =  matvar->isComplex != 0;
+
+    /* Return the variable name */
+    createSingleString(pvApiCtx, Rhs + 1, matvar->name);
+    LhsVar(1) = Rhs + 1;
+
+    returnedClass = matvar->class_type;
+
+    if (Lhs >= 2)
     {
-      /* Return the values */
-      if (!CreateMatlabVariable(Rhs+2, matvar, NULL, -1)) /* Could not Create Variable */
-	{
-	  sciprint("Do not know how to read a variable of class %d.\n", matvar->class_type);
-	  returnedClass = UNKNOWN_VARIABLE_TYPE;
-	}
-      LhsVar(2) = Rhs+2;
+        /* Return the values */
+        if (!CreateMatlabVariable(pvApiCtx, Rhs + 2, matvar, NULL, -1)) /* Could not Create Variable */
+        {
+            sciprint("Do not know how to read a variable of class %d.\n", matvar->class_type);
+            returnedClass = UNKNOWN_VARIABLE_TYPE;
+        }
+        LhsVar(2) = Rhs + 2;
     }
-  
-  if (Lhs == 3)
+
+    if (Lhs == 3)
     {
-      /* Create class return value */
-      createScalarDouble(pvApiCtx, Rhs+3, returnedClass);
-      LhsVar(3) = Rhs+3;
+        /* Create class return value */
+        createScalarDouble(pvApiCtx, Rhs + 3, returnedClass);
+        LhsVar(3) = Rhs + 3;
     }
-  
-  Mat_VarFree(matvar);
-  PutLhsVar();
-  return TRUE;
+
+    Mat_VarFree(matvar);
+    PutLhsVar();
+    return TRUE;
 }
diff --git a/modules/matio/sci_gateway/c/sci_matfile_varwrite.c b/modules/matio/sci_gateway/c/sci_matfile_varwrite.c
index 19e4d09..5a3a262 100644
--- a/modules/matio/sci_gateway/c/sci_matfile_varwrite.c
+++ b/modules/matio/sci_gateway/c/sci_matfile_varwrite.c
@@ -1,12 +1,12 @@
 /*
  * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
- * Copyright (C) 2008 - INRIA - Vincent COUVERT 
+ * Copyright (C) 2008 - INRIA - Vincent COUVERT
  * Copyright (C) 2010 - DIGITEO - Yann COLLETTE
- * 
+ *
  * This file must be used under the terms of the CeCILL.
  * This source file is licensed as described in the file COPYING, which
  * you should have received as part of this distribution.  The terms
- * are also available at    
+ * are also available at
  * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
  *
  */
@@ -19,123 +19,154 @@
 #include "GetMatlabVariable.h"
 #include "api_scilab.h"
 
-#define MATIO_ERROR if(_SciErr.iErr)	     \
-    {					     \
-      printError(&_SciErr, 0);		     \
-      return 0;				     \
-    }
-
-enum matfile_errors {
-  NO_MORE_VARIABLES = -1,
-  UNKNOWN_VARIABLE_TYPE = 0
+enum matfile_errors
+{
+    NO_MORE_VARIABLES = -1,
+    UNKNOWN_VARIABLE_TYPE = 0
 };
 
-int sci_matfile_varwrite(char *fname,unsigned long fname_len)
+int sci_matfile_varwrite(char *fname, unsigned long fname_len)
 {
-  int nbRow = 0, nbCol = 0;
-  mat_t *matfile = NULL;
-  matvar_t *matvar = NULL;
-  int fileIndex = 0;
-  char *varname = NULL;
-  int flag = 0;
-  int compressionFlag = 0;
-  int var_type;
-  int * fd_addr = NULL, * name_addr = NULL, * cp_flag_addr = NULL;
-  double tmp_dbl;
-  SciErr _SciErr;
-  
-  CheckRhs(4, 4);
-  CheckLhs(1, 1);
-  
-  /* Input argument is the index of the file to write */
-  
-  _SciErr = getVarAddressFromPosition(pvApiCtx, 1, &fd_addr); MATIO_ERROR;
-  _SciErr = getVarType(pvApiCtx, fd_addr, &var_type); MATIO_ERROR;
-  
-  if (var_type == sci_matrix)
+    int nbRow = 0, nbCol = 0;
+    mat_t *matfile = NULL;
+    matvar_t *matvar = NULL;
+    int fileIndex = 0;
+    char *varname = NULL;
+    int flag = 0;
+    int compressionFlag = 0;
+    int var_type;
+    int * fd_addr = NULL, * name_addr = NULL, * cp_flag_addr = NULL;
+    double tmp_dbl;
+    SciErr sciErr;
+
+    CheckRhs(4, 4);
+    CheckLhs(1, 1);
+
+    /* Input argument is the index of the file to write */
+
+    sciErr = getVarAddressFromPosition(pvApiCtx, 1, &fd_addr);
+    if (sciErr.iErr)
+    {
+        printError(&sciErr, 0);
+        return 0;
+    }
+    sciErr = getVarType(pvApiCtx, fd_addr, &var_type);
+    if (sciErr.iErr)
+    {
+        printError(&sciErr, 0);
+        return 0;
+    }
+
+    if (var_type == sci_matrix)
+    {
+        getScalarDouble(pvApiCtx, fd_addr, &tmp_dbl);
+        if (!isScalar(pvApiCtx, fd_addr))
+        {
+            Scierror(999, _("%s: Wrong size for first input argument: Single double expected.\n"), fname);
+            return FALSE;
+        }
+        fileIndex = (int)tmp_dbl;
+    }
+    else
+    {
+        Scierror(999, _("%s: Wrong type for first input argument: Double expected.\n"), fname);
+        return FALSE;
+    }
+
+    /* Gets the corresponding matfile */
+    matfile_manager(MATFILEMANAGER_GETFILE, &fileIndex, &matfile);
+
+    /* Second argument is the variable name */
+
+    sciErr = getVarAddressFromPosition(pvApiCtx, 2, &name_addr);
+    if (sciErr.iErr)
+    {
+        printError(&sciErr, 0);
+        return 0;
+    }
+    sciErr = getVarType(pvApiCtx, name_addr, &var_type);
+    if (sciErr.iErr)
     {
-      getScalarDouble(pvApiCtx, fd_addr, &tmp_dbl);
-      if (!isScalar(pvApiCtx, fd_addr))
-	{
-	  Scierror(999, _("%s: Wrong size for first input argument: Single double expected.\n"), fname);
-	  return FALSE;
-	}
-      fileIndex = (int)tmp_dbl;
+        printError(&sciErr, 0);
+        return 0;
+    }
+
+    if (var_type == sci_strings)
+    {
+        getAllocatedSingleString(pvApiCtx, name_addr, &varname);
+        sciErr = getVarDimension(pvApiCtx, name_addr, &nbRow, &nbCol);
+        if (sciErr.iErr)
+        {
+            printError(&sciErr, 0);
+            return 0;
+        }
+        if (nbCol != 1)
+        {
+            Scierror(999, _("%s: Wrong size for second input argument: Single string expected.\n"), fname);
+
+            freeAllocatedSingleString(varname);
+
+            return FALSE;
+        }
     }
-  else
+    else
     {
-      Scierror(999, _("%s: Wrong type for first input argument: Double expected.\n"), fname);
-      return FALSE;
+        Scierror(999, _("%s: Wrong type for second input argument: Single string expected.\n"), fname);
+
+        freeAllocatedSingleString(varname);
+
+        return FALSE;
     }
-  
-  /* Gets the corresponding matfile */
-  matfile_manager(MATFILEMANAGER_GETFILE, &fileIndex, &matfile);
-  
-  /* Second argument is the variable name */
-  
-  _SciErr = getVarAddressFromPosition(pvApiCtx, 2, &name_addr); MATIO_ERROR;
-  _SciErr = getVarType(pvApiCtx, name_addr, &var_type); MATIO_ERROR;
-  
-  if (var_type == sci_strings)
+
+    /* Third argument is the variable data */
+    /* TODO update this NULL */
+    matvar = GetMatlabVariable(pvApiCtx, 3, varname, Mat_GetVersion(matfile), NULL, -1);
+
+    /* Fourth argument is the compression flag */
+
+    sciErr = getVarAddressFromPosition(pvApiCtx, 4, &cp_flag_addr);
+    if (sciErr.iErr)
     {
-      getAllocatedSingleString(pvApiCtx, name_addr, &varname);
-      _SciErr = getVarDimension(pvApiCtx, name_addr, &nbRow, &nbCol); MATIO_ERROR;
-      if (nbCol != 1)
-	{
-	  Scierror(999, _("%s: Wrong size for second input argument: Single string expected.\n"), fname);
-	  
-	  freeAllocatedSingleString(varname);
-	  
-	  return FALSE;
-	}
+        printError(&sciErr, 0);
+        return 0;
     }
-  else
+    sciErr = getVarType(pvApiCtx, cp_flag_addr, &var_type);
+    if (sciErr.iErr)
     {
-      Scierror(999, _("%s: Wrong type for second input argument: Single string expected.\n"), fname);
-      
-      freeAllocatedSingleString(varname);
-      
-      return FALSE;
+        printError(&sciErr, 0);
+        return 0;
     }
-  
-  /* Third argument is the variable data */
-  matvar = GetMatlabVariable(3, varname, matfile->version, NULL, -1);
-  
-  /* Fourth argument is the compression flag */
-  
-  _SciErr = getVarAddressFromPosition(pvApiCtx, 4, &cp_flag_addr); MATIO_ERROR;
-  _SciErr = getVarType(pvApiCtx, cp_flag_addr, &var_type); MATIO_ERROR;
-  
-  if (var_type == sci_boolean)
+
+    if (var_type == sci_boolean)
     {
-      getScalarBoolean(pvApiCtx, cp_flag_addr, &compressionFlag);
-      if (!isScalar(pvApiCtx, cp_flag_addr))
-	{
-	  Scierror(999, _("%s: Wrong size for fourth input argument: Single boolean expected.\n"), fname);
-	  
-	  freeAllocatedSingleString(varname);
-	  
-	  return FALSE;
-	}
+        getScalarBoolean(pvApiCtx, cp_flag_addr, &compressionFlag);
+        if (!isScalar(pvApiCtx, cp_flag_addr))
+        {
+            Scierror(999, _("%s: Wrong size for fourth input argument: Single boolean expected.\n"), fname);
+
+            freeAllocatedSingleString(varname);
+
+            return FALSE;
+        }
     }
-  else
+    else
     {
-      Scierror(999, _("%s: Wrong type for fourth input argument: Single boolean expected.\n"), fname);
-      
-      freeAllocatedSingleString(varname);
-      
-      return FALSE;
+        Scierror(999, _("%s: Wrong type for fourth input argument: Single boolean expected.\n"), fname);
+
+        freeAllocatedSingleString(varname);
+
+        return FALSE;
     }
-  
-  flag = Mat_VarWrite(matfile, matvar, compressionFlag);
-  
-  /* Return execution flag */
-  var_type = (flag==0);
-  createScalarBoolean(pvApiCtx, Rhs+1, var_type);
-  
-  freeAllocatedSingleString(varname);
-  LhsVar(1) = Rhs+1;
-  PutLhsVar();
-  
-  return TRUE;
+
+    flag = Mat_VarWrite(matfile, matvar, compressionFlag);
+
+    /* Return execution flag */
+    var_type = (flag == 0);
+    createScalarBoolean(pvApiCtx, Rhs + 1, var_type);
+
+    freeAllocatedSingleString(varname);
+    LhsVar(1) = Rhs + 1;
+    PutLhsVar();
+
+    return TRUE;
 }
diff --git a/modules/matio/src/c/CreateBooleanVariable.c b/modules/matio/src/c/CreateBooleanVariable.c
index 9496f92..6681cab 100644
--- a/modules/matio/src/c/CreateBooleanVariable.c
+++ b/modules/matio/src/c/CreateBooleanVariable.c
@@ -1,12 +1,12 @@
 /*
  * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
- * Copyright (C) 2010 - DIGITEO - Vincent COUVERT 
- * Copyright (C) 2010 - DIGITEO - Yann COLLETTE 
- * 
+ * Copyright (C) 2010 - DIGITEO - Vincent COUVERT
+ * Copyright (C) 2010 - DIGITEO - Yann COLLETTE
+ *
  * This file must be used under the terms of the CeCILL.
  * This source file is licensed as described in the file COPYING, which
  * you should have received as part of this distribution.  The terms
- * are also available at    
+ * are also available at
  * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
  *
  */
@@ -18,80 +18,107 @@
 #include "Scierror.h"
 #include "sciprint.h"
 
-#define MATIO_ERROR if(_SciErr.iErr) \
-    {				     \
-      printError(&_SciErr, 0);	     \
-      return 0;			     \
-    }
-
-int CreateBooleanVariable(int iVar, matvar_t *matVariable, int * parent, int item_position)
+int CreateBooleanVariable(void *pvApiCtx, int iVar, matvar_t *matVariable, int * parent, int item_position)
 {
-  int nbRow = 0, nbCol = 0;
-  int * intPtr = NULL;
-  double * dblPtr = NULL;
-  int K = 0;
-  SciErr _SciErr;
+    int nbRow = 0, nbCol = 0;
+    int *piDims = NULL;
+    int * intPtr = NULL;
+    double * dblPtr = NULL;
+    int K = 0;
+    SciErr sciErr;
 
-  if (matVariable->rank==2) /* 2-D array */
+    if (matVariable->rank == 2) /* 2-D array */
     {
-      nbRow = matVariable->dims[0];
-      nbCol = matVariable->dims[1];
-      
-      if (nbRow*nbCol != 0)
+        nbRow = matVariable->dims[0];
+        nbCol = matVariable->dims[1];
+
+        if (nbRow*nbCol != 0)
         {
-          if ((intPtr = (int*) MALLOC(sizeof(int) * nbRow * nbCol)) == NULL)
+            if ((intPtr = (int*) MALLOC(sizeof(int) * nbRow * nbCol)) == NULL)
+            {
+                Scierror(999, _("%s: No more memory.\n"), "CreateBooleanVariable");
+                return FALSE;
+            }
+
+            for (K = 0; K < nbRow * nbCol; K++)
+            {
+                intPtr[K] = ((unsigned char*)matVariable->data)[K];
+            }
+
+            if (parent == NULL)
             {
-              Scierror(999, _("%s: No more memory.\n"), "CreateBooleanVariable");
-              return FALSE;
+                sciErr = createMatrixOfBoolean(pvApiCtx, iVar, nbRow, nbCol, intPtr);
+                if (sciErr.iErr)
+                {
+                    printError(&sciErr, 0);
+                    return 0;
+                }
             }
-          
-          for (K = 0; K < nbRow*nbCol; K++)
+            else
             {
-              intPtr[K] = ((unsigned char*)matVariable->data)[K];
+                sciErr = createMatrixOfBooleanInList(pvApiCtx, iVar, parent, item_position, nbRow, nbCol, intPtr);
+                if (sciErr.iErr)
+                {
+                    printError(&sciErr, 0);
+                    return 0;
+                }
             }
 
-	  if (parent==NULL)
-	    {
-	      _SciErr = createMatrixOfBoolean(pvApiCtx, iVar, nbRow, nbCol, intPtr); MATIO_ERROR;
-	    }
-	  else
-	    {
-	      _SciErr = createMatrixOfBooleanInList(pvApiCtx, iVar, parent, item_position, nbRow, nbCol, intPtr); MATIO_ERROR;
-	    }
-          
-          FREE(intPtr);
+            FREE(intPtr);
         }
-      else
+        else
         {
-          if ((dblPtr = (double *)MALLOC(sizeof(double) * nbRow * nbCol)) == NULL)
+            if ((dblPtr = (double *)MALLOC(sizeof(double) * nbRow * nbCol)) == NULL)
             {
-              Scierror(999, _("%s: No more memory.\n"), "CreateBooleanVariable");
-
-              return FALSE;
+                Scierror(999, _("%s: No more memory.\n"), "CreateBooleanVariable");
+                return FALSE;
             }
-          
-          for (K = 0; K < nbRow*nbCol; K++)
+
+            for (K = 0; K < nbRow * nbCol; K++)
             {
-              dblPtr[K] = ((unsigned char*)matVariable->data)[K];
+                dblPtr[K] = ((unsigned char*)matVariable->data)[K];
             }
 
-	  if (parent==NULL)
-	    {
-	      _SciErr = createMatrixOfDouble(pvApiCtx, iVar, nbRow, nbCol, dblPtr);
-	    }
-	  else
-	    {
-	      _SciErr = createMatrixOfDoubleInList(pvApiCtx, iVar, parent, item_position, nbRow, nbCol, dblPtr);
-	    }
+            if (parent == NULL)
+            {
+                sciErr = createMatrixOfDouble(pvApiCtx, iVar, nbRow, nbCol, dblPtr);
+                if (sciErr.iErr)
+                {
+                    printError(&sciErr, 0);
+                    return 0;
+                }
+            }
+            else
+            {
+                sciErr = createMatrixOfDoubleInList(pvApiCtx, iVar, parent, item_position, nbRow, nbCol, dblPtr);
+                if (sciErr.iErr)
+                {
+                    printError(&sciErr, 0);
+                    return 0;
+                }
+            }
 
-          FREE(dblPtr);
+            FREE(dblPtr);
         }
     }
-  else /* Multi-dimension array -> Scilab HyperMatrix */
+    else /* Multi-dimension array -> Scilab HyperMatrix */
     {
-      CreateHyperMatrixVariable(iVar, MATRIX_OF_BOOLEAN_DATATYPE,  NULL, &matVariable->rank, matVariable->dims, matVariable->data, NULL, parent, item_position);
+        piDims = (int*) MALLOC(matVariable->rank * sizeof(int));
+        if (piDims == NULL)
+        {
+            Scierror(999, _("%s: No more memory.\n"), "CreateBooleanVariable");
+            return FALSE;
+        }
+        for (K = 0; K < matVariable->rank; K++)
+        {
+            piDims[K] = matVariable->dims[K];
+        }
+
+        CreateHyperMatrixVariable(pvApiCtx, iVar, MATRIX_OF_BOOLEAN_DATATYPE,  NULL, &matVariable->rank, piDims, matVariable->data, NULL, parent, item_position);
+
+        FREE(piDims);
     }
-  
-  return TRUE;
+
+    return TRUE;
 }
 
diff --git a/modules/matio/src/c/CreateCellVariable.c b/modules/matio/src/c/CreateCellVariable.c
index 322847b..9498fed 100644
--- a/modules/matio/src/c/CreateCellVariable.c
+++ b/modules/matio/src/c/CreateCellVariable.c
@@ -1,11 +1,11 @@
 /*
  * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
- * Copyright (C) 2008 - INRIA - Vincent COUVERT 
- * 
+ * Copyright (C) 2008 - INRIA - Vincent COUVERT
+ *
  * This file must be used under the terms of the CeCILL.
  * This source file is licensed as described in the file COPYING, which
  * you should have received as part of this distribution.  The terms
- * are also available at    
+ * are also available at
  * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
  *
  */
@@ -17,81 +17,110 @@
 #include "Scierror.h"
 #include "sciprint.h"
 
+int CreateCellVariable(void *pvApiCtx, int iVar, matvar_t *matVariable, int * parent, int item_position)
+{
+    static const char *fieldNames[] = {"ce", "dims", "entries"};
+    int nbFields = 3;
+    int K = 0;
+    int prodDims = 0;
+    int valueIndex = 0, type;
+    int * cell_addr = NULL;
+    int * cell_entry_addr = NULL;
+    matvar_t ** allData = NULL;
+    SciErr sciErr;
 
-#define MATIO_ERROR if(_SciErr.iErr) \
-    {				     \
-      printError(&_SciErr, 0);	     \
-      return 0;			     \
-    }
+    int *piDims = NULL;
+    int i = 0;
 
-int CreateCellVariable(int iVar, matvar_t *matVariable, int * parent, int item_position)
-{
-  static const char *fieldNames[] = {"ce", "dims","entries"};
-  int nbFields = 3;
-  int K = 0;
-  int prodDims = 0;
-  int valueIndex = 0, type;
-  int * cell_addr = NULL;
-  int * cell_entry_addr = NULL;
-  matvar_t ** allData = NULL;
-  SciErr _SciErr;
+    /* Returned mlist initialization */
+    if (parent == NULL)
+    {
+        sciErr = createMList(pvApiCtx, iVar, nbFields, &cell_addr);
+        if (sciErr.iErr)
+        {
+            printError(&sciErr, 0);
+            return 0;
+        }
+    }
+    else
+    {
+        sciErr = createMListInList(pvApiCtx, iVar, parent, item_position, nbFields, &cell_addr);
+        if (sciErr.iErr)
+        {
+            printError(&sciErr, 0);
+            return 0;
+        }
+    }
 
-  /* Returned mlist initialization */
-  if (parent==NULL)
+    /* FIRST LIST ENTRY: fieldnames */
+    sciErr = createMatrixOfStringInList(pvApiCtx, iVar, cell_addr, 1, 1, nbFields, (const char **)fieldNames);
+    if (sciErr.iErr)
     {
-      _SciErr = createMList(pvApiCtx, iVar, nbFields, &cell_addr); MATIO_ERROR;
+        printError(&sciErr, 0);
+        return 0;
     }
-  else
+
+    piDims = (int *) MALLOC(matVariable->rank * sizeof(int));
+    for (i = 0 ; i < matVariable->rank ; ++i)
     {
-      _SciErr = createMListInList(pvApiCtx, iVar, parent, item_position, nbFields, &cell_addr); MATIO_ERROR;
+        piDims[i] = matVariable->dims[i]; // Copy dims to make size_t values fit int
     }
- 
-  /* FIRST LIST ENTRY: fieldnames */
-  _SciErr = createMatrixOfStringInList(pvApiCtx, iVar, cell_addr, 1, 1, nbFields, (char **)fieldNames); MATIO_ERROR;
-  
-  /* SECOND LIST ENTRY: Dimensions (int32 type) */
-  if(matVariable->rank==2) /* Two dimensions */
+
+    /* SECOND LIST ENTRY: Dimensions (int32 type) */
+    if (matVariable->rank == 2) /* Two dimensions */
     {
-      _SciErr = createMatrixOfInteger32InList(pvApiCtx, iVar, cell_addr, 2, 1, matVariable->rank, matVariable->dims); MATIO_ERROR;
+        sciErr = createMatrixOfInteger32InList(pvApiCtx, iVar, cell_addr, 2, 1, matVariable->rank, piDims);
+        if (sciErr.iErr)
+        {
+            printError(&sciErr, 0);
+            return 0;
+        }
     }
-  else /* 3 or more dimensions -> Scilab HyperMatrix */
+    else /* 3 or more dimensions -> Scilab HyperMatrix */
     {
-      type = I_INT32;
-      CreateHyperMatrixVariable(iVar, MATRIX_OF_VARIABLE_SIZE_INTEGER_DATATYPE, 
-				&type, &matVariable->rank, matVariable->dims, matVariable->data,
-				NULL, cell_addr, 2);
+        type = I_INT32;
+        CreateHyperMatrixVariable(pvApiCtx, iVar, MATRIX_OF_VARIABLE_SIZE_INTEGER_DATATYPE,
+                                  &type, &matVariable->rank, piDims, matVariable->data,
+                                  NULL, cell_addr, 2);
     }
 
-  /* ALL OTHER ENTRIES: Fields data */
-  prodDims = 1;
-  for (K=0; K<matVariable->rank; K++)
+    FREE(piDims);
+
+    /* ALL OTHER ENTRIES: Fields data */
+    prodDims = 1;
+    for (K = 0; K < matVariable->rank; K++)
     {
-      prodDims *= matVariable->dims[K];
+        prodDims *= matVariable->dims[K];
     }
 
-  allData = (matvar_t**) (matVariable->data);
+    allData = (matvar_t**) (matVariable->data);
 
-  if (prodDims == 1) /* Scalar cell */
+    if (prodDims == 1) /* Scalar cell */
     {
-      /* Create list entry in the stack */
-      if (!CreateMatlabVariable(iVar, allData[0], cell_addr, 3)) /* Could not Create Variable */
-	{
-	  sciprint("Do not know how to read a variable of class %d.\n", allData[0]->class_type);
-	}
+        /* Create list entry in the stack */
+        if (!CreateMatlabVariable(pvApiCtx, iVar, allData[0], cell_addr, 3)) /* Could not Create Variable */
+        {
+            sciprint("Do not know how to read a variable of class %d.\n", allData[0]->class_type);
+        }
     }
-  else
+    else
     {
-      _SciErr = createListInList(pvApiCtx, iVar, cell_addr, 3, prodDims, &cell_entry_addr); MATIO_ERROR;
+        sciErr = createListInList(pvApiCtx, iVar, cell_addr, 3, prodDims, &cell_entry_addr);
+        if (sciErr.iErr)
+        {
+            printError(&sciErr, 0);
+            return 0;
+        }
 
-      for (valueIndex = 0; valueIndex < prodDims; valueIndex++)
+        for (valueIndex = 0; valueIndex < prodDims; valueIndex++)
         {
-          /* Create list entry in the stack */
-          if (!CreateMatlabVariable(iVar, allData[valueIndex], cell_entry_addr, valueIndex+1)) /* Could not Create Variable */
+            /* Create list entry in the stack */
+            if (!CreateMatlabVariable(pvApiCtx, iVar, allData[valueIndex], cell_entry_addr, valueIndex + 1)) /* Could not Create Variable */
             {
-              sciprint("Do not know how to read a variable of class %d.\n", allData[valueIndex]->class_type);
+                sciprint("Do not know how to read a variable of class %d.\n", allData[valueIndex]->class_type);
             }
         }
     }
-  
-  return TRUE;
+
+    return TRUE;
 }
diff --git a/modules/matio/src/c/CreateCharVariable.c b/modules/matio/src/c/CreateCharVariable.c
index c51e76c..1cbda14 100644
--- a/modules/matio/src/c/CreateCharVariable.c
+++ b/modules/matio/src/c/CreateCharVariable.c
@@ -22,94 +22,96 @@
 #include "localization.h"
 #include "Scierror.h"
 
-#define MATIO_ERROR if(_SciErr.iErr)	     \
-    {					     \
-      printError(&_SciErr, 0);		     \
-      return 0;				     \
-    }
-
-int CreateCharVariable(int iVar, matvar_t *matVariable, int * parent, int item_position)
+int CreateCharVariable(void *pvApiCtx, int iVar, matvar_t *matVariable, int * parent, int item_position)
 {
-  int nbRow = 0, nbCol = 0;
-  char **charData = NULL;
-  int K = 0, L = 0;
-  SciErr _SciErr;
+    int nbRow = 0, nbCol = 0;
+    char **charData = NULL;
+    int K = 0, L = 0;
+    SciErr sciErr;
 
-  if(matVariable->rank==2) /* 2-D array */
+    if (matVariable->rank == 2) /* 2-D array */
     {
-      nbRow = matVariable->dims[0];
-      nbCol = nbRow==0 ? 0 : 1; /* In Scilab empty string has size 0x0 */
+        nbRow = matVariable->dims[0];
+        nbCol = nbRow == 0 ? 0 : 1; /* In Scilab empty string has size 0x0 */
 
-      if (nbRow != 0)
-	{
-	  charData =  (char**) MALLOC(sizeof(char*) * nbRow);
-	  if (charData==NULL)
-	    {
-	      Scierror(999, _("%s: No more memory.\n"), "CreateCharVariable");
-	      return FALSE;
-	    }
-	}
+        if (nbRow != 0)
+        {
+            charData =  (char**) MALLOC(sizeof(char*) * nbRow);
+            if (charData == NULL)
+            {
+                Scierror(999, _("%s: No more memory.\n"), "CreateCharVariable");
+                return FALSE;
+            }
+        }
 
-      for (K=0; K<nbRow; K++)
-	{
-	  charData[K] =  (char*) MALLOC(sizeof(char*) * (matVariable->dims[1] + 1));
-	  if (charData[K]==NULL)
-	    {
-	      Scierror(999, _("%s: No more memory.\n"), "CreateCharVariable");
-	      return FALSE;
-	    }
-	}
+        for (K = 0; K < nbRow; K++)
+        {
+            charData[K] =  (char*) MALLOC(sizeof(char*) * (matVariable->dims[1] + 1));
+            if (charData[K] == NULL)
+            {
+                Scierror(999, _("%s: No more memory.\n"), "CreateCharVariable");
+                return FALSE;
+            }
+        }
 
-      /* Fill items: data in Matlab file is stored columnwise */
-      for(K=0; K<matVariable->dims[0]; K++) /* Loop over items */
-	{
-	  for(L=0; L<matVariable->dims[1]; L++) /* Loop over chars */
-	    {
-	      if (matVariable->fp->version != MAT_FT_MAT4) /* MAT_FT_MAT4 format ==> data is a char* pointer */
-		{
-		  charData[K][L] = ((char *)matVariable->data)[L*matVariable->dims[0]+K];
-		}
-	      else /* MAT_FT_MAT4 format ==> data is a double* pointer */
-		{
-		  charData[K][L] = (char) ((double *)matVariable->data)[L*matVariable->dims[0]+K];
-		}
-	    }
-	  charData[K][L] = '\0';
-	}
+        /* Fill items: data in Matlab file is stored columnwise */
+        for (K = 0; K < (int)matVariable->dims[0]; K++) /* Loop over items */
+        {
+            for (L = 0; L < (int)matVariable->dims[1]; L++) /* Loop over chars */
+            {
+                charData[K][L] = ((char *)matVariable->data)[L * matVariable->dims[0] + K];
+            }
+            charData[K][L] = '\0';
+        }
 
-      if (nbRow*nbCol != 0)
-	{
-	  if (parent==NULL)
-	    {
-	      _SciErr = createMatrixOfString(pvApiCtx, iVar, nbRow, nbCol, charData); MATIO_ERROR;
-	    }
-	  else
-	    {
-	      _SciErr = createMatrixOfStringInList(pvApiCtx, iVar, parent, item_position, nbRow, nbCol, charData); MATIO_ERROR;
-	    }
-	}
-      else /* Empty character string */
-	{
-	  if (parent==NULL)
-	    {
-	      createSingleString(pvApiCtx, iVar, "\0");
-	    }
-	  else
-	    {
-	      char ** tmp_char = (char **)MALLOC(sizeof(char *));
-	      tmp_char[0] = strdup("\0");
-	      _SciErr = createMatrixOfStringInList(pvApiCtx, iVar, parent, item_position, 1, 1, tmp_char); MATIO_ERROR;
-	      freeArrayOfString(tmp_char, 1);
-	    }
-	}
+        if (nbRow*nbCol != 0)
+        {
+            if (parent == NULL)
+            {
+                sciErr = createMatrixOfString(pvApiCtx, iVar, nbRow, nbCol, charData);
+                if (sciErr.iErr)
+                {
+                    printError(&sciErr, 0);
+                    return 0;
+                }
+            }
+            else
+            {
+                sciErr = createMatrixOfStringInList(pvApiCtx, iVar, parent, item_position, nbRow, nbCol, charData);
+                if (sciErr.iErr)
+                {
+                    printError(&sciErr, 0);
+                    return 0;
+                }
+            }
+        }
+        else /* Empty character string */
+        {
+            if (parent == NULL)
+            {
+                createSingleString(pvApiCtx, iVar, "\0");
+            }
+            else
+            {
+                char ** tmp_char = (char **)MALLOC(sizeof(char *));
+                tmp_char[0] = strdup("\0");
+                sciErr = createMatrixOfStringInList(pvApiCtx, iVar, parent, item_position, 1, 1, tmp_char);
+                if (sciErr.iErr)
+                {
+                    printError(&sciErr, 0);
+                    return 0;
+                }
+                freeArrayOfString(tmp_char, 1);
+            }
+        }
 
-      freeArrayOfString(charData,nbRow*nbCol);
+        freeArrayOfString(charData, nbRow * nbCol);
     }
-  else /* Multi-dimension array -> Scilab HyperMatrix */
+    else /* Multi-dimension array -> Scilab HyperMatrix */
     {
-      Scierror(999, _("%s: N-D arrays of chars not implemented.\n"), "CreateCharVariable");
-      return FALSE;
+        Scierror(999, _("%s: N-D arrays of chars not implemented.\n"), "CreateCharVariable");
+        return FALSE;
     }
 
-  return TRUE;
+    return TRUE;
 }
diff --git a/modules/matio/src/c/CreateDoubleVariable.c b/modules/matio/src/c/CreateDoubleVariable.c
index 37a0edf..18f715e 100644
--- a/modules/matio/src/c/CreateDoubleVariable.c
+++ b/modules/matio/src/c/CreateDoubleVariable.c
@@ -1,74 +1,89 @@
 /*
  * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
- * Copyright (C) 2008 - INRIA - Vincent COUVERT 
+ * Copyright (C) 2008 - INRIA - Vincent COUVERT
  * Copyright (C) 2010 - DIGITEO - Yann COLLETTE
- * 
+ *
  * This file must be used under the terms of the CeCILL.
  * This source file is licensed as described in the file COPYING, which
  * you should have received as part of this distribution.  The terms
- * are also available at    
+ * are also available at
  * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
  *
  */
 
 #include "CreateMatlabVariable.h"
 #include "api_scilab.h"
+#include "MALLOC.h"
 
-#define MATIO_ERROR if(_SciErr.iErr) \
-    {				     \
-      printError(&_SciErr, 0);	     \
-      return 0;			     \
-    }
-
-int CreateDoubleVariable(int iVar, matvar_t *matVariable, int * parent, int item_position)
+int CreateDoubleVariable(void *pvApiCtx, int iVar, matvar_t *matVariable, int * parent, int item_position)
 {
-  int nbRow = 0, nbCol = 0;
-  struct ComplexSplit *mat5ComplexData = NULL;
-  SciErr _SciErr;
+    int nbRow = 0, nbCol = 0;
+    mat_complex_split_t *mat5ComplexData = NULL;
+    SciErr sciErr;
+    int *piDims = NULL;
+    int i = 0;
 
-  if(matVariable->rank==2) /* 2-D array */
+    if (matVariable->rank == 2) /* 2-D array */
     {
-      nbRow = matVariable->dims[0];
-      nbCol = matVariable->dims[1];
-      if (matVariable->isComplex == 0)
+        nbRow = matVariable->dims[0];
+        nbCol = matVariable->dims[1];
+        if (matVariable->isComplex == 0)
         {
-	  if (parent==NULL)
-	    {
-	      _SciErr = createMatrixOfDouble(pvApiCtx, iVar, nbRow, nbCol, matVariable->data); MATIO_ERROR;
-	    }
-	  else
-	    {
-	      _SciErr = createMatrixOfDoubleInList(pvApiCtx, iVar, parent, item_position, nbRow, nbCol, matVariable->data); MATIO_ERROR;
-	    }
+            if (parent == NULL)
+            {
+                sciErr = createMatrixOfDouble(pvApiCtx, iVar, nbRow, nbCol, matVariable->data);
+                if (sciErr.iErr)
+                {
+                    printError(&sciErr, 0);
+                    return 0;
+                }
+            }
+            else
+            {
+                sciErr = createMatrixOfDoubleInList(pvApiCtx, iVar, parent, item_position, nbRow, nbCol, matVariable->data);
+                if (sciErr.iErr)
+                {
+                    printError(&sciErr, 0);
+                    return 0;
+                }
+            }
         }
-      else
+        else
         {
-          /* Since MATIO 1.3.2 data is a ComplexSplit for MAT4 and MAT5 formats */
-          mat5ComplexData = matVariable->data;
-	  if (parent==NULL)
-	    {
-	      _SciErr = createComplexMatrixOfDouble(pvApiCtx, iVar, nbRow, nbCol, mat5ComplexData->Re, mat5ComplexData->Im);
-	    }
-	  else
-	    {
-	      _SciErr = createComplexMatrixOfDoubleInList(pvApiCtx, iVar, parent, item_position, nbRow, nbCol, 
-							  mat5ComplexData->Re, mat5ComplexData->Im);
-	    }
+            /* Since MATIO 1.3.2 data is a ComplexSplit for MAT4 and MAT5 formats */
+            mat5ComplexData = matVariable->data;
+            if (parent == NULL)
+            {
+                sciErr = createComplexMatrixOfDouble(pvApiCtx, iVar, nbRow, nbCol, mat5ComplexData->Re, mat5ComplexData->Im);
+            }
+            else
+            {
+                sciErr = createComplexMatrixOfDoubleInList(pvApiCtx, iVar, parent, item_position, nbRow, nbCol,
+                         mat5ComplexData->Re, mat5ComplexData->Im);
+            }
         }
     }
-  else /* Multi-dimension array -> Scilab HyperMatrix */
+    else /* Multi-dimension array -> Scilab HyperMatrix */
     {
-      if (matVariable->isComplex == 0)
+        piDims = (int *) MALLOC(matVariable->rank * sizeof(int));
+        for (i = 0 ; i < matVariable->rank ; ++i)
         {
-          CreateHyperMatrixVariable(iVar, MATRIX_OF_DOUBLE_DATATYPE, &matVariable->isComplex, &matVariable->rank, 
-				    matVariable->dims, matVariable->data, NULL, parent, item_position);
+            piDims[i] = matVariable->dims[i];
         }
-      else
+
+        if (matVariable->isComplex == 0)
         {
-          mat5ComplexData = matVariable->data;
-          CreateHyperMatrixVariable(iVar, MATRIX_OF_DOUBLE_DATATYPE, &matVariable->isComplex, &matVariable->rank, 
-				    matVariable->dims, mat5ComplexData->Re, mat5ComplexData->Im, parent, item_position);
+            CreateHyperMatrixVariable(pvApiCtx, iVar, MATRIX_OF_DOUBLE_DATATYPE, &matVariable->isComplex, &matVariable->rank,
+                                      piDims, matVariable->data, NULL, parent, item_position);
         }
+        else
+        {
+            mat5ComplexData = matVariable->data;
+            CreateHyperMatrixVariable(pvApiCtx, iVar, MATRIX_OF_DOUBLE_DATATYPE, &matVariable->isComplex, &matVariable->rank,
+                                      piDims, mat5ComplexData->Re, mat5ComplexData->Im, parent, item_position);
+        }
+
+        FREE(piDims);
     }
-  return TRUE;
+    return TRUE;
 }
diff --git a/modules/matio/src/c/CreateHyperMatrixVariable.c b/modules/matio/src/c/CreateHyperMatrixVariable.c
index 25631e4..76fde31 100644
--- a/modules/matio/src/c/CreateHyperMatrixVariable.c
+++ b/modules/matio/src/c/CreateHyperMatrixVariable.c
@@ -1,12 +1,12 @@
 /*
  * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
- * Copyright (C) 2008 - INRIA - Vincent COUVERT 
+ * Copyright (C) 2008 - INRIA - Vincent COUVERT
  * Copyright (C) 2010 - DIGITEO - Yann COLLETTE
- * 
+ *
  * This file must be used under the terms of the CeCILL.
  * This source file is licensed as described in the file COPYING, which
  * you should have received as part of this distribution.  The terms
- * are also available at    
+ * are also available at
  * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
  *
  */
@@ -19,14 +19,14 @@
 #include "sciprint.h"
 
 
-int CreateHyperMatrixVariable(int iVar, const char *type, int *iscomplex, int * rank, int *dims, double *realdata, double *complexdata, int * parent, int item_position)
+int CreateHyperMatrixVariable(void *pvApiCtx, int iVar, const char *type, int *iscomplex, int * rank, int *dims, double *realdata, double *complexdata, int * parent, int item_position)
 {
-    static const char *tlistFields[] = {"hm", "dims","entries"};
+    static const char *tlistFields[] = {"hm", "dims", "entries"};
     int nbRow = 0, nbCol = 0;
     int K = 0, i;
     int * hm_addr = NULL;
     SciErr sciErr;
-    
+
     /* Used for integer hypermatrices */
     char * tmp_int8 = NULL;
     short * tmp_int16 = NULL;
@@ -38,11 +38,11 @@ int CreateHyperMatrixVariable(int iVar, const char *type, int *iscomplex, int *
     long long * tmp_int64 = NULL;
     unsigned long long * tmp_uint64 = NULL;
 #endif
-    
-    if (parent==NULL)
+
+    if (parent == NULL)
     {
         sciErr = createMList(pvApiCtx, iVar, 3, &hm_addr);
-        if(sciErr.iErr)
+        if (sciErr.iErr)
         {
             printError(&sciErr, 0);
             return FALSE;
@@ -51,56 +51,56 @@ int CreateHyperMatrixVariable(int iVar, const char *type, int *iscomplex, int *
     else
     {
         sciErr = createMListInList(pvApiCtx, iVar, parent, item_position, 3, &hm_addr);
-        if(sciErr.iErr)
+        if (sciErr.iErr)
         {
             printError(&sciErr, 0);
             return FALSE;
         }
     }
-    
+
     /* mlist fields */
     nbRow = 1;
     nbCol = 3;
     sciErr = createMatrixOfStringInList(pvApiCtx, iVar, hm_addr, 1, nbRow, nbCol, (const char **)tlistFields);
-    if(sciErr.iErr)
+    if (sciErr.iErr)
     {
         printError(&sciErr, 0);
         return FALSE;
     }
-    
+
     /* hm dimensions */
     sciErr = createMatrixOfInteger32InList(pvApiCtx, iVar, hm_addr, 2, 1, *rank, dims);
-    if(sciErr.iErr)
+    if (sciErr.iErr)
     {
         printError(&sciErr, 0);
         return FALSE;
     }
-    
+
     /* hm entries */
     nbRow = 1;
     nbCol = 1;
-    for (K=0; K<*rank; K++)
+    for (K = 0; K < *rank; K++)
     {
         nbRow *= dims[K];
     }
-    
-    if (strcmp(type,MATRIX_OF_VARIABLE_SIZE_INTEGER_DATATYPE) == 0)
+
+    if (strcmp(type, MATRIX_OF_VARIABLE_SIZE_INTEGER_DATATYPE) == 0)
     {
-        switch(*iscomplex)
+        switch (*iscomplex)
         {
             case I_CHAR:
-                tmp_int8 = (char *)MALLOC(nbRow*nbCol*sizeof(char));
+                tmp_int8 = (char *)MALLOC(nbRow * nbCol * sizeof(char));
                 if (tmp_int8 == NULL)
                 {
                     Scierror(999, _("%s: No more memory.\n"), "CreateHyperMatrixVariable");
                     return FALSE;
                 }
-                for(i=0; i<nbRow*nbCol; i++)
+                for (i = 0; i < nbRow * nbCol; i++)
                 {
                     tmp_int8[i] = ((char *)realdata)[i];
                 }
                 sciErr = createMatrixOfInteger8InList(pvApiCtx, iVar, hm_addr, 3, nbRow, nbCol, tmp_int8);
-                if(sciErr.iErr)
+                if (sciErr.iErr)
                 {
                     printError(&sciErr, 0);
                     FREE(tmp_int8);
@@ -109,39 +109,39 @@ int CreateHyperMatrixVariable(int iVar, const char *type, int *iscomplex, int *
                 FREE(tmp_int8);
                 break;
             case I_INT16:
-                tmp_int16 = (short *)MALLOC(nbRow*nbCol*sizeof(short));
+                tmp_int16 = (short *)MALLOC(nbRow * nbCol * sizeof(short));
                 if (tmp_int16 == NULL)
                 {
                     Scierror(999, _("%s: No more memory.\n"), "CreateHyperMatrixVariable");
                     return FALSE;
                 }
-                for(i=0; i<nbRow*nbCol; i++)
+                for (i = 0; i < nbRow * nbCol; i++)
                 {
                     tmp_int16[i] = ((short *)realdata)[i];
                 }
                 sciErr = createMatrixOfInteger16InList(pvApiCtx, iVar, hm_addr, 3, nbRow, nbCol, tmp_int16);
-                if(sciErr.iErr)
+                if (sciErr.iErr)
                 {
                     printError(&sciErr, 0);
                     FREE(tmp_int16);
                     return FALSE;
                 }
-                
+
                 FREE(tmp_int16);
                 break;
             case I_INT32:
-                tmp_int32 = (int *)MALLOC(nbRow*nbCol*sizeof(int));
+                tmp_int32 = (int *)MALLOC(nbRow * nbCol * sizeof(int));
                 if (tmp_int32 == NULL)
                 {
                     Scierror(999, _("%s: No more memory.\n"), "CreateHyperMatrixVariable");
                     return FALSE;
                 }
-                for(i=0; i<nbRow*nbCol; i++)
+                for (i = 0; i < nbRow * nbCol; i++)
                 {
                     tmp_int32[i] = ((int *)realdata)[i];
                 }
                 sciErr = createMatrixOfInteger32InList(pvApiCtx, iVar, hm_addr, 3, nbRow, nbCol, tmp_int32);
-                if(sciErr.iErr)
+                if (sciErr.iErr)
                 {
                     printError(&sciErr, 0);
                     FREE(tmp_int32);
@@ -151,18 +151,18 @@ int CreateHyperMatrixVariable(int iVar, const char *type, int *iscomplex, int *
                 break;
 #ifdef __SCILAB_INT64__
             case I_INT64:
-                tmp_int64 = (long long *)MALLOC(nbRow*nbCol*sizeof(long long));
+                tmp_int64 = (long long *)MALLOC(nbRow * nbCol * sizeof(long long));
                 if (tmp_int64 == NULL)
                 {
                     Scierror(999, _("%s: No more memory.\n"), "CreateHyperMatrixVariable");
                     return FALSE;
                 }
-                for(i=0; i<nbRow*nbCol; i++)
-                {    
+                for (i = 0; i < nbRow * nbCol; i++)
+                {
                     tmp_int64[i] = ((long long *)realdata)[i];
                 }
                 qciErr = createMatrixOfInteger64InList(pvApiCtx, iVar, hm_addr, 3, nbRow, nbCol, tmp_int64);
-                if(sciErr.iErr)
+                if (sciErr.iErr)
                 {
                     printError(&sciErr, 0);
                     FREE(tmp_int64);
@@ -172,18 +172,18 @@ int CreateHyperMatrixVariable(int iVar, const char *type, int *iscomplex, int *
                 break;
 #endif
             case I_UCHAR:
-                tmp_uint8 = (unsigned char *)MALLOC(nbRow*nbCol*sizeof(unsigned char));
+                tmp_uint8 = (unsigned char *)MALLOC(nbRow * nbCol * sizeof(unsigned char));
                 if (tmp_uint8 == NULL)
                 {
                     Scierror(999, _("%s: No more memory.\n"), "CreateHyperMatrixVariable");
                     return FALSE;
                 }
-                for(i=0; i<nbRow*nbCol; i++)
+                for (i = 0; i < nbRow * nbCol; i++)
                 {
                     tmp_uint8[i] = ((unsigned char *)realdata)[i];
                 }
                 sciErr = createMatrixOfUnsignedInteger8InList(pvApiCtx, iVar, hm_addr, 3, nbRow, nbCol, tmp_uint8);
-                if(sciErr.iErr)
+                if (sciErr.iErr)
                 {
                     printError(&sciErr, 0);
                     FREE(tmp_uint8);
@@ -192,18 +192,18 @@ int CreateHyperMatrixVariable(int iVar, const char *type, int *iscomplex, int *
                 FREE(tmp_uint8);
                 break;
             case I_UINT16:
-                tmp_uint16 = (unsigned short *)MALLOC(nbRow*nbCol*sizeof(unsigned short));
+                tmp_uint16 = (unsigned short *)MALLOC(nbRow * nbCol * sizeof(unsigned short));
                 if (tmp_uint16 == NULL)
                 {
                     Scierror(999, _("%s: No more memory.\n"), "CreateHyperMatrixVariable");
                     return FALSE;
                 }
-                for(i=0; i<nbRow*nbCol; i++)
+                for (i = 0; i < nbRow * nbCol; i++)
                 {
                     tmp_uint16[i] = ((unsigned short *)realdata)[i];
                 }
                 sciErr = createMatrixOfUnsignedInteger16InList(pvApiCtx, iVar, hm_addr, 3, nbRow, nbCol, tmp_uint16);
-                if(sciErr.iErr)
+                if (sciErr.iErr)
                 {
                     printError(&sciErr, 0);
                     FREE(tmp_uint16);
@@ -212,18 +212,18 @@ int CreateHyperMatrixVariable(int iVar, const char *type, int *iscomplex, int *
                 FREE(tmp_uint16);
                 break;
             case I_UINT32:
-                tmp_uint32 = (unsigned int *)MALLOC(nbRow*nbCol*sizeof(unsigned int));
+                tmp_uint32 = (unsigned int *)MALLOC(nbRow * nbCol * sizeof(unsigned int));
                 if (tmp_uint32 == NULL)
                 {
                     Scierror(999, _("%s: No more memory.\n"), "CreateHyperMatrixVariable");
                     return FALSE;
                 }
-                for(i=0;i<nbRow*nbCol; i++)
+                for (i = 0; i < nbRow * nbCol; i++)
                 {
                     tmp_uint32[i] = ((unsigned int *)realdata)[i];
                 }
                 sciErr = createMatrixOfUnsignedInteger32InList(pvApiCtx, iVar, hm_addr, 3, nbRow, nbCol, tmp_uint32);
-                if(sciErr.iErr)
+                if (sciErr.iErr)
                 {
                     printError(&sciErr, 0);
                     FREE(tmp_uint32);
@@ -233,18 +233,18 @@ int CreateHyperMatrixVariable(int iVar, const char *type, int *iscomplex, int *
                 break;
 #ifdef __SCILAB_INT64__
             case I_UINT64:
-                tmp_uint64 = (unsigned long long *)MALLOC(nbRow*nbCol*sizeof(unsigned long long));
+                tmp_uint64 = (unsigned long long *)MALLOC(nbRow * nbCol * sizeof(unsigned long long));
                 if (tmp_uint64 == NULL)
                 {
                     Scierror(999, _("%s: No more memory.\n"), "CreateHyperMatrixVariable");
                     return FALSE;
                 }
-                for(i=0; i<nbRow*nbCol; i++)
+                for (i = 0; i < nbRow * nbCol; i++)
                 {
                     tmp_uint64[i] = ((unsigned long long *)realdata)[i];
                 }
                 sciErr = createMatrixOfUnsignedInteger64InList(pvApiCtx, iVar, hm_addr, 3, nbRow, nbCol, tmp_uint64);
-                if(sciErr.iErr)
+                if (sciErr.iErr)
                 {
                     printError(&sciErr, 0);
                     FREE(tmp_uint64);
@@ -258,7 +258,7 @@ int CreateHyperMatrixVariable(int iVar, const char *type, int *iscomplex, int *
     else if (strcmp(type, MATRIX_OF_BOOLEAN_DATATYPE) == 0)
     {
         sciErr = createMatrixOfDoubleInList(pvApiCtx, iVar, hm_addr, 3, nbRow, nbCol, realdata);
-        if(sciErr.iErr)
+        if (sciErr.iErr)
         {
             printError(&sciErr, 0);
             return FALSE;
@@ -269,7 +269,7 @@ int CreateHyperMatrixVariable(int iVar, const char *type, int *iscomplex, int *
         if (*iscomplex == 0)
         {
             sciErr = createMatrixOfDoubleInList(pvApiCtx, iVar, hm_addr, 3, nbRow, nbCol, realdata);
-            if(sciErr.iErr)
+            if (sciErr.iErr)
             {
                 printError(&sciErr, 0);
                 return FALSE;
@@ -278,13 +278,13 @@ int CreateHyperMatrixVariable(int iVar, const char *type, int *iscomplex, int *
         else
         {
             sciErr = createComplexMatrixOfDoubleInList(pvApiCtx, iVar, hm_addr, 3, nbRow, nbCol, realdata, complexdata);
-            if(sciErr.iErr)
+            if (sciErr.iErr)
             {
                 printError(&sciErr, 0);
                 return FALSE;
             }
         }
     }
-    
+
     return TRUE;
 }
diff --git a/modules/matio/src/c/CreateIntegerVariable.c b/modules/matio/src/c/CreateIntegerVariable.c
index 23bbadd..71fd72b 100644
--- a/modules/matio/src/c/CreateIntegerVariable.c
+++ b/modules/matio/src/c/CreateIntegerVariable.c
@@ -1,12 +1,12 @@
 /*
  * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
- * Copyright (C) 2008 - INRIA - Vincent COUVERT 
- * Copyright (C) 2010 - INRIA - Vincent COUVERT 
- * 
+ * Copyright (C) 2008 - INRIA - Vincent COUVERT
+ * Copyright (C) 2010 - INRIA - Vincent COUVERT
+ *
  * This file must be used under the terms of the CeCILL.
  * This source file is licensed as described in the file COPYING, which
  * you should have received as part of this distribution.  The terms
- * are also available at    
+ * are also available at
  * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
  *
  */
@@ -18,207 +18,286 @@
 #include "Scierror.h"
 #include "sciprint.h"
 
-
-#define MATIO_ERROR if(_SciErr.iErr) \
-    {				     \
-      printError(&_SciErr, 0);	     \
-      return 0;			     \
-    }
-
-int CreateIntegerVariable(int iVar, int integerType, matvar_t *matVariable, int * parent, int item_position)
+int CreateIntegerVariable(void *pvApiCtx, int iVar, int integerType, matvar_t *matVariable, int * parent, int item_position)
 {
-  int nbRow, nbCol, i;
-  SciErr _SciErr;
-  char * tmp_int8 = NULL;
-  short * tmp_int16 = NULL;
-  int * tmp_int32 = NULL;
-  unsigned char * tmp_uint8 = NULL;
-  unsigned short * tmp_uint16 = NULL;
-  unsigned int * tmp_uint32 = NULL;
+    int nbRow, nbCol, i;
+    SciErr sciErr;
+    char * tmp_int8 = NULL;
+    short * tmp_int16 = NULL;
+    int * tmp_int32 = NULL;
+    int *piDims = NULL;
+    unsigned char * tmp_uint8 = NULL;
+    unsigned short * tmp_uint16 = NULL;
+    unsigned int * tmp_uint32 = NULL;
 #ifdef __SCILAB_INT64__
-  long long * tmp_int64 = NULL;
-  unsigned long long * tmp_uint64 = NULL;
+    long long * tmp_int64 = NULL;
+    unsigned long long * tmp_uint64 = NULL;
 #endif
 
-  // Matrix dimensions
-  nbRow = matVariable->dims[0];
-  nbCol = matVariable->dims[1];
+    // Matrix dimensions
+    nbRow = matVariable->dims[0];
+    nbCol = matVariable->dims[1];
 
-  if (matVariable->rank==2) /* 2-D array */
+    if (matVariable->rank == 2) /* 2-D array */
     {
-      switch(integerType)
-	{
-	case I_CHAR:
-	  tmp_int8 = (char *)MALLOC(nbRow*nbCol*sizeof(char));
-	  if (tmp_int8 == NULL)
-            {
-              Scierror(999, _("%s: No more memory.\n"), "CreateIntegerVariable");
-              return FALSE;
-            }
-	  for(i=0;i<nbRow*nbCol; i++) tmp_int8[i] = ((char *)matVariable->data)[i];
-
-	  if (parent==NULL)
-	    {
-	      _SciErr = createMatrixOfInteger8(pvApiCtx, iVar, nbRow, nbCol, tmp_int8); MATIO_ERROR;
-	    }
-	  else
-	    {
-	      _SciErr = createMatrixOfInteger8InList(pvApiCtx, iVar, parent, item_position, nbRow, nbCol, tmp_int8); MATIO_ERROR;
-	    }
-
-	  FREE(tmp_int8);
-	  break;
-	case I_INT16:
-	  tmp_int16 = (short *)MALLOC(nbRow*nbCol*sizeof(short));
-	  if (tmp_int16 == NULL)
-            {
-              Scierror(999, _("%s: No more memory.\n"), "CreateIntegerVariable");
-              return FALSE;
-            }
-	  for(i=0;i<nbRow*nbCol; i++) tmp_int16[i] = ((short *)matVariable->data)[i];
-
-	  if (parent==NULL)
-	    {
-	      _SciErr = createMatrixOfInteger16(pvApiCtx, iVar, nbRow, nbCol, tmp_int16); MATIO_ERROR;
-	    }
-	  else
-	    {
-	      _SciErr = createMatrixOfInteger16InList(pvApiCtx, iVar, parent, item_position, nbRow, nbCol, tmp_int16); MATIO_ERROR;
-	    }
-
-	  FREE(tmp_int16);
-	  break;
-	case I_INT32:
-	  tmp_int32 = (int *)MALLOC(nbRow*nbCol*sizeof(int));
-	  if (tmp_int32 == NULL)
-            {
-              Scierror(999, _("%s: No more memory.\n"), "CreateIntegerVariable");
-              return FALSE;
-            }
-	  for(i=0;i<nbRow*nbCol; i++) tmp_int32[i] = ((int *)matVariable->data)[i];
-
-	  if (parent==NULL)
-	    {
-	      _SciErr = createMatrixOfInteger32(pvApiCtx, iVar, nbRow, nbCol, tmp_int32); MATIO_ERROR;
-	    }
-	  else
-	    {
-	      _SciErr = createMatrixOfInteger32InList(pvApiCtx, iVar, parent, item_position, nbRow, nbCol, tmp_int32); MATIO_ERROR;
-	    }
-
-	  FREE(tmp_int32);
-	  break;
+        switch (integerType)
+        {
+            case I_CHAR:
+                tmp_int8 = (char *)MALLOC(nbRow * nbCol * sizeof(char));
+                if (tmp_int8 == NULL)
+                {
+                    Scierror(999, _("%s: No more memory.\n"), "CreateIntegerVariable");
+                    return FALSE;
+                }
+                for (i = 0; i < nbRow * nbCol; i++)
+                {
+                    tmp_int8[i] = ((char *)matVariable->data)[i];
+                }
+
+                if (parent == NULL)
+                {
+                    sciErr = createMatrixOfInteger8(pvApiCtx, iVar, nbRow, nbCol, tmp_int8);
+                }
+                else
+                {
+                    sciErr = createMatrixOfInteger8InList(pvApiCtx, iVar, parent, item_position, nbRow, nbCol, tmp_int8);
+                }
+
+                if (sciErr.iErr)
+                {
+                    printError(&sciErr, 0);
+                    return 0;
+                }
+
+                FREE(tmp_int8);
+                break;
+            case I_INT16:
+                tmp_int16 = (short *)MALLOC(nbRow * nbCol * sizeof(short));
+                if (tmp_int16 == NULL)
+                {
+                    Scierror(999, _("%s: No more memory.\n"), "CreateIntegerVariable");
+                    return FALSE;
+                }
+                for (i = 0; i < nbRow * nbCol; i++)
+                {
+                    tmp_int16[i] = ((short *)matVariable->data)[i];
+                }
+
+                if (parent == NULL)
+                {
+                    sciErr = createMatrixOfInteger16(pvApiCtx, iVar, nbRow, nbCol, tmp_int16);
+                }
+                else
+                {
+                    sciErr = createMatrixOfInteger16InList(pvApiCtx, iVar, parent, item_position, nbRow, nbCol, tmp_int16);
+                }
+
+                if (sciErr.iErr)
+                {
+                    printError(&sciErr, 0);
+                    return 0;
+                }
+
+                FREE(tmp_int16);
+                break;
+            case I_INT32:
+                tmp_int32 = (int *)MALLOC(nbRow * nbCol * sizeof(int));
+                if (tmp_int32 == NULL)
+                {
+                    Scierror(999, _("%s: No more memory.\n"), "CreateIntegerVariable");
+                    return FALSE;
+                }
+                for (i = 0; i < nbRow * nbCol; i++)
+                {
+                    tmp_int32[i] = ((int *)matVariable->data)[i];
+                }
+
+                if (parent == NULL)
+                {
+                    sciErr = createMatrixOfInteger32(pvApiCtx, iVar, nbRow, nbCol, tmp_int32);
+                }
+                else
+                {
+                    sciErr = createMatrixOfInteger32InList(pvApiCtx, iVar, parent, item_position, nbRow, nbCol, tmp_int32);
+                }
+
+                if (sciErr.iErr)
+                {
+                    printError(&sciErr, 0);
+                    return 0;
+                }
+
+                FREE(tmp_int32);
+                break;
 #ifdef __SCILAB_INT64__
-	case I_INT64:
-	  tmp_int64 = (long long *)MALLOC(nbRow*nbCol*sizeof(long long));
-	  if (tmp_int64 == NULL)
-            {
-              Scierror(999, _("%s: No more memory.\n"), "CreateIntegerVariable");
-              return FALSE;
-            }
-	  for(i=0;i<nbRow*nbCol; i++) tmp_int64[i] = ((long long *)matVariable->data)[i];
-
-	  if (parent==NULL)
-	    {
-	      _SciErr = createMatrixOfInteger64(pvApiCtx, iVar, nbRow, nbCol, tmp_int64); MATIO_ERROR;
-	    }
-	  else
-	    {
-	      _SciErr = createMatrixOfInteger64InList(pvApiCtx, iVar, parent, item_position, nbRow, nbCol, tmp_int64); MATIO_ERROR;
-	    }
-
-	  FREE(tmp_int64);
-	  break;
+            case I_INT64:
+                tmp_int64 = (long long *)MALLOC(nbRow * nbCol * sizeof(long long));
+                if (tmp_int64 == NULL)
+                {
+                    Scierror(999, _("%s: No more memory.\n"), "CreateIntegerVariable");
+                    return FALSE;
+                }
+                for (i = 0; i < nbRow * nbCol; i++)
+                {
+                    tmp_int64[i] = ((long long *)matVariable->data)[i];
+                }
+
+                if (parent == NULL)
+                {
+                    sciErr = createMatrixOfInteger64(pvApiCtx, iVar, nbRow, nbCol, tmp_int64);
+                }
+                else
+                {
+                    sciErr = createMatrixOfInteger64InList(pvApiCtx, iVar, parent, item_position, nbRow, nbCol, tmp_int64);
+                }
+
+                if (sciErr.iErr)
+                {
+                    printError(&sciErr, 0);
+                    return 0;
+                }
+
+                FREE(tmp_int64);
+                break;
 #endif
-	case I_UCHAR:
-	  tmp_uint8 = (unsigned char *)MALLOC(nbRow*nbCol*sizeof(unsigned char));
-	  if (tmp_uint8 == NULL)
-            {
-              Scierror(999, _("%s: No more memory.\n"), "CreateIntegerVariable");
-              return FALSE;
-            }
-	  for(i=0;i<nbRow*nbCol; i++) tmp_uint8[i] = ((unsigned char *)matVariable->data)[i];
-
-	  if (parent==NULL)
-	    {
-	      _SciErr = createMatrixOfUnsignedInteger8(pvApiCtx, iVar, nbRow, nbCol, tmp_uint8); MATIO_ERROR;
-	    }
-	  else
-	    {
-	      _SciErr = createMatrixOfUnsignedInteger8InList(pvApiCtx, iVar, parent, item_position, nbRow, nbCol, tmp_uint8); MATIO_ERROR;
-	    }
-
-	  FREE(tmp_uint8);
-	  break;
-	case I_UINT16:
-	  tmp_uint16 = (unsigned short *)MALLOC(nbRow*nbCol*sizeof(unsigned short));
-	  if (tmp_uint16 == NULL)
-            {
-              Scierror(999, _("%s: No more memory.\n"), "CreateIntegerVariable");
-              return FALSE;
-            }
-	  for(i=0;i<nbRow*nbCol; i++) tmp_uint16[i] = ((unsigned short *)matVariable->data)[i];
-
-	  if (parent==NULL)
-	    {
-	      _SciErr = createMatrixOfUnsignedInteger16(pvApiCtx, iVar, nbRow, nbCol, tmp_uint16); MATIO_ERROR;
-	    }
-	  else
-	    {
-	      _SciErr = createMatrixOfUnsignedInteger16InList(pvApiCtx, iVar, parent, item_position, nbRow, nbCol, tmp_uint16); MATIO_ERROR;
-	    }
-
-	  FREE(tmp_uint16);
-	  break;
-	case I_UINT32:
-	  tmp_uint32 = (unsigned int *)MALLOC(nbRow*nbCol*sizeof(unsigned int));
-	  if (tmp_uint32 == NULL)
-            {
-              Scierror(999, _("%s: No more memory.\n"), "CreateIntegerVariable");
-              return FALSE;
-            }
-	  for(i=0;i<nbRow*nbCol; i++) tmp_uint32[i] = ((unsigned int *)matVariable->data)[i];
-
-	  if (parent==NULL)
-	    {
-	      _SciErr = createMatrixOfUnsignedInteger32(pvApiCtx, iVar, nbRow, nbCol, tmp_uint32); MATIO_ERROR;
-	    }
-	  else
-	    {
-	      _SciErr = createMatrixOfUnsignedInteger32InList(pvApiCtx, iVar, parent, item_position, nbRow, nbCol, tmp_uint32); MATIO_ERROR;
-	    }
-
-	  FREE(tmp_uint32);
-	  break;
+            case I_UCHAR:
+                tmp_uint8 = (unsigned char *)MALLOC(nbRow * nbCol * sizeof(unsigned char));
+                if (tmp_uint8 == NULL)
+                {
+                    Scierror(999, _("%s: No more memory.\n"), "CreateIntegerVariable");
+                    return FALSE;
+                }
+                for (i = 0; i < nbRow * nbCol; i++)
+                {
+                    tmp_uint8[i] = ((unsigned char *)matVariable->data)[i];
+                }
+
+                if (parent == NULL)
+                {
+                    sciErr = createMatrixOfUnsignedInteger8(pvApiCtx, iVar, nbRow, nbCol, tmp_uint8);
+                }
+                else
+                {
+                    sciErr = createMatrixOfUnsignedInteger8InList(pvApiCtx, iVar, parent, item_position, nbRow, nbCol, tmp_uint8);
+                }
+
+                if (sciErr.iErr)
+                {
+                    printError(&sciErr, 0);
+                    return 0;
+                }
+
+                FREE(tmp_uint8);
+                break;
+            case I_UINT16:
+                tmp_uint16 = (unsigned short *)MALLOC(nbRow * nbCol * sizeof(unsigned short));
+                if (tmp_uint16 == NULL)
+                {
+                    Scierror(999, _("%s: No more memory.\n"), "CreateIntegerVariable");
+                    return FALSE;
+                }
+                for (i = 0; i < nbRow * nbCol; i++)
+                {
+                    tmp_uint16[i] = ((unsigned short *)matVariable->data)[i];
+                }
+
+                if (parent == NULL)
+                {
+                    sciErr = createMatrixOfUnsignedInteger16(pvApiCtx, iVar, nbRow, nbCol, tmp_uint16);
+                }
+                else
+                {
+                    sciErr = createMatrixOfUnsignedInteger16InList(pvApiCtx, iVar, parent, item_position, nbRow, nbCol, tmp_uint16);
+                }
+
+                if (sciErr.iErr)
+                {
+                    printError(&sciErr, 0);
+                    return 0;
+                }
+
+                FREE(tmp_uint16);
+                break;
+            case I_UINT32:
+                tmp_uint32 = (unsigned int *)MALLOC(nbRow * nbCol * sizeof(unsigned int));
+                if (tmp_uint32 == NULL)
+                {
+                    Scierror(999, _("%s: No more memory.\n"), "CreateIntegerVariable");
+                    return FALSE;
+                }
+                for (i = 0; i < nbRow * nbCol; i++)
+                {
+                    tmp_uint32[i] = ((unsigned int *)matVariable->data)[i];
+                }
+
+                if (parent == NULL)
+                {
+                    sciErr = createMatrixOfUnsignedInteger32(pvApiCtx, iVar, nbRow, nbCol, tmp_uint32);
+                }
+                else
+                {
+                    sciErr = createMatrixOfUnsignedInteger32InList(pvApiCtx, iVar, parent, item_position, nbRow, nbCol, tmp_uint32);
+                }
+
+                if (sciErr.iErr)
+                {
+                    printError(&sciErr, 0);
+                    return 0;
+                }
+
+                FREE(tmp_uint32);
+                break;
 #ifdef __SCILAB_INT64__
-	case I_UINT64:
-	  tmp_uint64 = (unsigned long long *)MALLOC(nbRow*nbCol*sizeof(unsigned long long));
-	  if (tmp_uint64 == NULL)
-            {
-              Scierror(999, _("%s: No more memory.\n"), "CreateIntegerVariable");
-              return FALSE;
-            }
-	  for(i=0;i<nbRow*nbCol; i++) tmp_uint64[i] = ((unsigned long long *)matVariable->data)[i];
-
-	  if (parent==NULL)
-	    {
-	      _SciErr = createMatrixOfUnsignedInteger64(pvApiCtx, iVar, nbRow, nbCol, tmp_uint64); MATIO_ERROR;
-	    }
-	  else
-	    {
-	      _SciErr = createMatrixOfUnsignedInteger64InList(pvApiCtx, iVar, parent, item_position, nbRow, nbCol, tmp_uint64); MATIO_ERROR;
-	    }
-
-	  FREE(tmp_uint64);
-	  break;
+            case I_UINT64:
+                tmp_uint64 = (unsigned long long *)MALLOC(nbRow * nbCol * sizeof(unsigned long long));
+                if (tmp_uint64 == NULL)
+                {
+                    Scierror(999, _("%s: No more memory.\n"), "CreateIntegerVariable");
+                    return FALSE;
+                }
+                for (i = 0; i < nbRow * nbCol; i++)
+                {
+                    tmp_uint64[i] = ((unsigned long long *)matVariable->data)[i];
+                }
+
+                if (parent == NULL)
+                {
+                    sciErr = createMatrixOfUnsignedInteger64(pvApiCtx, iVar, nbRow, nbCol, tmp_uint64);
+                }
+                else
+                {
+                    sciErr = createMatrixOfUnsignedInteger64InList(pvApiCtx, iVar, parent, item_position, nbRow, nbCol, tmp_uint64);
+                }
+
+                if (sciErr.iErr)
+                {
+                    printError(&sciErr, 0);
+                    return 0;
+                }
+
+                FREE(tmp_uint64);
+                break;
 #endif
-	}
+        }
     }
-  else /* Multi-dimension array -> Scilab HyperMatrix */
+    else /* Multi-dimension array -> Scilab HyperMatrix */
     {
-      CreateHyperMatrixVariable(iVar, MATRIX_OF_VARIABLE_SIZE_INTEGER_DATATYPE,  &integerType, &matVariable->rank, 
-				matVariable->dims, matVariable->data, NULL, parent, item_position);
+        piDims = (int*) MALLOC(matVariable->rank * sizeof(int));
+        if (piDims == NULL)
+        {
+            Scierror(999, _("%s: No more memory.\n"), "CreateBooleanVariable");
+            return FALSE;
+        }
+        for (i = 0; i < matVariable->rank; i++)
+        {
+            piDims[i] = matVariable->dims[i];
+        }
+
+        CreateHyperMatrixVariable(pvApiCtx, iVar, MATRIX_OF_VARIABLE_SIZE_INTEGER_DATATYPE,  &integerType, &matVariable->rank,
+                                  piDims, matVariable->data, NULL, parent, item_position);
+
+        FREE(piDims);
     }
-  
-  return TRUE;
+
+    return TRUE;
 }
diff --git a/modules/matio/src/c/CreateMatlabVariable.c b/modules/matio/src/c/CreateMatlabVariable.c
index f96be35..4ee2d98 100644
--- a/modules/matio/src/c/CreateMatlabVariable.c
+++ b/modules/matio/src/c/CreateMatlabVariable.c
@@ -1,12 +1,12 @@
 /*
  * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
- * Copyright (C) 2008 - INRIA - Vincent COUVERT 
+ * Copyright (C) 2008 - INRIA - Vincent COUVERT
  * Copyright (C) 2010 - DIGITEO - Yann COLLETTE
- * 
+ *
  * This file must be used under the terms of the CeCILL.
  * This source file is licensed as described in the file COPYING, which
  * you should have received as part of this distribution.  The terms
- * are also available at    
+ * are also available at
  * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
  *
  */
@@ -14,72 +14,77 @@
 #include "CreateMatlabVariable.h"
 #include "api_scilab.h"
 
-int CreateMatlabVariable(int iVar, matvar_t *matVariable, int * parent, int item_position)
+int CreateMatlabVariable(void *pvApiCtx, int iVar, matvar_t *matVariable, int * parent, int item_position)
 {
-  SciErr _SciErr;
+    SciErr sciErr;
 
-  /* To be sure isComplex is 0 or 1 */
-  matVariable->isComplex =  matVariable->isComplex != 0;
+    /* To be sure isComplex is 0 or 1 */
+    matVariable->isComplex =  matVariable->isComplex != 0;
 
-  switch(matVariable->class_type)
+    switch (matVariable->class_type)
     {
-    case MAT_C_CELL: /* 1 */
-      CreateCellVariable(iVar, matVariable, parent, item_position);
-      break;
-    case MAT_C_STRUCT: /* 2 */
-      CreateStructVariable(iVar, matVariable, parent, item_position);
-      break;
-    case MAT_C_CHAR: /* 4 */
-      CreateCharVariable(iVar, matVariable, parent, item_position);
-      break;
-    case MAT_C_SPARSE: /* 5 */
-      CreateSparseVariable(iVar, matVariable, parent, item_position);
-      break;
-    case MAT_C_DOUBLE: /* 6 */
-    case MAT_C_SINGLE: /* 7 */
-      CreateDoubleVariable(iVar, matVariable, parent, item_position);
-      break;
-    case MAT_C_INT8: /* 8 */
-      CreateIntegerVariable(iVar, I_CHAR, matVariable, parent, item_position);
-      break;
-    case MAT_C_UINT8: /* 9 */
-      if (matVariable->isLogical != 0)
-        {
-          CreateBooleanVariable(iVar, matVariable, parent, item_position);
-        }
-      else
-        {
-          CreateIntegerVariable(iVar, I_UCHAR, matVariable, parent, item_position);
-        }
-      break;
-    case MAT_C_INT16: /* 10 */
-      CreateIntegerVariable(iVar, I_INT16, matVariable, parent, item_position);
-      break;
-    case MAT_C_UINT16: /* 11 */
-      CreateIntegerVariable(iVar, I_UINT16, matVariable, parent, item_position);
-      break;
-    case MAT_C_INT32: /* 12 */
-      CreateIntegerVariable(iVar, I_INT32, matVariable, parent, item_position);
-      break;
-    case MAT_C_UINT32: /* 13 */
-      CreateIntegerVariable(iVar, I_UINT32, matVariable, parent, item_position);
-      break;
-    case MAT_C_OBJECT: /* 3 to be written */
-    case MAT_C_INT64: /* 14: no Scilab equivalent */
-    case MAT_C_UINT64: /* 15: no Scilab equivalent */
-    case MAT_C_FUNCTION: /* 16 to be written */
-    default:
-      /* Empty matrix returned */
-      if (parent==NULL)
-	{
-	  createEmptyMatrix(pvApiCtx, iVar);
-	}
-      else
-	{
-	  _SciErr = createMatrixOfDoubleInList(pvApiCtx, iVar, parent, item_position, 0, 0, NULL);
-	}
-      return FALSE;
+        case MAT_C_CELL: /* 1 */
+            CreateCellVariable(pvApiCtx, iVar, matVariable, parent, item_position);
+            break;
+        case MAT_C_STRUCT: /* 2 */
+            CreateStructVariable(pvApiCtx, iVar, matVariable, parent, item_position);
+            break;
+        case MAT_C_CHAR: /* 4 */
+            CreateCharVariable(pvApiCtx, iVar, matVariable, parent, item_position);
+            break;
+        case MAT_C_SPARSE: /* 5 */
+            CreateSparseVariable(pvApiCtx, iVar, matVariable, parent, item_position);
+            break;
+        case MAT_C_DOUBLE: /* 6 */
+        case MAT_C_SINGLE: /* 7 */
+            CreateDoubleVariable(pvApiCtx, iVar, matVariable, parent, item_position);
+            break;
+        case MAT_C_INT8: /* 8 */
+            CreateIntegerVariable(pvApiCtx, iVar, I_CHAR, matVariable, parent, item_position);
+            break;
+        case MAT_C_UINT8: /* 9 */
+            if (matVariable->isLogical != 0)
+            {
+                CreateBooleanVariable(pvApiCtx, iVar, matVariable, parent, item_position);
+            }
+            else
+            {
+                CreateIntegerVariable(pvApiCtx, iVar, I_UCHAR, matVariable, parent, item_position);
+            }
+            break;
+        case MAT_C_INT16: /* 10 */
+            CreateIntegerVariable(pvApiCtx, iVar, I_INT16, matVariable, parent, item_position);
+            break;
+        case MAT_C_UINT16: /* 11 */
+            CreateIntegerVariable(pvApiCtx, iVar, I_UINT16, matVariable, parent, item_position);
+            break;
+        case MAT_C_INT32: /* 12 */
+            CreateIntegerVariable(pvApiCtx, iVar, I_INT32, matVariable, parent, item_position);
+            break;
+        case MAT_C_UINT32: /* 13 */
+            CreateIntegerVariable(pvApiCtx, iVar, I_UINT32, matVariable, parent, item_position);
+            break;
+        case MAT_C_OBJECT: /* 3 to be written */
+        case MAT_C_INT64: /* 14: no Scilab equivalent */
+        case MAT_C_UINT64: /* 15: no Scilab equivalent */
+        case MAT_C_FUNCTION: /* 16 to be written */
+        default:
+            /* Empty matrix returned */
+            if (parent == NULL)
+            {
+                createEmptyMatrix(pvApiCtx, iVar);
+            }
+            else
+            {
+                sciErr = createMatrixOfDoubleInList(pvApiCtx, iVar, parent, item_position, 0, 0, NULL);
+                if (sciErr.iErr)
+                {
+                    printError(&sciErr, 0);
+                    return 0;
+                }
+            }
+            return FALSE;
     }
 
-  return TRUE;
+    return TRUE;
 }
diff --git a/modules/matio/src/c/CreateMatlabVariable.h b/modules/matio/src/c/CreateMatlabVariable.h
index 25a2405..fbc350b 100644
--- a/modules/matio/src/c/CreateMatlabVariable.h
+++ b/modules/matio/src/c/CreateMatlabVariable.h
@@ -1,12 +1,12 @@
 /*
  * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
- * Copyright (C) 2008 - INRIA - Vincent COUVERT 
- * Copyright (C) 2010 - DIGITEO - Yann COLLETTE 
- * 
+ * Copyright (C) 2008 - INRIA - Vincent COUVERT
+ * Copyright (C) 2010 - DIGITEO - Yann COLLETTE
+ *
  * This file must be used under the terms of the CeCILL.
  * This source file is licensed as described in the file COPYING, which
  * you should have received as part of this distribution.  The terms
- * are also available at    
+ * are also available at
  * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
  *
  */
@@ -18,35 +18,38 @@
 
 /*
  * Create a Scilab variable on stack from a Matlab variable
- * This function write nothing on stack but calls the function which 
+ * This function write nothing on stack but calls the function which
  * does the work according to Matlab Variable type
- * 
+ *
+ * @param pvApiCtx Scilab context
  * @param iVar position on the stack
  * @param matVariable Matlab variable (See MATIO library)
  * @param parent parent mlist. If NULL, a normal variable is created.
- * @parem item_position position of the variable in the mlist. Only effective if parent !=NULL
+ * @param item_position position of the variable in the mlist. Only effective if parent !=NULL
  *
  * @return TRUE if the variable has been written without problem
  */
-int CreateMatlabVariable(int iVar, matvar_t *matVariable, int * parent, int item_position);
+int CreateMatlabVariable(void *pvApiCtx, int iVar, matvar_t *matVariable, int * parent, int item_position);
 
 
 /*
  * Create a Scilab Integer variable on stack from a Matlab variable
- * 
+ *
+ * @param pvApiCtx Scilab context
  * @param iVar position on the stack
  * @param integerType Scilab int type (See stack-c.h)
  * @param matVariable Matlab variable (See MATIO library)
  * @param parent parent mlist. If NULL, a normal variable is created.
- * @parem item_position position of the variable in the mlist. Only effective if parent !=NULL
+ * @param item_position position of the variable in the mlist. Only effective if parent !=NULL
  *
  * @return TRUE if the variable has been written without problem
  */
-int CreateIntegerVariable(int iVar, int integerType, matvar_t *matVariable, int * parent, int item_position);
+int CreateIntegerVariable(void *pvApiCtx, int iVar, int integerType, matvar_t *matVariable, int * parent, int item_position);
 
 /*
  * Create a Scilab HyperMatrix variable on stack from a Matlab variable
- * 
+ *
+ * @param pvApiCtx Scilab context
  * @param iVar position on the stack
  * @param type contents data type
  * @param iscomplex TRUE if the variable is Complex
@@ -55,82 +58,88 @@ int CreateIntegerVariable(int iVar, int integerType, matvar_t *matVariable, int
  * @param realdata pointer to real data
  * @param complexdata pointer to complex data
  * @param parent parent mlist. If NULL, a normal variable is created.
- * @parem item_position position of the variable in the mlist. Only effective if parent !=NULL
+ * @param item_position position of the variable in the mlist. Only effective if parent !=NULL
  *
  * @return TRUE if the variable has been written without problem
  */
-int CreateHyperMatrixVariable(int iVar, const char *type, int *iscomplex, int * rank, int *dims, double *realdata, double *complexdata, int * parent, int item_position);
+int CreateHyperMatrixVariable(void *pvApiCtx, int iVar, const char *type, int *iscomplex, int * rank, int *dims, double *realdata, double *complexdata, int * parent, int item_position);
 
 /*
  * Create a Scilab Struct variable on stack from a Matlab variable
- * 
+ *
+ * @param pvApiCtx Scilab context
  * @param iVar position on the stack
  * @param matVariable Matlab variable (See MATIO library)
  * @param parent parent mlist. If NULL, a normal variable is created.
- * @parem item_position position of the variable in the mlist. Only effective if parent !=NULL
+ * @param item_position position of the variable in the mlist. Only effective if parent !=NULL
  *
  * @return TRUE if the variable has been written without problem
  */
-int CreateStructVariable(int iVar, matvar_t *matVariable, int * parent, int item_position);
+int CreateStructVariable(void *pvApiCtx, int iVar, matvar_t *matVariable, int * parent, int item_position);
 
 /*
  * Create a Scilab Cell variable on stack from a Matlab variable
- * 
+ *
+ * @param pvApiCtx Scilab context
  * @param iVar position on the stack
  * @param matVariable Matlab variable (See MATIO library)
  * @param parent parent mlist. If NULL, a normal variable is created.
- * @parem item_position position of the variable in the mlist. Only effective if parent !=NULL
+ * @param item_position position of the variable in the mlist. Only effective if parent !=NULL
  *
  * @return TRUE if the variable has been written without problem
  */
-int CreateCellVariable(int iVar, matvar_t *matVariable, int * parent, int item_position);
+int CreateCellVariable(void *pvApiCtx, int iVar, matvar_t *matVariable, int * parent, int item_position);
 
 /*
  * Create a Scilab Char variable on stack from a Matlab variable
- * 
+ *
+ * @param pvApiCtx Scilab context
  * @param iVar position on the stack
  * @param matVariable Matlab variable (See MATIO library)
  * @param parent parent mlist. If NULL, a normal variable is created.
- * @parem item_position position of the variable in the mlist. Only effective if parent !=NULL
+ * @param item_position position of the variable in the mlist. Only effective if parent !=NULL
  *
  * @return TRUE if the variable has been written without problem
  */
-int CreateCharVariable(int iVar, matvar_t *matVariable, int * parent, int item_position);
+int CreateCharVariable(void *pvApiCtx, int iVar, matvar_t *matVariable, int * parent, int item_position);
 
 /*
  * Create a Scilab Sparse variable on stack from a Matlab variable
- * 
+ *
+ * @param pvApiCtx Scilab context
  * @param iVar position on the stack
  * @param matVariable Matlab variable (See MATIO library)
  * @param parent parent mlist. If NULL, a normal variable is created.
- * @parem item_position position of the variable in the mlist. Only effective if parent !=NULL
+ * @param item_position position of the variable in the mlist. Only effective if parent !=NULL
  *
  * @return TRUE if the variable has been written without problem
  */
-int CreateSparseVariable(int iVar, matvar_t *matVariable, int * parent, int item_position);
+int CreateSparseVariable(void *pvApiCtx, int iVar, matvar_t *matVariable, int * parent, int item_position);
 
 /*
  * Create a Scilab Double variable on stack from a Matlab variable
- * 
+ *
+ * @param pvApiCtx Scilab context
  * @param iVar position on the stack
  * @param matVariable Matlab variable (See MATIO library)
  * @param parent parent mlist. If NULL, a normal variable is created.
- * @parem item_position position of the variable in the mlist. Only effective if parent !=NULL
+ * @param item_position position of the variable in the mlist. Only effective if parent !=NULL
  *
  * @return TRUE if the variable has been written without problem
  */
-int CreateDoubleVariable(int iVar, matvar_t *matVariable, int * parent, int item_position);
+int CreateDoubleVariable(void *pvApiCtx, int iVar, matvar_t *matVariable, int * parent, int item_position);
 
 /*
  * Create a Scilab Boolean variable on stack from a Matlab variable
- * 
+ *
+ * @param pvApiCtx Scilab context
  * @param iVar position on the stack
  * @param matVariable Matlab variable (See MATIO library)
  * @param parent parent mlist. If NULL, a normal variable is created.
- * @parem item_position position of the variable in the mlist. Only effective if parent !=NULL
+ * @param item_position position of the variable in the mlist. Only effective if parent !=NULL
  *
  * @return TRUE if the variable has been written without problem
  */
-int CreateBooleanVariable(int iVar, matvar_t *matVariable, int * parent, int item_position);
+int CreateBooleanVariable(void *pvApiCtx, int iVar, matvar_t *matVariable, int * parent, int item_position);
 
 #endif /* !__CREATEMATLABVARIABLE_H__ */
diff --git a/modules/matio/src/c/CreateSparseVariable.c b/modules/matio/src/c/CreateSparseVariable.c
index ee4c2c4..0edae61 100644
--- a/modules/matio/src/c/CreateSparseVariable.c
+++ b/modules/matio/src/c/CreateSparseVariable.c
@@ -1,12 +1,12 @@
 /*
  * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
- * Copyright (C) 2008 - INRIA - Vincent COUVERT 
+ * Copyright (C) 2008 - INRIA - Vincent COUVERT
  * Copyright (C) 2010 - DIGITEO - Yann COLLETTE
- * 
+ *
  * This file must be used under the terms of the CeCILL.
  * This source file is licensed as described in the file COPYING, which
  * you should have received as part of this distribution.  The terms
- * are also available at    
+ * are also available at
  * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
  *
  */
@@ -19,196 +19,239 @@
 #include "Scierror.h"
 #include "sciprint.h"
 
-
-#define MATIO_ERROR if(_SciErr.iErr) \
-    {				     \
-      printError(&_SciErr, 0);	     \
-      return 0;			     \
-    }
-
 /* Defined in SCI/modules/sparse/src/fortran/spt.f */
-extern int C2F(spt)(int *m, int *n, int *nel, int *it, int *workArray, 
-		    double *A_R, double *A_I, int *A_mnel, int *A_icol,
-		    double *At_R, double *At_I, int *At_mnel, int *At_icol);
-		   
-int CreateSparseVariable(int iVar, matvar_t *matVariable, int * parent, int item_position)
+extern int C2F(spt)(int *m, int *n, int *nel, int *it, int *workArray,
+                    double *A_R, double *A_I, int *A_mnel, int *A_icol,
+                    double *At_R, double *At_I, int *At_mnel, int *At_icol);
+
+int CreateSparseVariable(void *pvApiCtx, int iVar, matvar_t *matVariable, int * parent, int item_position)
 {
-  int K = 0;
-  sparse_t *sparseData = NULL;
-  SciSparse *scilabSparse = NULL;
-  SciSparse *scilabSparseT = NULL; /* Transpose */
-  int *colIndexes = NULL;
-  int *rowIndexes = NULL;
-  int *workArray = NULL;
-  struct ComplexSplit *complexData = NULL;
-  SciErr _SciErr;
+    int K = 0;
+    mat_sparse_t *sparseData = NULL;
+    SciSparse *scilabSparse = NULL;
+    SciSparse *scilabSparseT = NULL; /* Transpose */
+    int *colIndexes = NULL;
+    int *rowIndexes = NULL;
+    int *workArray = NULL;
+    struct mat_complex_split_t *complexData = NULL;
+    SciErr sciErr;
 
-  sparseData = (sparse_t*) matVariable->data;
+    sparseData = (mat_sparse_t*) matVariable->data;
 
-  scilabSparse = (SciSparse*) MALLOC(sizeof(SciSparse));
-  if (scilabSparse==NULL)
+    scilabSparse = (SciSparse*) MALLOC(sizeof(SciSparse));
+    if (scilabSparse == NULL)
     {
-      Scierror(999, _("%s: No more memory.\n"), "CreateSparseVariable");
-      return FALSE;
+        Scierror(999, _("%s: No more memory.\n"), "CreateSparseVariable");
+        return FALSE;
     }
 
-  /* Computes column indexes from Matlab indexes */
-  if (sparseData->njc > 1)
+    /* Computes column indexes from Matlab indexes */
+    if (sparseData->njc > 1)
     {
-      colIndexes = (int*) MALLOC(sizeof(int) *  (sparseData->njc-1));
-      if (colIndexes==NULL)
+        colIndexes = (int*) MALLOC(sizeof(int) *  (sparseData->njc - 1));
+        if (colIndexes == NULL)
         {
-          Scierror(999, _("%s: No more memory.\n"), "CreateSparseVariable");
-          return FALSE;
+            Scierror(999, _("%s: No more memory.\n"), "CreateSparseVariable");
+            return FALSE;
         }
-      
-      for (K=0; K<sparseData->njc-1; K++)
+
+        for (K = 0; K < sparseData->njc - 1; K++)
         {
-          colIndexes[K] = sparseData->jc[K+1] - sparseData->jc[K];
+            colIndexes[K] = sparseData->jc[K + 1] - sparseData->jc[K];
         }
     }
 
-  /* Computes row indexes from Matlab indexes */
-  rowIndexes = (int*) MALLOC(sizeof(int) * sparseData->nir);
-  if (rowIndexes==NULL)
+    /* Computes row indexes from Matlab indexes */
+    rowIndexes = (int*) MALLOC(sizeof(int) * sparseData->nir);
+    if (rowIndexes == NULL)
     {
-      Scierror(999, _("%s: No more memory.\n"), "CreateSparseVariable");
-      return FALSE;
+        Scierror(999, _("%s: No more memory.\n"), "CreateSparseVariable");
+        return FALSE;
     }
 
-  for (K=0; K<sparseData->nir; K++)
+    for (K = 0; K < sparseData->nir; K++)
     {
-      rowIndexes[K] = sparseData->ir[K] + 1;
+        rowIndexes[K] = sparseData->ir[K] + 1;
     }
 
-  /* Create sparse matrix to be transposed */
-  scilabSparse->m    = matVariable->dims[1];
-  scilabSparse->n    = matVariable->dims[0];
-  scilabSparse->it   = matVariable->isComplex;
-  scilabSparse->nel  = sparseData->ndata;
-  scilabSparse->mnel = colIndexes;
-  scilabSparse->icol = rowIndexes;
+    /* Create sparse matrix to be transposed */
+    scilabSparse->m    = matVariable->dims[1];
+    scilabSparse->n    = matVariable->dims[0];
+    scilabSparse->it   = matVariable->isComplex;
+    scilabSparse->nel  = sparseData->ndata;
+    scilabSparse->mnel = colIndexes;
+    scilabSparse->icol = rowIndexes;
 
-  if (scilabSparse->it == 0)
+    if (scilabSparse->it == 0)
     {
-      scilabSparse->R = (double*) sparseData->data;
-      scilabSparse->I = NULL;
+        scilabSparse->R = (double*) sparseData->data;
+        scilabSparse->I = NULL;
     }
-  else
+    else
     {
-      complexData = (struct ComplexSplit *) sparseData->data;
-      scilabSparse->R = (double *) complexData->Re;
-      scilabSparse->I = (double *) complexData->Im;
+        complexData = (struct mat_complex_split_t *) sparseData->data;
+        scilabSparse->R = (double *) complexData->Re;
+        scilabSparse->I = (double *) complexData->Im;
     }
 
-  /* Create transpose */
-  scilabSparseT = (SciSparse*) MALLOC(sizeof(SciSparse));
-  if (scilabSparseT==NULL)
+    /* Create transpose */
+    scilabSparseT = (SciSparse*) MALLOC(sizeof(SciSparse));
+    if (scilabSparseT == NULL)
     {
-      Scierror(999, _("%s: No more memory.\n"), "CreateSparseVariable");
-      return FALSE;
+        Scierror(999, _("%s: No more memory.\n"), "CreateSparseVariable");
+        return FALSE;
     }
 
-  scilabSparseT->m   = scilabSparse->n;
-  scilabSparseT->n   = scilabSparse->m;
-  scilabSparseT->it  = scilabSparse->it;
-  scilabSparseT->nel = scilabSparse->nel;
+    scilabSparseT->m   = scilabSparse->n;
+    scilabSparseT->n   = scilabSparse->m;
+    scilabSparseT->it  = scilabSparse->it;
+    scilabSparseT->nel = scilabSparse->nel;
 
-  if (scilabSparseT->m == 0)
+    if (scilabSparseT->m == 0)
     {
-      workArray = (int*) MALLOC(sizeof(int));
+        workArray = (int*) MALLOC(sizeof(int));
     }
-  else
+    else
     {
-      workArray = (int*) MALLOC(sizeof(int) * scilabSparseT->m);
+        workArray = (int*) MALLOC(sizeof(int) * scilabSparseT->m);
+    }
+
+    if (workArray == NULL)
+    {
+        Scierror(999, _("%s: No more memory.\n"), "CreateSparseVariable");
+        return FALSE;
+    }
+
+    if (scilabSparseT->m != 0)
+    {
+        scilabSparseT->mnel = (int*) MALLOC(sizeof(int) * scilabSparseT->m);
+        if (scilabSparseT->mnel == NULL)
+        {
+            Scierror(999, _("%s: No more memory.\n"), "CreateSparseVariable");
+            return FALSE;
+        }
     }
 
-  if (workArray==NULL)
+    if (scilabSparseT->nel != 0)
     {
-      Scierror(999, _("%s: No more memory.\n"), "CreateSparseVariable");
-      return FALSE;
+        scilabSparseT->icol = (int*) MALLOC(sizeof(int) * scilabSparseT->nel);
+        if (scilabSparseT->icol == NULL)
+        {
+            Scierror(999, _("%s: No more memory.\n"), "CreateSparseVariable");
+            return FALSE;
+        }
     }
 
-  if (scilabSparseT->m != 0) {
-    scilabSparseT->mnel = (int*) MALLOC(sizeof(int) * scilabSparseT->m); 
-    if (scilabSparseT->mnel==NULL)
-      {
-	Scierror(999, _("%s: No more memory.\n"), "CreateSparseVariable");
-	return FALSE;
-      }
-  }
+    if (scilabSparseT->nel != 0)
+    {
+        scilabSparseT->R = (double*) MALLOC(sizeof(double) * scilabSparseT->nel);
+        if (scilabSparseT->R == NULL)
+        {
+            Scierror(999, _("%s: No more memory.\n"), "CreateSparseVariable");
+            return FALSE;
+        }
+    }
 
-  if (scilabSparseT->nel != 0) {
-    scilabSparseT->icol = (int*) MALLOC(sizeof(int) * scilabSparseT->nel); 
-    if (scilabSparseT->icol==NULL)
-      {
-	Scierror(999, _("%s: No more memory.\n"), "CreateSparseVariable");
-	return FALSE;
-      }
-  }
+    if (scilabSparseT->it)
+    {
+        scilabSparseT->I = (double*) MALLOC(sizeof(double) * scilabSparseT->nel);
+        if (scilabSparseT->I == NULL)
+        {
+            Scierror(999, _("%s: No more memory.\n"), "CreateSparseVariable");
+            return FALSE;
+        }
+    }
 
-  if (scilabSparseT->nel != 0) {
-    scilabSparseT->R = (double*) MALLOC(sizeof(double) * scilabSparseT->nel); 
-    if (scilabSparseT->R==NULL)
-      {
-	Scierror(999, _("%s: No more memory.\n"), "CreateSparseVariable");
-	return FALSE;
-      }
-  }
+    C2F(spt)(&scilabSparse->m, &scilabSparse->n, &scilabSparse->nel, &scilabSparse->it, workArray,
+             scilabSparse->R, scilabSparse->I, scilabSparse->mnel, scilabSparse->icol,
+             scilabSparseT->R, scilabSparseT->I, scilabSparseT->mnel, scilabSparseT->icol);
 
-  if (scilabSparseT->it)
+    if (scilabSparse->it)
+    {
+        if (parent == NULL)
+        {
+            sciErr = createComplexSparseMatrix(pvApiCtx, iVar, scilabSparse->m, scilabSparse->n, scilabSparse->nel,
+                                               scilabSparseT->mnel, scilabSparseT->icol, scilabSparseT->R, scilabSparseT->I);
+            if (sciErr.iErr)
+            {
+                printError(&sciErr, 0);
+                return 0;
+            }
+        }
+        else
+        {
+            sciErr = createComplexSparseMatrixInList(pvApiCtx, iVar, parent, item_position,
+                     scilabSparse->m, scilabSparse->n, scilabSparse->nel,
+                     scilabSparseT->mnel, scilabSparseT->icol, scilabSparseT->R, scilabSparseT->I);
+            if (sciErr.iErr)
+            {
+                printError(&sciErr, 0);
+                return 0;
+            }
+        }
+    }
+    else
     {
-      scilabSparseT->I = (double*) MALLOC(sizeof(double) * scilabSparseT->nel);
-      if (scilabSparseT->I==NULL)
+        if (parent == NULL)
         {
-          Scierror(999, _("%s: No more memory.\n"), "CreateSparseVariable");
-          return FALSE;
+            sciErr = createSparseMatrix(pvApiCtx, iVar, scilabSparseT->m, scilabSparseT->n, scilabSparseT->nel,
+                                        scilabSparseT->mnel, scilabSparseT->icol, scilabSparseT->R);
+            if (sciErr.iErr)
+            {
+                printError(&sciErr, 0);
+                return 0;
+            }
         }
+        else
+        {
+            sciErr = createSparseMatrixInList(pvApiCtx, iVar, parent, item_position,
+                                              scilabSparseT->m, scilabSparseT->n, scilabSparseT->nel,
+                                              scilabSparseT->mnel, scilabSparseT->icol, scilabSparseT->R);
+            if (sciErr.iErr)
+            {
+                printError(&sciErr, 0);
+                return 0;
+            }
+        }
+    }
+
+    /* Free all arrays */
+    if (scilabSparse != NULL)
+    {
+        FREE(scilabSparse);
+    }
+    if (colIndexes != NULL)
+    {
+        FREE(colIndexes);
+    }
+    if (rowIndexes != NULL)
+    {
+        FREE(rowIndexes);
     }
-  
-  C2F(spt)(&scilabSparse->m, &scilabSparse->n, &scilabSparse->nel, &scilabSparse->it, workArray, 
-	   scilabSparse->R, scilabSparse->I, scilabSparse->mnel, scilabSparse->icol,
-	   scilabSparseT->R, scilabSparseT->I, scilabSparseT->mnel, scilabSparseT->icol);
-
-  if (scilabSparse->it)
-    {
-      if (parent==NULL)
-	{
-	  _SciErr = createComplexSparseMatrix(pvApiCtx, iVar, scilabSparse->m, scilabSparse->n, scilabSparse->nel,
-					      scilabSparseT->mnel, scilabSparseT->icol, scilabSparseT->R, scilabSparseT->I);
-	}
-      else
-	{
-	  _SciErr = createComplexSparseMatrixInList(pvApiCtx, iVar, parent, item_position,
-						    scilabSparse->m, scilabSparse->n, scilabSparse->nel,
-						    scilabSparseT->mnel, scilabSparseT->icol, scilabSparseT->R, scilabSparseT->I);
-	}
-    }
-  else
-    {
-      if (parent==NULL)
-	{
-	  _SciErr = createSparseMatrix(pvApiCtx, iVar, scilabSparseT->m, scilabSparseT->n, scilabSparseT->nel,
-				       scilabSparseT->mnel, scilabSparseT->icol, scilabSparseT->R);
-	}
-      else
-	{
-	  _SciErr = createSparseMatrixInList(pvApiCtx, iVar, parent, item_position, 
-					     scilabSparseT->m, scilabSparseT->n, scilabSparseT->nel,
-					     scilabSparseT->mnel, scilabSparseT->icol, scilabSparseT->R);
-	}
-    }
-
-  /* Free all arrays */
-  if (scilabSparse != NULL)    FREE(scilabSparse);
-  if (colIndexes != NULL)      FREE(colIndexes);
-  if (rowIndexes != NULL)      FREE(rowIndexes);
-  if (workArray != NULL)       FREE(workArray);
-  if (scilabSparseT->m != 0)   FREE(scilabSparseT->mnel);
-  if (scilabSparseT->nel != 0) FREE(scilabSparseT->icol);
-  if (scilabSparseT->nel != 0) FREE(scilabSparseT->R);
-  if ((scilabSparseT->nel != 0) && (scilabSparseT->it != 0)) FREE(scilabSparseT->I);
-  if (scilabSparseT != NULL)   FREE(scilabSparseT);
-  
-  return TRUE;
+    if (workArray != NULL)
+    {
+        FREE(workArray);
+    }
+    if (scilabSparseT->m != 0)
+    {
+        FREE(scilabSparseT->mnel);
+    }
+    if (scilabSparseT->nel != 0)
+    {
+        FREE(scilabSparseT->icol);
+    }
+    if (scilabSparseT->nel != 0)
+    {
+        FREE(scilabSparseT->R);
+    }
+    if ((scilabSparseT->nel != 0) && (scilabSparseT->it != 0))
+    {
+        FREE(scilabSparseT->I);
+    }
+    if (scilabSparseT != NULL)
+    {
+        FREE(scilabSparseT);
+    }
+
+    return TRUE;
 }
diff --git a/modules/matio/src/c/CreateStructVariable.c b/modules/matio/src/c/CreateStructVariable.c
index f6dc231..6e5fb29 100644
--- a/modules/matio/src/c/CreateStructVariable.c
+++ b/modules/matio/src/c/CreateStructVariable.c
@@ -1,12 +1,12 @@
 /*
  * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
- * Copyright (C) 2008 - INRIA - Vincent COUVERT 
+ * Copyright (C) 2008 - INRIA - Vincent COUVERT
  * Copyright (C) 2010 - DIGITEO - Yann COLLETTE
- * 
+ *
  * This file must be used under the terms of the CeCILL.
  * This source file is licensed as described in the file COPYING, which
  * you should have received as part of this distribution.  The terms
- * are also available at    
+ * are also available at
  * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
  *
  */
@@ -23,139 +23,168 @@
 #include "Scierror.h"
 #include "sciprint.h"
 
-#define MATIO_ERROR if(_SciErr.iErr) \
-    {				     \
-      printError(&_SciErr, 0);	     \
-      return 0;			     \
+int CreateStructVariable(void *pvApiCtx, int iVar, matvar_t *matVariable, int * parent, int item_position)
+{
+    char **fieldNames = NULL;
+    int nbFields = 0;
+    int fieldIndex = 0;
+    int K = 0;
+    int prodDims = 0;
+    int valueIndex = 0;
+    matvar_t *fieldMatVar = NULL;
+    matvar_t ** allData = NULL;
+    int * cell_addr = NULL;
+    int * cell_entry_addr = NULL;
+    int type;
+    SciErr sciErr;
+    int *piDims = NULL;
+    int i = 0;
+
+    /* Fields of the struct */
+    nbFields = 2; /* "st" "dims" */
+    nbFields += Mat_VarGetNumberOfFields(matVariable);
+
+    fieldNames = (char**) MALLOC(sizeof(char*) * nbFields);
+    if (fieldNames == NULL)
+    {
+        Scierror(999, _("%s: No more memory.\n"), "CreateStructVariable");
+        return FALSE;
     }
 
-int CreateStructVariable(int iVar, matvar_t *matVariable, int * parent, int item_position)
-{
-  char **fieldNames = NULL;
-  int nbFields = 0;
-  int fieldIndex = 0;
-  int K = 0;
-  int prodDims = 0;
-  int valueIndex = 0;
-  matvar_t *fieldMatVar = NULL;
-  matvar_t ** allData = NULL;
-  int * cell_addr = NULL;
-  int * cell_entry_addr = NULL;
-  int type;
-  SciErr _SciErr;
-    
-  /* Fields of the struct */
-  nbFields = 2; /* "st" "dims" */
-  nbFields += Mat_VarGetNumberOfFields(matVariable);
-
-  fieldNames = (char**) MALLOC(sizeof(char*) * nbFields);
-  if (fieldNames==NULL)
+    fieldNames[0] = strdup("st");
+    if (fieldNames[0] == NULL)
     {
-      Scierror(999, _("%s: No more memory.\n"), "CreateStructVariable");
-      return FALSE;
+        Scierror(999, _("%s: No more memory.\n"), "CreateStructVariable");
+        return FALSE;
     }
-  
-  fieldNames[0] = strdup("st");
-  if (fieldNames[0]==NULL)
+    fieldNames[1] = strdup("dims");
+    if (fieldNames[1] == NULL)
     {
-      Scierror(999, _("%s: No more memory.\n"), "CreateStructVariable");
-      return FALSE;
+        Scierror(999, _("%s: No more memory.\n"), "CreateStructVariable");
+        return FALSE;
+    }
+
+    for (fieldIndex = 1; fieldIndex < nbFields - 1; fieldIndex++)
+    {
+        fieldMatVar = Mat_VarGetStructField(matVariable, &fieldIndex, MAT_BY_INDEX, 0);
+        fieldNames[fieldIndex + 1] = strdup(fieldMatVar->name);
+        if (fieldNames[fieldIndex + 1] == NULL)
+        {
+            Scierror(999, _("%s: No more memory.\n"), "CreateStructVariable");
+            return FALSE;
+        }
     }
-  fieldNames[1] = strdup("dims");
-  if (fieldNames[1]==NULL)
+
+    /* Returned mlist initialization */
+    if (parent == NULL)
     {
-      Scierror(999, _("%s: No more memory.\n"), "CreateStructVariable");
-      return FALSE;
+        sciErr = createMList(pvApiCtx, iVar, nbFields, &cell_addr);
+        if (sciErr.iErr)
+        {
+            printError(&sciErr, 0);
+            return 0;
+        }
     }
-  
-  for (fieldIndex = 1; fieldIndex < nbFields - 1; fieldIndex++)
+    else
     {
-      fieldMatVar = Mat_VarGetStructField(matVariable, &fieldIndex, BY_INDEX, 0);
-      fieldNames[fieldIndex + 1] = strdup(fieldMatVar->name);
-      if (fieldNames[fieldIndex + 1]==NULL)
+        sciErr = createMListInList(pvApiCtx, iVar, parent, item_position, nbFields, &cell_addr);
+        if (sciErr.iErr)
         {
-          Scierror(999, _("%s: No more memory.\n"), "CreateStructVariable");
-          return FALSE;
+            printError(&sciErr, 0);
+            return 0;
         }
     }
-  
-  /* Returned mlist initialization */
-  if (parent==NULL)
+
+    /* FIRST LIST ENTRY: fieldnames */
+    sciErr = createMatrixOfStringInList(pvApiCtx, iVar, cell_addr, 1, 1, nbFields, fieldNames);
+    if (sciErr.iErr)
     {
-      _SciErr = createMList(pvApiCtx, iVar, nbFields, &cell_addr); MATIO_ERROR;
+        printError(&sciErr, 0);
+        return 0;
     }
-  else
+
+    /* SECOND LIST ENTRY: Dimensions (int32 type) */
+    if (nbFields == 2) /* Empty struct must have size 0x0 in Scilab */
     {
-      _SciErr = createMListInList(pvApiCtx, iVar, parent, item_position, nbFields, &cell_addr); MATIO_ERROR;
+        matVariable->dims[0] = 0;
+        matVariable->dims[1] = 0;
     }
 
-  /* FIRST LIST ENTRY: fieldnames */
-  _SciErr = createMatrixOfStringInList(pvApiCtx, iVar, cell_addr, 1, 1, nbFields, fieldNames); MATIO_ERROR;
-  
-  /* SECOND LIST ENTRY: Dimensions (int32 type) */
-  if (nbFields==2) /* Empty struct must have size 0x0 in Scilab */
+    piDims = (int *) MALLOC(matVariable->rank * sizeof(int));
+    for (i = 0 ; i < matVariable->rank ; ++i)
     {
-      matVariable->dims[0] = 0;
-      matVariable->dims[1] = 0;
+        piDims[i] = matVariable->dims[i];
     }
 
-  if(matVariable->rank==2) /* Two dimensions */
+    if (matVariable->rank == 2) /* Two dimensions */
     {
-      _SciErr = createMatrixOfInteger32InList(pvApiCtx, iVar, cell_addr, 2, 1, matVariable->rank, matVariable->dims); MATIO_ERROR;
+        sciErr = createMatrixOfInteger32InList(pvApiCtx, iVar, cell_addr, 2, 1, matVariable->rank, piDims);
+        if (sciErr.iErr)
+        {
+            printError(&sciErr, 0);
+            return 0;
+        }
     }
-  else /* 3 or more dimensions -> Scilab HyperMatrix */
+    else /* 3 or more dimensions -> Scilab HyperMatrix */
     {
-      type = I_INT32;
-      CreateHyperMatrixVariable(iVar, MATRIX_OF_VARIABLE_SIZE_INTEGER_DATATYPE, 
-				&type, &matVariable->rank, matVariable->dims, matVariable->data,
-				NULL, cell_addr, 2);
+        type = I_INT32;
+        CreateHyperMatrixVariable(pvApiCtx, iVar, MATRIX_OF_VARIABLE_SIZE_INTEGER_DATATYPE,
+                                  &type, &matVariable->rank, piDims, matVariable->data,
+                                  NULL, cell_addr, 2);
     }
 
-  /* ALL OTHER ENTRIES: Fields data */
-  prodDims = 1;
-  for (K=0; K<matVariable->rank; K++)
+    FREE(piDims);
+
+    /* ALL OTHER ENTRIES: Fields data */
+    prodDims = 1;
+    for (K = 0; K < matVariable->rank; K++)
     {
-      prodDims *= matVariable->dims[K];
+        prodDims *= matVariable->dims[K];
     }
 
-  allData = (matvar_t**) (matVariable->data);
+    allData = (matvar_t**) (matVariable->data);
 
-  if (prodDims == 1) /* Scalar struct */
+    if (prodDims == 1) /* Scalar struct */
     {
-      for (fieldIndex = 0; fieldIndex < nbFields - 2; fieldIndex++)
+        for (fieldIndex = 0; fieldIndex < nbFields - 2; fieldIndex++)
         {
-          /* Create list entry in the stack */
-          if (!CreateMatlabVariable(iVar, allData[fieldIndex], cell_addr, fieldIndex+3)) /* Could not Create Variable */
+            /* Create list entry in the stack */
+            if (!CreateMatlabVariable(pvApiCtx, iVar, allData[fieldIndex], cell_addr, fieldIndex + 3)) /* Could not Create Variable */
             {
-              if (allData[fieldIndex]->class_type != 0) /* class is 0 for not initialized fields */
+                if (allData[fieldIndex]->class_type != 0) /* class is 0 for not initialized fields */
                 {
-                  sciprint("Do not know how to read a variable of class %d.\n", allData[fieldIndex]->class_type);
+                    sciprint("Do not know how to read a variable of class %d.\n", allData[fieldIndex]->class_type);
                 }
             }
         }
     }
-  else
+    else
     {
-      for (fieldIndex = 0; fieldIndex < nbFields - 2; fieldIndex++)
+        for (fieldIndex = 0; fieldIndex < nbFields - 2; fieldIndex++)
         {
-	  _SciErr = createListInList(pvApiCtx, iVar, cell_addr, fieldIndex+3, prodDims, &cell_entry_addr); MATIO_ERROR;
-          
-          for (valueIndex = 0; valueIndex < prodDims; valueIndex++)
+            sciErr = createListInList(pvApiCtx, iVar, cell_addr, fieldIndex + 3, prodDims, &cell_entry_addr);
+            if (sciErr.iErr)
+            {
+                printError(&sciErr, 0);
+                return 0;
+            }
+
+            for (valueIndex = 0; valueIndex < prodDims; valueIndex++)
             {
-              /* Create list entry in the stack */
-              if (!CreateMatlabVariable(iVar, allData[(fieldIndex) + (nbFields-2)*valueIndex], cell_entry_addr, valueIndex+1)) /* Could not Create Variable */
+                /* Create list entry in the stack */
+                if (!CreateMatlabVariable(pvApiCtx, iVar, allData[(fieldIndex) + (nbFields - 2)*valueIndex], cell_entry_addr, valueIndex + 1)) /* Could not Create Variable */
                 {
-                  if (allData[(fieldIndex) + (nbFields-2)*valueIndex]->class_type != 0) /* class is 0 for not initialized fields */
+                    if (allData[(fieldIndex) + (nbFields - 2)*valueIndex]->class_type != 0) /* class is 0 for not initialized fields */
                     {
-                      sciprint("Do not know how to read a variable of class %d.\n", allData[(fieldIndex) + (nbFields-2)*valueIndex]->class_type);
+                        sciprint("Do not know how to read a variable of class %d.\n", allData[(fieldIndex) + (nbFields - 2)*valueIndex]->class_type);
                     }
                 }
             }
         }
     }
 
-  freeArrayOfString(fieldNames, nbFields);
+    freeArrayOfString(fieldNames, nbFields);
 
-  return TRUE;
+    return TRUE;
 }
 
diff --git a/modules/matio/src/c/GetCellVariable.c b/modules/matio/src/c/GetCellVariable.c
index cda3ac2..b45434e 100644
--- a/modules/matio/src/c/GetCellVariable.c
+++ b/modules/matio/src/c/GetCellVariable.c
@@ -1,12 +1,12 @@
 /*
  * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
- * Copyright (C) 2008 - INRIA - Vincent COUVERT 
+ * Copyright (C) 2008 - INRIA - Vincent COUVERT
  * Copyright (C) 2010 - DIGITEO - Yann COLLETTE
- * 
+ *
  * This file must be used under the terms of the CeCILL.
  * This source file is licensed as described in the file COPYING, which
  * you should have received as part of this distribution.  The terms
- * are also available at    
+ * are also available at
  * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
  *
  */
@@ -18,76 +18,100 @@
 #include "freeArrayOfString.h"
 #include "MALLOC.h"
 
-#define MATIO_ERROR if(_SciErr.iErr) \
-    {				     \
-      printError(&_SciErr, 0);	     \
-      return 0;			     \
-    }
-
-matvar_t *GetCellVariable(int iVar, const char *name, int matfile_version, int * parent, int item_position)
+matvar_t *GetCellVariable(void *pvApiCtx, int iVar, const char *name, int matfile_version, int * parent, int item_position)
 {
-  int nbFields = 0;
-  int K = 0;
-  int prodDims = 1;
-  matvar_t *dimensionsVariable = NULL;
-  matvar_t **cellEntries = NULL;
-  int * var_addr = NULL;
-  int var_type;
-  SciErr _SciErr;
+    int nbFields = 0;
+    int K = 0;
+    size_t *pszDims = NULL;
+    int prodDims = 1;
+    matvar_t *dimensionsVariable = NULL;
+    matvar_t **cellEntries = NULL;
+    int * var_addr = NULL;
+    int var_type;
+    SciErr sciErr;
 
-  if ((parent==NULL)&&(item_position==-1))
+    if ((parent == NULL) && (item_position == -1))
     {
-      _SciErr = getVarAddressFromPosition(pvApiCtx, iVar, &var_addr); MATIO_ERROR;
+        sciErr = getVarAddressFromPosition(pvApiCtx, iVar, &var_addr);
+        if (sciErr.iErr)
+        {
+            printError(&sciErr, 0);
+            return 0;
+        }
     }
-  else if ((parent!=NULL)&&(item_position==-1))
+    else if ((parent != NULL) && (item_position == -1))
     {
-      var_addr = parent;
+        var_addr = parent;
     }
-  else
+    else
     {
-      _SciErr = getListItemAddress(pvApiCtx, parent, item_position, &var_addr); MATIO_ERROR;
+        sciErr = getListItemAddress(pvApiCtx, parent, item_position, &var_addr);
+        if (sciErr.iErr)
+        {
+            printError(&sciErr, 0);
+            return 0;
+        }
     }
 
-  _SciErr = getVarType(pvApiCtx, var_addr, &var_type); MATIO_ERROR;
-  if (var_type != sci_mlist)
+    sciErr = getVarType(pvApiCtx, var_addr, &var_type);
+    if (sciErr.iErr)
     {
-      Scierror(999, _("%s: Wrong type for first input argument: Mlist expected.\n"), "GetCellVariable");
-      return FALSE;
+        printError(&sciErr, 0);
+        return 0;
+    }
+    if (var_type != sci_mlist)
+    {
+        Scierror(999, _("%s: Wrong type for first input argument: Mlist expected.\n"), "GetCellVariable");
+        return FALSE;
+    }
+
+    sciErr = getListItemNumber(pvApiCtx, var_addr, &nbFields);
+    if (sciErr.iErr)
+    {
+        printError(&sciErr, 0);
+        return 0;
     }
 
-  _SciErr = getListItemNumber(pvApiCtx, var_addr, &nbFields); MATIO_ERROR;
+    /* FIRST LIST ENTRY: fieldnames --> NO NEED TO BE READ */
 
-  /* FIRST LIST ENTRY: fieldnames --> NO NEED TO BE READ */
-  
-  /* SECOND LIST ENTRY: dimensions */
-  dimensionsVariable = GetMatlabVariable(iVar, "data", 0, var_addr, 2);
+    /* SECOND LIST ENTRY: dimensions */
+    dimensionsVariable = GetMatlabVariable(pvApiCtx, iVar, "data", 0, var_addr, 2);
 
-  /* OTHERS LIST ENTRIES: ALL CELL VALUES */
+    /* OTHERS LIST ENTRIES: ALL CELL VALUES */
+
+    pszDims = (size_t*) MALLOC(dimensionsVariable->rank * sizeof(size_t));
+    if (pszDims == NULL)
+    {
+        Scierror(999, _("%s: No more memory.\n"), "GetCellVariable");
+        return NULL;
+    }
 
-  /* Total number of entries */
-  for (K=0; K<dimensionsVariable->rank; K++)
+    /* Total number of entries */
+    for (K = 0; K < dimensionsVariable->rank; K++)
     {
-      prodDims *= ((int *)dimensionsVariable->data)[K];
+        prodDims *= ((int*)dimensionsVariable->data)[K];
+        pszDims[K] = ((int*)dimensionsVariable->data)[K];
     }
 
-  if ((cellEntries = (matvar_t **) MALLOC (sizeof(matvar_t*)*prodDims)) == NULL)
+    cellEntries = (matvar_t **) MALLOC(sizeof(matvar_t*) * prodDims);
+    if (cellEntries == NULL)
     {
-      Scierror(999, _("%s: No more memory.\n"), "GetCellVariable");
-      return NULL;
+        Scierror(999, _("%s: No more memory.\n"), "GetCellVariable");
+        return NULL;
     }
 
-  if (prodDims == 1) /* Scalar cell array */
+    if (prodDims == 1) /* Scalar cell array */
     {
-      cellEntries[0] = GetMatlabVariable(iVar ,"data", matfile_version, var_addr, 3);
+        cellEntries[0] = GetMatlabVariable(pvApiCtx, iVar , "data", matfile_version, var_addr, 3);
     }
-  else
+    else
     {
-      /* Read all entries */
-      for (K=0; K<prodDims; K++)
+        /* Read all entries */
+        for (K = 0; K < prodDims; K++)
         {
-          cellEntries[K] = GetMatlabVariable(iVar ,"data", matfile_version, var_addr, 3+K);
+            cellEntries[K] = GetMatlabVariable(pvApiCtx, iVar , "data", matfile_version, var_addr, 3 + K);
         }
     }
 
-  return Mat_VarCreate(name, MAT_C_CELL, MAT_T_CELL, dimensionsVariable->rank, dimensionsVariable->data, cellEntries, 0);
+    return Mat_VarCreate(name, MAT_C_CELL, MAT_T_CELL, dimensionsVariable->rank, pszDims, cellEntries, 0);
 }
diff --git a/modules/matio/src/c/GetCharVariable.c b/modules/matio/src/c/GetCharVariable.c
index a8af5f6..b2abce2 100644
--- a/modules/matio/src/c/GetCharVariable.c
+++ b/modules/matio/src/c/GetCharVariable.c
@@ -1,13 +1,13 @@
 /*
  * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
- * Copyright (C) 2008 - INRIA - Vincent COUVERT 
+ * Copyright (C) 2008 - INRIA - Vincent COUVERT
  * Copyright (C) 2010 - DIGITEO - Yann COLLETTE
- * Copyright (C) 2010 - DIGITEO - Vincent COUVERT 
- * 
+ * Copyright (C) 2010 - DIGITEO - Vincent COUVERT
+ *
  * This file must be used under the terms of the CeCILL.
  * This source file is licensed as described in the file COPYING, which
  * you should have received as part of this distribution.  The terms
- * are also available at    
+ * are also available at
  * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
  *
  */
@@ -22,11 +22,11 @@
 #include "MALLOC.h"
 #include "localization.h"
 
-matvar_t *GetCharVariable(int iVar, const char *name, int * parent, int item_position)
+matvar_t *GetCharVariable(void *pvApiCtx, int iVar, const char *name, int * parent, int item_position)
 {
-    char * dataAdr = NULL;
     int rank = 0, i = 0, j = 0;
-    int *dims = NULL;
+    size_t *pszDims = NULL;
+    int *piDims = NULL;
     matvar_t *createdVar = NULL;
     int* piLen = NULL;
     char** pstData = NULL;
@@ -37,16 +37,16 @@ matvar_t *GetCharVariable(int iVar, const char *name, int * parent, int item_pos
     int saveDim = 0; /* Used to save old dimension before restoring it */
     SciErr sciErr;
 
-    if (parent==NULL)
+    if (parent == NULL)
     {
         sciErr = getVarAddressFromPosition(pvApiCtx, iVar, &piAddr);
-        if(sciErr.iErr)
+        if (sciErr.iErr)
         {
             printError(&sciErr, 0);
             return NULL;
         }
         sciErr = getVarType(pvApiCtx, piAddr, &var_type);
-        if(sciErr.iErr)
+        if (sciErr.iErr)
         {
             printError(&sciErr, 0);
             return NULL;
@@ -55,160 +55,170 @@ matvar_t *GetCharVariable(int iVar, const char *name, int * parent, int item_pos
     else
     {
         sciErr = getListItemAddress(pvApiCtx, parent, item_position, &item_addr);
-        if(sciErr.iErr)
+        if (sciErr.iErr)
         {
             printError(&sciErr, 0);
             return NULL;
         }
         sciErr = getVarType(pvApiCtx, item_addr, &var_type);
-        if(sciErr.iErr)
+        if (sciErr.iErr)
         {
             printError(&sciErr, 0);
             return NULL;
         }
     }
 
-    if(var_type == sci_strings) /* 2-D array */
+    if (var_type == sci_strings) /* 2-D array */
     {
         rank = 2;
-        if ((dims = (int*)MALLOC(sizeof(int) * rank)) == NULL)
+        piDims = (int*)MALLOC(sizeof(int) * rank);
+        if (piDims == NULL)
         {
             Scierror(999, _("%s: No more memory.\n"), "GetCharVariable");
             return NULL;
         }
 
-        if (parent==NULL)
+        if (parent == NULL)
         {
             // First call to retrieve dimensions
-            sciErr = getMatrixOfString(pvApiCtx, piAddr, &dims[0], &dims[1], NULL, NULL);
-            if(sciErr.iErr)
+            sciErr = getMatrixOfString(pvApiCtx, piAddr, &piDims[0], &piDims[1], NULL, NULL);
+            if (sciErr.iErr)
             {
                 printError(&sciErr, 0);
                 return 0;
             }
-            piLen = (int *)MALLOC(dims[0] * dims[1] * sizeof(int));
+            piLen = (int *)MALLOC(piDims[0] * piDims[1] * sizeof(int));
             // Second call to retrieve length of each string
-            sciErr = getMatrixOfString(pvApiCtx, piAddr, &dims[0], &dims[1], piLen, NULL);
-            if(sciErr.iErr)
+            sciErr = getMatrixOfString(pvApiCtx, piAddr, &piDims[0], &piDims[1], piLen, NULL);
+            if (sciErr.iErr)
             {
                 printError(&sciErr, 0);
                 return 0;
             }
-            pstData = (char**)MALLOC(sizeof(char*) * dims[0] * dims[1]);
-            for(i = 0 ; i < dims[0] * dims[1] ; i++)
+            pstData = (char**)MALLOC(sizeof(char*) * piDims[0] * piDims[1]);
+            for (i = 0 ; i < piDims[0] * piDims[1] ; i++)
             {
                 pstData[i] = (char*)MALLOC(sizeof(char) * (piLen[i] + 1)); //+ 1 for null termination
             }
             // Third call to retrieve data
-            sciErr = getMatrixOfString(pvApiCtx, piAddr, &dims[0], &dims[1], piLen, pstData);
-            if(sciErr.iErr)
+            sciErr = getMatrixOfString(pvApiCtx, piAddr, &piDims[0], &piDims[1], piLen, pstData);
+            if (sciErr.iErr)
             {
                 printError(&sciErr, 0);
                 return 0;
             }
-            dataAdr = strdup(pstData[0]);
         }
         else
         {
             // First call to retrieve dimensions
-            sciErr  = getMatrixOfStringInList(pvApiCtx, parent, item_position, &dims[0], &dims[1], NULL, NULL);
-            if(sciErr.iErr)
+            sciErr  = getMatrixOfStringInList(pvApiCtx, parent, item_position, &piDims[0], &piDims[1], NULL, NULL);
+            if (sciErr.iErr)
             {
                 printError(&sciErr, 0);
                 return NULL;
             }
-            piLen = (int *)MALLOC(dims[0] * dims[1] * sizeof(int));
+            piLen = (int *)MALLOC(piDims[0] * piDims[1] * sizeof(int));
             // Second call to retrieve length of each string
-            sciErr = getMatrixOfStringInList(pvApiCtx, parent, item_position, &dims[0], &dims[1], piLen, NULL);
-            if(sciErr.iErr)
+            sciErr = getMatrixOfStringInList(pvApiCtx, parent, item_position, &piDims[0], &piDims[1], piLen, NULL);
+            if (sciErr.iErr)
             {
                 printError(&sciErr, 0);
                 return NULL;
             }
-            pstData = (char**)MALLOC(sizeof(char*) * dims[0] * dims[1]);
-            for(i = 0 ; i < dims[0] * dims[1] ; i++)
+            pstData = (char**)MALLOC(sizeof(char*) * piDims[0] * piDims[1]);
+            for (i = 0 ; i < piDims[0] * piDims[1] ; i++)
             {
                 pstData[i] = (char*)MALLOC(sizeof(char) * (piLen[i] + 1)); //+ 1 for null termination
             }
             // Third call to retrieve data
-            sciErr = getMatrixOfStringInList(pvApiCtx, parent, item_position, &dims[0], &dims[1], piLen, pstData);
-            if(sciErr.iErr)
+            sciErr = getMatrixOfStringInList(pvApiCtx, parent, item_position, &piDims[0], &piDims[1], piLen, pstData);
+            if (sciErr.iErr)
             {
                 printError(&sciErr, 0);
                 return NULL;
             }
-            dataAdr = strdup(pstData[0]);
         }
 
-        if (dims[0] == 0) /* Empty character string */
+        pszDims = (size_t*) MALLOC(rank * sizeof(size_t));
+        if (pszDims == NULL)
+        {
+            Scierror(999, _("%s: No more memory.\n"), "GetCharVariable");
+            return NULL;
+        }
+        for (i = 0; i < rank; i++)
+        {
+            pszDims[i] = piDims[i];
+        }
+
+        if (piDims[0] == 0) /* Empty character string */
         {
-            createdVar = Mat_VarCreate(name, MAT_C_CHAR, MAT_T_UINT8, rank, dims, pstData[0], 0);
+            createdVar = Mat_VarCreate(name, MAT_C_CHAR, MAT_T_UINT8, rank, pszDims, pstData[0], 0);
         }
-        else if (dims[0]*dims[1] == 1) /* Scalar character string */
+        else if (piDims[0]*piDims[1] == 1) /* Scalar character string */
         {
-            saveDim = dims[1];
-            dims[1] = piLen[0];
-            createdVar = Mat_VarCreate(name, MAT_C_CHAR, MAT_T_UINT8, rank, dims, pstData[0], 0);
-            dims[1] = saveDim;
+            saveDim = piDims[1];
+            pszDims[1] = piLen[0];
+            createdVar = Mat_VarCreate(name, MAT_C_CHAR, MAT_T_UINT8, rank, pszDims, pstData[0], 0);
+            pszDims[1] = saveDim;
         }
         else /* More than one character string -> save as a Cell */
         {
-            if (dims[0] == 1)
+            if (piDims[0] == 1)
             {
                 /* TODO: Should be saved as a cell */
                 Scierror(999, _("%s: Row array of strings saving is not implemented.\n"), "GetCharVariable");
-                freeArrayOfString(pstData, dims[0]*dims[1]);
-                FREE(dims);
-                FREE(dataAdr);
+                freeArrayOfString(pstData, piDims[0]*piDims[1]);
+                FREE(pszDims);
+                FREE(piDims);
                 FREE(piLen);
                 return NULL;
             }
-            else if (dims[1] == 1)
+            else if (piDims[1] == 1)
             {
                 /* Check that all strings have the same length */
-                for (i = 0 ; i < dims[0] ; i++)
+                for (i = 0 ; i < piDims[0] ; i++)
                 {
                     if (piLen[0] != piLen[i])
                     {
                         /* TODO: Should be saved as a cell */
                         Scierror(999, _("%s: Column array of strings with different lengths saving is not implemented.\n"), "GetCharVariable");
-                        freeArrayOfString(pstData, dims[0]*dims[1]);
-                        FREE(dims);
-                        FREE(dataAdr);
+                        freeArrayOfString(pstData, piDims[0]*piDims[1]);
+                        FREE(pszDims);
+                        FREE(piDims);
                         FREE(piLen);
                         return NULL;
                     }
                 }
 
                 /* Reorder characters */
-                pstMatData = (char*)MALLOC(sizeof(char) * dims[0] * piLen[0]);
-                for (i = 0 ; i < dims[0] ; i++)
+                pstMatData = (char*)MALLOC(sizeof(char) * piDims[0] * piLen[0]);
+                for (i = 0 ; i < piDims[0] ; i++)
                 {
                     for (j = 0 ; j < piLen[0] ; j++)
                     {
-                        pstMatData[i+j*dims[0]] = pstData[i][j];
+                        pstMatData[i + j * piDims[0]] = pstData[i][j];
                     }
                 }
 
                 /* Save the variable */
-                saveDim = dims[1];
-                dims[1] = piLen[0];
-                createdVar = Mat_VarCreate(name, MAT_C_CHAR, MAT_T_UINT8, rank, dims, pstMatData, 0);
-                dims[1] = saveDim;
+                saveDim = piDims[1];
+                pszDims[1] = piLen[0];
+                createdVar = Mat_VarCreate(name, MAT_C_CHAR, MAT_T_UINT8, rank, pszDims, pstMatData, 0);
+                pszDims[1] = saveDim;
 
-                freeArrayOfString(pstData, dims[0]*dims[1]); /* FREE now because dimensions are changed just below */
+                freeArrayOfString(pstData, piDims[0]*piDims[1]); /* FREE now because dimensions are changed just below */
                 FREE(pstMatData);
-                FREE(dims);
-                FREE(dataAdr);
+                FREE(pszDims);
+                FREE(piDims);
                 FREE(piLen);
             }
             else
             {
                 /* TODO: Should be saved as a cell */
                 Scierror(999, _("%s: 2D array of strings saving is not implemented.\n"), "GetCharVariable");
-                freeArrayOfString(pstData, dims[0]*dims[1]);
-                FREE(dims);
-                FREE(dataAdr);
+                freeArrayOfString(pstData, piDims[0]*piDims[1]);
+                FREE(pszDims);
+                FREE(piDims);
                 FREE(piLen);
                 return NULL;
             }
@@ -217,9 +227,9 @@ matvar_t *GetCharVariable(int iVar, const char *name, int * parent, int item_pos
     else
     {
         Scierror(999, _("%s: Wrong type for first input argument: String matrix expected.\n"), "GetCharVariable");
-        freeArrayOfString(pstData, dims[0]*dims[1]);
-        FREE(dims);
-        FREE(dataAdr);
+        freeArrayOfString(pstData, piDims[0]*piDims[1]);
+        FREE(pszDims);
+        FREE(piDims);
         FREE(piLen);
         return NULL;
     }
diff --git a/modules/matio/src/c/GetDoubleVariable.c b/modules/matio/src/c/GetDoubleVariable.c
index 2fdc009..c0baa97 100644
--- a/modules/matio/src/c/GetDoubleVariable.c
+++ b/modules/matio/src/c/GetDoubleVariable.c
@@ -1,12 +1,12 @@
 /*
  * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
- * Copyright (C) 2008 - INRIA - Vincent COUVERT 
+ * Copyright (C) 2008 - INRIA - Vincent COUVERT
  * Copyright (C) 2010 - DIGITEO - Yann COLLETTE
- * 
+ *
  * This file must be used under the terms of the CeCILL.
  * This source file is licensed as described in the file COPYING, which
  * you should have received as part of this distribution.  The terms
- * are also available at    
+ * are also available at
  * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
  *
  */
@@ -15,97 +15,143 @@
 #include "sci_types.h"
 #include "api_scilab.h"
 
-#define MATIO_ERROR if(_SciErr.iErr) \
-    {				     \
-      printError(&_SciErr, 0);	     \
-      return 0;			     \
-    }
-
-matvar_t * GetDoubleVariable(int iVar, const char* name, int matfile_version, int * parent, int item_position)
+matvar_t * GetDoubleVariable(void *pvApiCtx, int iVar, const char* name, int matfile_version, int * parent, int item_position)
 {
-  double * realDataAdr = NULL, * complexDataAdr = NULL;
-  int rank = 0;
-  int *dims = NULL;
-  int isComplex = 0;
-  struct ComplexSplit mat5ComplexData;
-  matvar_t *createdVar = NULL;
-  int * var_addr = NULL;
-  int * item_addr = NULL;
-  int var_type;
-  SciErr _SciErr;
+    double * realDataAdr = NULL, * complexDataAdr = NULL;
+    int i = 0;
+    int rank = 0;
+    int *piDims = NULL;
+    size_t *pszDims = NULL;
+    int isComplex = 0;
+    struct mat_complex_split_t mat5ComplexData;
+    matvar_t *createdVar = NULL;
+    int * var_addr = NULL;
+    int * item_addr = NULL;
+    int var_type;
+    SciErr sciErr;
 
-  if (parent==NULL)
+    if (parent == NULL)
     {
-      _SciErr = getVarAddressFromPosition(pvApiCtx, iVar, &var_addr); MATIO_ERROR;
-      _SciErr = getVarType(pvApiCtx, var_addr, &var_type); MATIO_ERROR;
-      isComplex = isVarComplex(pvApiCtx, var_addr);
+        sciErr = getVarAddressFromPosition(pvApiCtx, iVar, &var_addr);
+        if (sciErr.iErr)
+        {
+            printError(&sciErr, 0);
+            return 0;
+        }
+        sciErr = getVarType(pvApiCtx, var_addr, &var_type);
+        if (sciErr.iErr)
+        {
+            printError(&sciErr, 0);
+            return 0;
+        }
+        isComplex = isVarComplex(pvApiCtx, var_addr);
     }
-  else
+    else
     {
-      _SciErr = getListItemAddress(pvApiCtx, parent, item_position, &item_addr); MATIO_ERROR;
-      _SciErr = getVarType(pvApiCtx, item_addr, &var_type); MATIO_ERROR;
-      isComplex = isVarComplex(pvApiCtx, item_addr);
+        sciErr = getListItemAddress(pvApiCtx, parent, item_position, &item_addr);
+        if (sciErr.iErr)
+        {
+            printError(&sciErr, 0);
+            return 0;
+        }
+        sciErr = getVarType(pvApiCtx, item_addr, &var_type);
+        if (sciErr.iErr)
+        {
+            printError(&sciErr, 0);
+            return 0;
+        }
+        isComplex = isVarComplex(pvApiCtx, item_addr);
     }
 
-  if(var_type == sci_matrix) /* 2-D array */
+    if (var_type == sci_matrix) /* 2-D array */
     {
-      rank = 2;
-      if ((dims = (int*)MALLOC(sizeof(int)*rank)) == NULL)
+        rank = 2;
+        if ((piDims = (int*)MALLOC(sizeof(int) * rank)) == NULL)
         {
-          Scierror(999, _("%s: No more memory.\n"), "GetDoubleVariable");
-          return NULL;
+            Scierror(999, _("%s: No more memory.\n"), "GetDoubleVariable");
+            return NULL;
+        }
+        if ((pszDims = (size_t*)MALLOC(sizeof(size_t) * rank)) == NULL)
+        {
+            Scierror(999, _("%s: No more memory.\n"), "GetDoubleVariable");
+            return NULL;
         }
 
+        if (isComplex)
+        {
+            if (parent == NULL)
+            {
+                sciErr = getComplexMatrixOfDouble(pvApiCtx, var_addr, &piDims[0], &piDims[1], &realDataAdr, &complexDataAdr);
+                if (sciErr.iErr)
+                {
+                    printError(&sciErr, 0);
+                    return 0;
+                }
+            }
+            else
+            {
+                sciErr = getComplexMatrixOfDoubleInList(pvApiCtx, parent, item_position, &piDims[0], &piDims[1],
+                                                        &realDataAdr, &complexDataAdr);
+                if (sciErr.iErr)
+                {
+                    printError(&sciErr, 0);
+                    return 0;
+                }
+            }
+        }
+        else
+        {
+            if (parent == NULL)
+            {
+                sciErr = getMatrixOfDouble(pvApiCtx, var_addr, &piDims[0], &piDims[1], &realDataAdr);
+                if (sciErr.iErr)
+                {
+                    printError(&sciErr, 0);
+                    return 0;
+                }
+            }
+            else
+            {
+                sciErr = getMatrixOfDoubleInList(pvApiCtx, parent, item_position, &piDims[0], &piDims[1], &realDataAdr);
+                if (sciErr.iErr)
+                {
+                    printError(&sciErr, 0);
+                    return 0;
+                }
+            }
+        }
 
-      if (isComplex)
-	{
-	  if (parent==NULL)
-	    {
-	      _SciErr = getComplexMatrixOfDouble(pvApiCtx, var_addr, &dims[0], &dims[1], &realDataAdr, &complexDataAdr); MATIO_ERROR;
-	    }
-	  else
-	    {
-	      _SciErr = getComplexMatrixOfDoubleInList(pvApiCtx, parent, item_position, &dims[0], &dims[1], 
-						       &realDataAdr, &complexDataAdr); MATIO_ERROR;
-	    }
-	}
-      else
-	{
-	  if (parent==NULL)
-	    {
-	      _SciErr = getMatrixOfDouble(pvApiCtx, var_addr, &dims[0], &dims[1], &realDataAdr); MATIO_ERROR;
-	    }
-	  else
-	    {
-	      _SciErr = getMatrixOfDoubleInList(pvApiCtx, parent, item_position, &dims[0], &dims[1], &realDataAdr); MATIO_ERROR;
-	    }
-	}
+        for (i = 0; i < rank; i++)
+        {
+            pszDims[i] = piDims[i];
+        }
 
-      if (isComplex==0)
+        if (isComplex == 0)
         {
-          createdVar = Mat_VarCreate(name, MAT_C_DOUBLE, MAT_T_DOUBLE, rank, dims, realDataAdr, 0);
+            createdVar = Mat_VarCreate(name, MAT_C_DOUBLE, MAT_T_DOUBLE, rank, pszDims, realDataAdr, 0);
         }
-      else
+        else
         {
-          if(matfile_version==MAT_FT_MAT4) /* MATLAB4: data is a table of value */
+            if (matfile_version == MAT_FT_MAT4) /* MATLAB4: data is a table of value */
             {
-              createdVar = Mat_VarCreate(name, MAT_C_DOUBLE, MAT_T_DOUBLE, rank, dims, realDataAdr, MAT_F_COMPLEX);
+                createdVar = Mat_VarCreate(name, MAT_C_DOUBLE, MAT_T_DOUBLE, rank, pszDims, realDataAdr, MAT_F_COMPLEX);
             }
-          else /* MATLAB5 file: data is a ComplexSplit */
+            else /* MATLAB5 file: data is a mat_complex_split_t */
             {
-              mat5ComplexData.Re = realDataAdr;
-              mat5ComplexData.Im = complexDataAdr;
-              createdVar = Mat_VarCreate(name, MAT_C_DOUBLE, MAT_T_DOUBLE, rank, dims, &mat5ComplexData, MAT_F_COMPLEX);
+                mat5ComplexData.Re = realDataAdr;
+                mat5ComplexData.Im = complexDataAdr;
+                createdVar = Mat_VarCreate(name, MAT_C_DOUBLE, MAT_T_DOUBLE, rank, pszDims, &mat5ComplexData, MAT_F_COMPLEX);
             }
-          createdVar->isComplex = 1;
+            createdVar->isComplex = 1;
         }
     }
-  else
+    else
     {
-      Scierror(999, _("%s: Wrong type for first input argument: Double matrix expected.\n"), "GetDoubleVariable");
+        Scierror(999, _("%s: Wrong type for first input argument: Double matrix expected.\n"), "GetDoubleVariable");
     }
 
-  FREE(dims);
+    FREE(piDims);
+    FREE(pszDims);
 
-  return createdVar;
+    return createdVar;
 }
diff --git a/modules/matio/src/c/GetIntegerVariable.c b/modules/matio/src/c/GetIntegerVariable.c
index 909e6ed..3a894de 100644
--- a/modules/matio/src/c/GetIntegerVariable.c
+++ b/modules/matio/src/c/GetIntegerVariable.c
@@ -1,12 +1,12 @@
 /*
  * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
- * Copyright (C) 2008 - INRIA - Vincent COUVERT 
+ * Copyright (C) 2008 - INRIA - Vincent COUVERT
  * Copyright (C) 2010 - DIGITEO - Yann COLLETTE
- * 
+ *
  * This file must be used under the terms of the CeCILL.
  * This source file is licensed as described in the file COPYING, which
  * you should have received as part of this distribution.  The terms
- * are also available at    
+ * are also available at
  * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
  *
  */
@@ -15,141 +15,199 @@
 #include "sci_types.h"
 #include "api_scilab.h"
 
-#define MATIO_ERROR if(_SciErr.iErr) \
-    {				     \
-      printError(&_SciErr, 0);	     \
-      return 0;			     \
-    }
-
-matvar_t *GetIntegerVariable(int iVar, const char *name, int * parent, int item_position)
+matvar_t *GetIntegerVariable(void *pvApiCtx, int iVar, const char *name, int * parent, int item_position)
 {
-  int rank = 0;
-  int *dims = NULL;
-  matvar_t *createdVar = NULL;
-  int * var_addr = NULL;
-  int var_type;
-  int integerType;
-  SciErr _SciErr;
-  char * tmp_int8 = NULL;
-  short * tmp_int16 = NULL;
-  int * tmp_int32 = NULL;
-  int * item_addr = NULL;
-  unsigned char * tmp_uint8 = NULL;
-  unsigned short * tmp_uint16 = NULL;
-  unsigned int * tmp_uint32 = NULL;
+    int rank = 0;
+    size_t *pszDims = NULL;
+    int *piDims = NULL;
+    matvar_t *createdVar = NULL;
+    int * var_addr = NULL;
+    int i;
+    int var_type;
+    int integerType;
+    SciErr sciErr;
+    char * tmp_int8 = NULL;
+    short * tmp_int16 = NULL;
+    int * tmp_int32 = NULL;
+    int * item_addr = NULL;
+    unsigned char * tmp_uint8 = NULL;
+    unsigned short * tmp_uint16 = NULL;
+    unsigned int * tmp_uint32 = NULL;
 #ifdef __SCILAB_INT64__
-  long long * tmp_int64 = NULL;
-  unsigned long long * tmp_uint64 = NULL;
+    long long * tmp_int64 = NULL;
+    unsigned long long * tmp_uint64 = NULL;
 #endif
 
-  if (parent==NULL)
+    if (parent == NULL)
     {
-      _SciErr = getVarAddressFromPosition(pvApiCtx, iVar, &var_addr); MATIO_ERROR;
-      _SciErr = getVarType(pvApiCtx, var_addr, &var_type); MATIO_ERROR;
+        sciErr = getVarAddressFromPosition(pvApiCtx, iVar, &var_addr);
+        if (sciErr.iErr)
+        {
+            printError(&sciErr, 0);
+            return 0;
+        }
+        sciErr = getVarType(pvApiCtx, var_addr, &var_type);
+        if (sciErr.iErr)
+        {
+            printError(&sciErr, 0);
+            return 0;
+        }
     }
-  else
+    else
     {
-      _SciErr = getListItemAddress(pvApiCtx, parent, item_position, &item_addr); MATIO_ERROR;
-      _SciErr = getVarType(pvApiCtx, item_addr, &var_type); MATIO_ERROR;
+        sciErr = getListItemAddress(pvApiCtx, parent, item_position, &item_addr);
+        if (sciErr.iErr)
+        {
+            printError(&sciErr, 0);
+            return 0;
+        }
+        sciErr = getVarType(pvApiCtx, item_addr, &var_type);
+        if (sciErr.iErr)
+        {
+            printError(&sciErr, 0);
+            return 0;
+        }
     }
 
-  if (var_type == sci_ints) /* 2-D array */
+    if (var_type == sci_ints) /* 2-D array */
     {
-      rank = 2;
-      if ((dims = (int*)MALLOC(sizeof(int)*rank)) == NULL)
+        rank = 2;
+        if ((pszDims = (size_t*)MALLOC(sizeof(size_t) * rank)) == NULL)
         {
-          Scierror(999, _("%s: No more memory.\n"), "GetIntegerVariable");
-          return NULL;
+            Scierror(999, _("%s: No more memory.\n"), "GetIntegerVariable");
+            return NULL;
+        }
+        if ((piDims = (int*)MALLOC(sizeof(int) * rank)) == NULL)
+        {
+            Scierror(999, _("%s: No more memory.\n"), "GetIntegerVariable");
+            return NULL;
         }
 
-      if (parent==NULL)
-	{
-	  _SciErr = getMatrixOfIntegerPrecision(pvApiCtx, var_addr, &integerType);
-	}
-      else
-	{
-	  _SciErr = getMatrixOfIntegerPrecision(pvApiCtx, item_addr, &integerType);
-	}
+        if (parent == NULL)
+        {
+            sciErr = getMatrixOfIntegerPrecision(pvApiCtx, var_addr, &integerType);
+        }
+        else
+        {
+            sciErr = getMatrixOfIntegerPrecision(pvApiCtx, item_addr, &integerType);
+        }
 
-      switch(integerType)
+        switch (integerType)
         {
-        case SCI_INT8: /* INT8 */
-	  if (parent==NULL)
-	    {
-	      _SciErr = getMatrixOfInteger8(pvApiCtx, var_addr, &dims[0], &dims[1], &tmp_int8);
-	    }
-	  else
-	    {
-	      _SciErr = getMatrixOfInteger8InList(pvApiCtx, parent, item_position, &dims[0], &dims[1], &tmp_int8);
-	    }
-          createdVar = Mat_VarCreate(name, MAT_C_INT8, MAT_T_INT8, rank, dims, tmp_int8, 0);
-          break;
-        case SCI_INT16: /* INT16 */
-	  if (parent==NULL)
-	    {
-	      _SciErr = getMatrixOfInteger16(pvApiCtx, var_addr, &dims[0], &dims[1], &tmp_int16);
-	    }
-	  else
-	    {
-	      _SciErr = getMatrixOfInteger16InList(pvApiCtx, parent, item_position, &dims[0], &dims[1], &tmp_int16);
-	    }
-          createdVar = Mat_VarCreate(name, MAT_C_INT16, MAT_T_INT16, rank, dims, tmp_int16, 0);
-          break;
-	case SCI_INT32: /* INT32 */
-	  if (parent==NULL)
-	    {
-	      _SciErr = getMatrixOfInteger32(pvApiCtx, var_addr, &dims[0], &dims[1], &tmp_int32);
-	    }
-	  else
-	    {
-	      _SciErr = getMatrixOfInteger32InList(pvApiCtx, parent, item_position, &dims[0], &dims[1], &tmp_int32);
-	    }
-	  createdVar = Mat_VarCreate(name, MAT_C_INT32, MAT_T_INT32, rank, dims, tmp_int32, 0);
-	  break;
-        case SCI_UINT8: /* UINT8 */
-	  if (parent==NULL)
-	    {
-	      _SciErr = getMatrixOfUnsignedInteger8(pvApiCtx, var_addr, &dims[0], &dims[1], &tmp_uint8);
-	    }
-	  else
-	    {
-	      _SciErr = getMatrixOfUnsignedInteger8InList(pvApiCtx, parent, item_position, &dims[0], &dims[1], &tmp_uint8);
-	    }
-          createdVar = Mat_VarCreate(name, MAT_C_UINT8, MAT_T_UINT8, rank, dims, tmp_uint8, 0);
-          break;
-        case SCI_UINT16: /* UINT16 */
-	  if (parent==NULL)
-	    {
-	      _SciErr = getMatrixOfUnsignedInteger16(pvApiCtx, var_addr, &dims[0], &dims[1], &tmp_uint16);
-	    }
-	  else
-	    {
-	      _SciErr = getMatrixOfUnsignedInteger16InList(pvApiCtx, parent, item_position, &dims[0], &dims[1], &tmp_uint16);
-	    }
-          createdVar = Mat_VarCreate(name, MAT_C_UINT16, MAT_T_UINT16, rank, dims, tmp_uint16, 0);
-	  break;
-	case SCI_UINT32: /* UINT32 */
-	  if (parent==NULL)
-	    {
-	      _SciErr = getMatrixOfUnsignedInteger32(pvApiCtx, var_addr, &dims[0], &dims[1], &tmp_uint32);
-	    }
-	  else
-	    {
-	      _SciErr = getMatrixOfUnsignedInteger32InList(pvApiCtx, parent, item_position, &dims[0], &dims[1], &tmp_uint32);
-	    }
-	  createdVar = Mat_VarCreate(name, MAT_C_UINT32, MAT_T_UINT32, rank, dims, tmp_uint32, 0);
-	  break;
-        default:
-          createdVar = NULL;
-          break;
+            case SCI_INT8: /* INT8 */
+                if (parent == NULL)
+                {
+                    sciErr = getMatrixOfInteger8(pvApiCtx, var_addr, &piDims[0], &piDims[1], &tmp_int8);
+                }
+                else
+                {
+                    sciErr = getMatrixOfInteger8InList(pvApiCtx, parent, item_position, &piDims[0], &piDims[1], &tmp_int8);
+                }
+
+                for (i = 0; i < rank; i++)
+                {
+                    pszDims[i] = piDims[i];
+                }
+
+                createdVar = Mat_VarCreate(name, MAT_C_INT8, MAT_T_INT8, rank, pszDims, tmp_int8, 0);
+                break;
+            case SCI_INT16: /* INT16 */
+                if (parent == NULL)
+                {
+                    sciErr = getMatrixOfInteger16(pvApiCtx, var_addr, &piDims[0], &piDims[1], &tmp_int16);
+                }
+                else
+                {
+                    sciErr = getMatrixOfInteger16InList(pvApiCtx, parent, item_position, &piDims[0], &piDims[1], &tmp_int16);
+                }
+
+                for (i = 0; i < rank; i++)
+                {
+                    pszDims[i] = piDims[i];
+                }
+
+                createdVar = Mat_VarCreate(name, MAT_C_INT16, MAT_T_INT16, rank, pszDims, tmp_int16, 0);
+                break;
+            case SCI_INT32: /* INT32 */
+                if (parent == NULL)
+                {
+                    sciErr = getMatrixOfInteger32(pvApiCtx, var_addr, &piDims[0], &piDims[1], &tmp_int32);
+                }
+                else
+                {
+                    sciErr = getMatrixOfInteger32InList(pvApiCtx, parent, item_position, &piDims[0], &piDims[1], &tmp_int32);
+                }
+
+                for (i = 0; i < rank; i++)
+                {
+                    pszDims[i] = piDims[i];
+                }
+
+                createdVar = Mat_VarCreate(name, MAT_C_INT32, MAT_T_INT32, rank, pszDims, tmp_int32, 0);
+                break;
+            case SCI_UINT8: /* UINT8 */
+                if (parent == NULL)
+                {
+                    sciErr = getMatrixOfUnsignedInteger8(pvApiCtx, var_addr, &piDims[0], &piDims[1], &tmp_uint8);
+                }
+                else
+                {
+                    sciErr = getMatrixOfUnsignedInteger8InList(pvApiCtx, parent, item_position, &piDims[0], &piDims[1], &tmp_uint8);
+                }
+
+                for (i = 0; i < rank; i++)
+                {
+                    pszDims[i] = piDims[i];
+                }
+
+                createdVar = Mat_VarCreate(name, MAT_C_UINT8, MAT_T_UINT8, rank, pszDims, tmp_uint8, 0);
+                break;
+            case SCI_UINT16: /* UINT16 */
+                if (parent == NULL)
+                {
+                    sciErr = getMatrixOfUnsignedInteger16(pvApiCtx, var_addr, &piDims[0], &piDims[1], &tmp_uint16);
+                }
+                else
+                {
+                    sciErr = getMatrixOfUnsignedInteger16InList(pvApiCtx, parent, item_position, &piDims[0], &piDims[1], &tmp_uint16);
+                }
+
+                for (i = 0; i < rank; i++)
+                {
+                    pszDims[i] = piDims[i];
+                }
+
+                createdVar = Mat_VarCreate(name, MAT_C_UINT16, MAT_T_UINT16, rank, pszDims, tmp_uint16, 0);
+                break;
+            case SCI_UINT32: /* UINT32 */
+                if (parent == NULL)
+                {
+                    sciErr = getMatrixOfUnsignedInteger32(pvApiCtx, var_addr, &piDims[0], &piDims[1], &tmp_uint32);
+                }
+                else
+                {
+                    sciErr = getMatrixOfUnsignedInteger32InList(pvApiCtx, parent, item_position, &piDims[0], &piDims[1], &tmp_uint32);
+                }
+
+                for (i = 0; i < rank; i++)
+                {
+                    pszDims[i] = piDims[i];
+                }
+
+                createdVar = Mat_VarCreate(name, MAT_C_UINT32, MAT_T_UINT32, rank, pszDims, tmp_uint32, 0);
+                break;
+            default:
+                createdVar = NULL;
+                break;
         }
     }
-  else
+    else
     {
-      Scierror(999, _("%s: Wrong type for first input argument: Integer matrix expected.\n"), "GetIntegerVariable");
+        Scierror(999, _("%s: Wrong type for first input argument: Integer matrix expected.\n"), "GetIntegerVariable");
     }
 
-  FREE(dims);
+    FREE(pszDims);
+    FREE(piDims);
 
-  return createdVar;
+    return createdVar;
 }
diff --git a/modules/matio/src/c/GetMatlabVariable.c b/modules/matio/src/c/GetMatlabVariable.c
index a769288..34a906d 100644
--- a/modules/matio/src/c/GetMatlabVariable.c
+++ b/modules/matio/src/c/GetMatlabVariable.c
@@ -16,23 +16,23 @@
 #include "sci_types.h"
 #include "api_scilab.h"
 
-matvar_t *GetMatlabVariable(int iVar, const char *name, int matfile_version, int * parent, int item_position)
+matvar_t *GetMatlabVariable(void *pvApiCtx, int iVar, const char *name, int matfile_version, int * parent, int item_position)
 {
     int * var_addr = NULL;
     int var_type;
     SciErr sciErr;
     matvar_t * tmp_res = NULL;
 
-    if (parent==NULL)
+    if (parent == NULL)
     {
         sciErr = getVarAddressFromPosition(pvApiCtx, iVar, &var_addr);
-        if(sciErr.iErr)
+        if (sciErr.iErr)
         {
             printError(&sciErr, 0);
             return NULL;
         }
         sciErr = getVarType(pvApiCtx, var_addr, &var_type);
-        if(sciErr.iErr)
+        if (sciErr.iErr)
         {
             printError(&sciErr, 0);
             return NULL;
@@ -41,54 +41,54 @@ matvar_t *GetMatlabVariable(int iVar, const char *name, int matfile_version, int
     else
     {
         sciErr = getListItemAddress(pvApiCtx, parent, item_position, &var_addr);
-        if(sciErr.iErr)
+        if (sciErr.iErr)
         {
             printError(&sciErr, 0);
             return NULL;
         }
         sciErr = getVarType(pvApiCtx, var_addr, &var_type);
-        if(sciErr.iErr)
+        if (sciErr.iErr)
         {
             printError(&sciErr, 0);
             return NULL;
         }
     }
 
-    switch(var_type)
+    switch (var_type)
     {
-    case sci_matrix:
-        tmp_res = GetDoubleVariable(iVar, name, matfile_version, parent, item_position);
-        break;
-    case sci_strings:
-        tmp_res = GetCharVariable(iVar, name, parent, item_position);
-        break;
-    case sci_ints:
-        tmp_res = GetIntegerVariable(iVar, name, parent, item_position);
-        break;
-    case sci_mlist:
-        /* Only cells structs and hypermatrices are managed */
-        if (item_position > 0)
-        {
-            tmp_res = GetMlistVariable(iVar, name, matfile_version, parent, item_position);
-        }
-        else
-        {
-            tmp_res = GetMlistVariable(iVar, name, matfile_version, parent, -1);
-        }
-        break;
-    case sci_sparse:
-        if (item_position > 0)
-        {
-            tmp_res = GetSparseVariable(iVar, name, parent, item_position);
-        }
-        else
-        {
-            tmp_res = GetSparseVariable(iVar, name, parent, -1);
-        }
-        break;
-    default:
-        sciprint("Do not known how to get variable of type %d\n", var_type);
-        tmp_res = NULL;
+        case sci_matrix:
+            tmp_res = GetDoubleVariable(pvApiCtx, iVar, name, matfile_version, parent, item_position);
+            break;
+        case sci_strings:
+            tmp_res = GetCharVariable(pvApiCtx, iVar, name, parent, item_position);
+            break;
+        case sci_ints:
+            tmp_res = GetIntegerVariable(pvApiCtx, iVar, name, parent, item_position);
+            break;
+        case sci_mlist:
+            /* Only cells structs and hypermatrices are managed */
+            if (item_position > 0)
+            {
+                tmp_res = GetMlistVariable(pvApiCtx, iVar, name, matfile_version, parent, item_position);
+            }
+            else
+            {
+                tmp_res = GetMlistVariable(pvApiCtx, iVar, name, matfile_version, parent, -1);
+            }
+            break;
+        case sci_sparse:
+            if (item_position > 0)
+            {
+                tmp_res = GetSparseVariable(pvApiCtx, iVar, name, parent, item_position);
+            }
+            else
+            {
+                tmp_res = GetSparseVariable(pvApiCtx, iVar, name, parent, -1);
+            }
+            break;
+        default:
+            sciprint("Do not known how to get variable of type %d\n", var_type);
+            tmp_res = NULL;
     }
 
     return tmp_res;
diff --git a/modules/matio/src/c/GetMatlabVariable.h b/modules/matio/src/c/GetMatlabVariable.h
index 7a138ab..2ffa9da 100644
--- a/modules/matio/src/c/GetMatlabVariable.h
+++ b/modules/matio/src/c/GetMatlabVariable.h
@@ -1,12 +1,12 @@
 /*
  * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
- * Copyright (C) 2008 - INRIA - Vincent COUVERT 
+ * Copyright (C) 2008 - INRIA - Vincent COUVERT
  * Copyright (C) 2010 - DIGITEO - Yann COLLETTE
- * 
+ *
  * This file must be used under the terms of the CeCILL.
  * This source file is licensed as described in the file COPYING, which
  * you should have received as part of this distribution.  The terms
- * are also available at    
+ * are also available at
  * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
  *
  */
@@ -22,9 +22,10 @@
 
 /*
  * Get a Matlab variable from a Scilab variable on stack
- * This function reads nothing on stack but calls the function which 
+ * This function reads nothing on stack but calls the function which
  * does the work according to Scilab Variable type
- * 
+ *
+ * @param pvApiCtx Scilab context
  * @param iVar position on the stack
  * @param name the name of the variable
  * @param matfile_version version of the file to write (See MATIO library)
@@ -33,11 +34,12 @@
  *
  * @return Matlab variable (See MATIO library)
  */
-matvar_t *GetMatlabVariable(int iVar, const char *name, int matfile_version, int * parent, int item_position);
+matvar_t *GetMatlabVariable(void *pvApiCtx, int iVar, const char *name, int matfile_version, int * parent, int item_position);
 
 /*
  * Get a Matlab Integer variable from stack
- * 
+ *
+ * @param pvApiCtx Scilab context
  * @param iVar position on the stack
  * @param name the name of the variable
  * @param parent parent mlist. If NULL, a normal variable is created.
@@ -45,11 +47,12 @@ matvar_t *GetMatlabVariable(int iVar, const char *name, int matfile_version, int
  *
  * @return Matlab variable (See MATIO library)
  */
-matvar_t *GetIntegerVariable(int iVar, const char *name, int * parent, int item_position);
+matvar_t *GetIntegerVariable(void *pvApiCtx, int iVar, const char *name, int * parent, int item_position);
 
 /*
  * Get a Matlab Mlist-equivalent variable from stack
- * 
+ *
+ * @param pvApiCtx Scilab context
  * @param iVar position on the stack
  * @param name the name of the variable
  * @param matfile_version version of the file to write (See MATIO library)
@@ -58,11 +61,12 @@ matvar_t *GetIntegerVariable(int iVar, const char *name, int * parent, int item_
  *
  * @return Matlab variable (See MATIO library)
  */
-matvar_t *GetMlistVariable(int iVar, const char *name, int matfile_version, int * parent, int item_position);
+matvar_t *GetMlistVariable(void *pvApiCtx, int iVar, const char *name, int matfile_version, int * parent, int item_position);
 
 /*
  * Get a Matlab Struct variable from stack
- * 
+ *
+ * @param pvApiCtx Scilab context
  * @param iVar position on the stack
  * @param name the name of the variable
  * @param matfile_version version of the file to write (See MATIO library)
@@ -73,11 +77,12 @@ matvar_t *GetMlistVariable(int iVar, const char *name, int matfile_version, int
  *
  * @return Matlab variable (See MATIO library)
  */
-matvar_t *GetStructVariable(int iVar, const char *name, int matfile_version, char **fieldNames, int nbFields, int * parent, int item_position);
+matvar_t *GetStructVariable(void *pvApiCtx, int iVar, const char *name, int matfile_version, char **fieldNames, int nbFields, int * parent, int item_position);
 
 /*
  * Get a Matlab Cell variable from stack
- * 
+ *
+ * @param pvApiCtx Scilab context
  * @param iVar position on the stack
  * @param name the name of the variable
  * @param matfile_version version of the file to write (See MATIO library)
@@ -86,11 +91,12 @@ matvar_t *GetStructVariable(int iVar, const char *name, int matfile_version, cha
  *
  * @return Matlab variable (See MATIO library)
  */
-matvar_t *GetCellVariable(int iVar, const char *name, int matfile_version, int * parent, int item_position);
+matvar_t *GetCellVariable(void *pvApiCtx, int iVar, const char *name, int matfile_version, int * parent, int item_position);
 
 /*
  * Get a Matlab Char variable from stack
- * 
+ *
+ * @param pvApiCtx Scilab context
  * @param iVar position on the stack
  * @param name the name of the variable
  * @param parent parent mlist. If NULL, a normal variable is created.
@@ -98,11 +104,12 @@ matvar_t *GetCellVariable(int iVar, const char *name, int matfile_version, int *
  *
  * @return Matlab variable (See MATIO library)
  */
-matvar_t *GetCharVariable(int iVar, const char *name, int * parent, int item_position);
+matvar_t *GetCharVariable(void *pvApiCtx, int iVar, const char *name, int * parent, int item_position);
 
 /*
  * Get a Matlab Sparse variable from stack
- * 
+ *
+ * @param pvApiCtx Scilab context
  * @param iVar position on the stack
  * @param name the name of the variable
  * @param parent parent mlist. If NULL, a normal variable is created.
@@ -110,11 +117,12 @@ matvar_t *GetCharVariable(int iVar, const char *name, int * parent, int item_pos
  *
  * @return Matlab variable (See MATIO library)
  */
-matvar_t *GetSparseVariable(int iVar, const char *name, int * parent, int item_position);
+matvar_t *GetSparseVariable(void *pvApiCtx, int iVar, const char *name, int * parent, int item_position);
 
 /*
  * Get a Matlab Double variable from stack
- * 
+ *
+ * @param pvApiCtx Scilab context
  * @param iVar position on the stack
  * @param name the name of the variable
  * @param matfile_version version of the file to write (See MATIO library)
@@ -123,6 +131,6 @@ matvar_t *GetSparseVariable(int iVar, const char *name, int * parent, int item_p
  *
  * @return Matlab variable (See MATIO library)
  */
-matvar_t *GetDoubleVariable(int iVar, const char *name, int matfile_version, int * parent, int item_position);
+matvar_t *GetDoubleVariable(void *pvApiCtx, int iVar, const char *name, int matfile_version, int * parent, int item_position);
 
 #endif /* !__GETMATLABVARIABLE_H__ */
diff --git a/modules/matio/src/c/GetMlistVariable.c b/modules/matio/src/c/GetMlistVariable.c
index 67f9737..a5336fb 100644
--- a/modules/matio/src/c/GetMlistVariable.c
+++ b/modules/matio/src/c/GetMlistVariable.c
@@ -1,12 +1,12 @@
 /*
  * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
- * Copyright (C) 2008 - INRIA - Vincent COUVERT 
+ * Copyright (C) 2008 - INRIA - Vincent COUVERT
  * Copyright (C) 2010 - DIGITEO - Yann COLLETTE
- * 
+ *
  * This file must be used under the terms of the CeCILL.
  * This source file is licensed as described in the file COPYING, which
  * you should have received as part of this distribution.  The terms
- * are also available at    
+ * are also available at
  * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
  *
  */
@@ -20,81 +20,103 @@
 #include "freeArrayOfString.h"
 #include "MALLOC.h"
 
-#define MATIO_ERROR if(_SciErr.iErr) \
-    {				     \
-      printError(&_SciErr, 0);	     \
-      return 0;			     \
-    }
-
-#define DEBUG 1
-
-matvar_t *GetMlistVariable(int iVar, const char *name, int matfile_version, int * parent, int item_position)
+matvar_t *GetMlistVariable(void *pvApiCtx, int iVar, const char *name, int matfile_version, int * parent, int item_position)
 {
-  char **fieldNames = NULL;
-  int * pilen = NULL;
-  int nbRow = 0, nbFields = 0, i;
-  int * var_addr = NULL;
-  int var_type;
-  SciErr _SciErr;
-  matvar_t * tmp_res = NULL;
+    char **fieldNames = NULL;
+    int * pilen = NULL;
+    int nbRow = 0, nbFields = 0, i;
+    int * var_addr = NULL;
+    int var_type;
+    SciErr sciErr;
+    matvar_t * tmp_res = NULL;
 
-  if ((parent==NULL)&&(item_position==-1))
+    if ((parent == NULL) && (item_position == -1))
     {
-      _SciErr = getVarAddressFromPosition(pvApiCtx, iVar, &var_addr); MATIO_ERROR;
+        sciErr = getVarAddressFromPosition(pvApiCtx, iVar, &var_addr);
+        if (sciErr.iErr)
+        {
+            printError(&sciErr, 0);
+            return 0;
+        }
     }
-  else if ((parent!=NULL)&&(item_position==-1))
+    else if ((parent != NULL) && (item_position == -1))
     {
-      var_addr = parent;
+        var_addr = parent;
     }
-  else
+    else
     {
-      _SciErr = getListItemAddress(pvApiCtx, parent, item_position, &var_addr); MATIO_ERROR;
+        sciErr = getListItemAddress(pvApiCtx, parent, item_position, &var_addr);
+        if (sciErr.iErr)
+        {
+            printError(&sciErr, 0);
+            return 0;
+        }
     }
 
-  _SciErr = getVarType(pvApiCtx, var_addr, &var_type); MATIO_ERROR;
+    sciErr = getVarType(pvApiCtx, var_addr, &var_type);
+    if (sciErr.iErr)
+    {
+        printError(&sciErr, 0);
+        return 0;
+    }
 
-  if (var_type == sci_mlist)
+    if (var_type == sci_mlist)
     {
-      /* FIRST LIST ENTRY: fieldnames */
-      _SciErr    = getMatrixOfStringInList(pvApiCtx, var_addr, 1, &nbRow, &nbFields, NULL, NULL); MATIO_ERROR;
-      pilen      = (int *)MALLOC(nbRow*nbFields*sizeof(int));
-      fieldNames = (char **)MALLOC(nbRow*nbFields*sizeof(char *));
-      _SciErr    = getMatrixOfStringInList(pvApiCtx, var_addr, 1, &nbRow, &nbFields, pilen, NULL); MATIO_ERROR;
-      for(i=0;i<nbRow*nbFields;i++)
-      	{
-      	  fieldNames[i] = (char *)MALLOC((pilen[i]+1)*sizeof(char));
-      	}
-      _SciErr = getMatrixOfStringInList(pvApiCtx, var_addr, 1, &nbRow, &nbFields, pilen, fieldNames); MATIO_ERROR;
-      FREE(pilen);
+        /* FIRST LIST ENTRY: fieldnames */
+        sciErr    = getMatrixOfStringInList(pvApiCtx, var_addr, 1, &nbRow, &nbFields, NULL, NULL);
+        if (sciErr.iErr)
+        {
+            printError(&sciErr, 0);
+            return 0;
+        }
+        pilen      = (int *)MALLOC(nbRow * nbFields * sizeof(int));
+        fieldNames = (char **)MALLOC(nbRow * nbFields * sizeof(char *));
+        sciErr    = getMatrixOfStringInList(pvApiCtx, var_addr, 1, &nbRow, &nbFields, pilen, NULL);
+        if (sciErr.iErr)
+        {
+            printError(&sciErr, 0);
+            return 0;
+        }
+        for (i = 0; i < nbRow * nbFields; i++)
+        {
+            fieldNames[i] = (char *)MALLOC((pilen[i] + 1) * sizeof(char));
+        }
+        sciErr = getMatrixOfStringInList(pvApiCtx, var_addr, 1, &nbRow, &nbFields, pilen, fieldNames);
+        if (sciErr.iErr)
+        {
+            printError(&sciErr, 0);
+            return 0;
+        }
+        FREE(pilen);
 
-      if (strcmp(fieldNames[0], "ce")==0)
+        if (strcmp(fieldNames[0], "ce") == 0)
         {
-          freeArrayOfString(fieldNames, nbRow * nbFields);
-          return GetCellVariable(iVar, name, matfile_version, parent, item_position);
+            freeArrayOfString(fieldNames, nbRow * nbFields);
+            return GetCellVariable(pvApiCtx, iVar, name, matfile_version, parent, item_position);
         }
-      else if (strcmp(fieldNames[0], "st")==0)
+        else if (strcmp(fieldNames[0], "st") == 0)
         {
-          tmp_res = GetStructVariable(iVar, name, matfile_version, fieldNames, nbFields, parent, item_position);
-          freeArrayOfString(fieldNames, nbFields);
-          return tmp_res;
+            tmp_res = GetStructVariable(pvApiCtx, iVar, name, matfile_version, fieldNames, nbFields, parent, item_position);
+            freeArrayOfString(fieldNames, nbFields);
+            return tmp_res;
         }
-      else if (strcmp(fieldNames[0], "hm")==0)
+        else if (strcmp(fieldNames[0], "hm") == 0)
         {
-          /* TODO */
-          Scierror(999, _("%s: Mlists of type %s can not be written to Matlab binary files.\n"), "GetMlistVariable", fieldNames[0]);
-          freeArrayOfString(fieldNames, nbFields);
-          return NULL;
+            /* TODO */
+            Scierror(999, _("%s: Mlists of type %s can not be written to Matlab binary files.\n"), "GetMlistVariable", fieldNames[0]);
+            freeArrayOfString(fieldNames, nbFields);
+            return NULL;
         }
-      else
+        else
         {
-          Scierror(999, _("%s: Mlists of type %s can not be written to Matlab binary files.\n"), "GetMlistVariable", fieldNames[0]);
-          freeArrayOfString(fieldNames, nbFields);
-          return NULL;
+            Scierror(999, _("%s: Mlists of type %s can not be written to Matlab binary files.\n"), "GetMlistVariable", fieldNames[0]);
+            freeArrayOfString(fieldNames, nbFields);
+            return NULL;
         }
     }
-  else
+    else
     {
-      Scierror(999, _("%s: Wrong type for first input argument: Mlist expected.\n"), "GetMlistVariable");
-      return NULL;
+        Scierror(999, _("%s: Wrong type for first input argument: Mlist expected.\n"), "GetMlistVariable");
+        return NULL;
     }
 }
diff --git a/modules/matio/src/c/GetSparseVariable.c b/modules/matio/src/c/GetSparseVariable.c
index 2025678..95e909e 100644
--- a/modules/matio/src/c/GetSparseVariable.c
+++ b/modules/matio/src/c/GetSparseVariable.c
@@ -14,46 +14,57 @@
 #include "stack-c.h"
 #include "api_scilab.h"
 
-#define MATIO_ERROR if(_SciErr.iErr) \
-    {				     \
-      printError(&_SciErr, 0);	     \
-      return 0;			     \
-    }
-
-matvar_t *GetSparseVariable(int iVar, const char *name, int * parent, int item_position)
+matvar_t *GetSparseVariable(void *pvApiCtx, int iVar, const char *name, int * parent, int item_position)
 {
     int K = 0;
     int rank = 0;
+    size_t* pszDims = NULL;
     int *dims = NULL;
     double *data = NULL;
     matvar_t *createdVar = NULL;
-    sparse_t *sparseData = NULL;
+    mat_sparse_t *sparseData = NULL;
     SciSparse scilabSparse;
     int *colIndexes = NULL;
     int *rowIndexes = NULL;
     int * var_addr = NULL;
     int * item_addr = NULL;
     int var_type;
-    SciErr _SciErr;
+    SciErr sciErr;
 
     if (parent == NULL)
     {
-        _SciErr = getVarAddressFromPosition(pvApiCtx, iVar, &var_addr);
-        MATIO_ERROR;
-        _SciErr = getVarType(pvApiCtx, var_addr, &var_type);
-        MATIO_ERROR;
+        sciErr = getVarAddressFromPosition(pvApiCtx, iVar, &var_addr);
+        if (sciErr.iErr)
+        {
+            printError(&sciErr, 0);
+            return 0;
+        }
+        sciErr = getVarType(pvApiCtx, var_addr, &var_type);
+        if (sciErr.iErr)
+        {
+            printError(&sciErr, 0);
+            return 0;
+        }
     }
     else
     {
-        _SciErr = getListItemAddress(pvApiCtx, parent, item_position, &item_addr);
-        MATIO_ERROR;
-        _SciErr = getVarType(pvApiCtx, item_addr, &var_type);
-        MATIO_ERROR;
+        sciErr = getListItemAddress(pvApiCtx, parent, item_position, &item_addr);
+        if (sciErr.iErr)
+        {
+            printError(&sciErr, 0);
+            return 0;
+        }
+        sciErr = getVarType(pvApiCtx, item_addr, &var_type);
+        if (sciErr.iErr)
+        {
+            printError(&sciErr, 0);
+            return 0;
+        }
     }
 
     if (var_type == sci_sparse)
     {
-        sparseData = (sparse_t*) MALLOC(sizeof(sparse_t));
+        sparseData = (mat_sparse_t*) MALLOC(sizeof(mat_sparse_t));
         if (sparseData == NULL)
         {
             Scierror(999, _("%s: No more memory.\n"), "GetSparseVariable");
@@ -64,7 +75,6 @@ matvar_t *GetSparseVariable(int iVar, const char *name, int * parent, int item_p
         if ((dims = (int*) MALLOC (sizeof(int) * rank)) == NULL)
         {
             Scierror(999, _("%s: No more memory.\n"), "GetSparseVariable");
-            free(sparseData);
             return NULL;
         }
 
@@ -79,8 +89,13 @@ matvar_t *GetSparseVariable(int iVar, const char *name, int * parent, int item_p
             }
             else
             {
-                _SciErr = getSparseMatrixInList(pvApiCtx, parent, item_position, &dims[1], &dims[0],
-                                                &scilabSparse.nel, NULL, NULL, NULL);
+                sciErr = getSparseMatrixInList(pvApiCtx, parent, item_position, &dims[1], &dims[0],
+                                               &scilabSparse.nel, NULL, NULL, NULL);
+                if (sciErr.iErr)
+                {
+                    printError(&sciErr, 0);
+                    return 0;
+                }
                 scilabSparse.mnel = (int *)MALLOC(dims[1] * sizeof(int));
                 if (scilabSparse.mnel == NULL)
                 {
@@ -123,9 +138,14 @@ matvar_t *GetSparseVariable(int iVar, const char *name, int * parent, int item_p
 
                     return FALSE;
                 }
-                _SciErr = getComplexSparseMatrixInList(pvApiCtx, parent, item_position, &dims[1], &dims[0],
-                                                       &scilabSparse.nel, &scilabSparse.mnel,
-                                                       &scilabSparse.icol, &scilabSparse.R, &scilabSparse.I);
+                sciErr = getComplexSparseMatrixInList(pvApiCtx, parent, item_position, &dims[1], &dims[0],
+                                                      &scilabSparse.nel, &scilabSparse.mnel,
+                                                      &scilabSparse.icol, &scilabSparse.R, &scilabSparse.I);
+                if (sciErr.iErr)
+                {
+                    printError(&sciErr, 0);
+                    return 0;
+                }
             }
 
             scilabSparse.it = 1;
@@ -141,8 +161,13 @@ matvar_t *GetSparseVariable(int iVar, const char *name, int * parent, int item_p
             }
             else
             {
-                _SciErr = getSparseMatrixInList(pvApiCtx, parent, item_position, &dims[1], &dims[0],
-                                                &scilabSparse.nel, NULL, NULL, NULL);
+                sciErr = getSparseMatrixInList(pvApiCtx, parent, item_position, &dims[1], &dims[0],
+                                               &scilabSparse.nel, NULL, NULL, NULL);
+                if (sciErr.iErr)
+                {
+                    printError(&sciErr, 0);
+                    return 0;
+                }
                 scilabSparse.mnel = (int *)MALLOC(dims[1] * sizeof(int));
                 if (scilabSparse.mnel == NULL)
                 {
@@ -173,9 +198,14 @@ matvar_t *GetSparseVariable(int iVar, const char *name, int * parent, int item_p
 
                     return FALSE;
                 }
-                _SciErr = getSparseMatrixInList(pvApiCtx, parent, item_position, &dims[1], &dims[0],
-                                                &scilabSparse.nel, &scilabSparse.mnel,
-                                                &scilabSparse.icol, &scilabSparse.R);
+                sciErr = getSparseMatrixInList(pvApiCtx, parent, item_position, &dims[1], &dims[0],
+                                               &scilabSparse.nel, &scilabSparse.mnel,
+                                               &scilabSparse.icol, &scilabSparse.R);
+                if (sciErr.iErr)
+                {
+                    printError(&sciErr, 0);
+                    return 0;
+                }
             }
 
             scilabSparse.it = 0;
@@ -213,7 +243,6 @@ matvar_t *GetSparseVariable(int iVar, const char *name, int * parent, int item_p
         if (rowIndexes == NULL)
         {
             Scierror(999, _("%s: No more memory.\n"), "GetSparseVariable");
-            free(colIndexes);
 
             if (scilabSparse.it)
             {
@@ -237,8 +266,8 @@ matvar_t *GetSparseVariable(int iVar, const char *name, int * parent, int item_p
             if ((data = (double*) MALLOC(sizeof(double) * scilabSparse.nel)) == NULL)
             {
                 Scierror(999, _("%s: No more memory.\n"), "GetSparseVariable");
-                free(rowIndexes);
-                free(colIndexes);
+                FREE(rowIndexes);
+                FREE(colIndexes);
                 if (scilabSparse.it)
                 {
                     freeAllocatedComplexSparseMatrix(scilabSparse.mnel, scilabSparse.icol, scilabSparse.R, scilabSparse.I);
@@ -261,7 +290,8 @@ matvar_t *GetSparseVariable(int iVar, const char *name, int * parent, int item_p
             if ((data = (double*) MALLOC(2 * sizeof(double) * scilabSparse.nel)) == NULL)
             {
                 Scierror(999, _("%s: No more memory.\n"), "GetSparseVariable");
-
+                FREE(rowIndexes);
+                FREE(colIndexes);
                 if (scilabSparse.it)
                 {
                     freeAllocatedComplexSparseMatrix(scilabSparse.mnel, scilabSparse.icol, scilabSparse.R, scilabSparse.I);
@@ -270,8 +300,7 @@ matvar_t *GetSparseVariable(int iVar, const char *name, int * parent, int item_p
                 {
                     freeAllocatedSparseMatrix(scilabSparse.mnel, scilabSparse.icol, scilabSparse.R);
                 }
-                free(rowIndexes);
-                free(colIndexes);
+
                 return FALSE;
             }
 
@@ -296,13 +325,36 @@ matvar_t *GetSparseVariable(int iVar, const char *name, int * parent, int item_p
         sparseData->ndata = scilabSparse.nel;
         sparseData->data  = (void*) data;
 
+        pszDims = (size_t*) MALLOC(rank * sizeof(size_t));
+        if (pszDims == NULL)
+        {
+            Scierror(999, _("%s: No more memory.\n"), "GetSparseVariable");
+
+            if (scilabSparse.it)
+            {
+                freeAllocatedComplexSparseMatrix(scilabSparse.mnel, scilabSparse.icol, scilabSparse.R, scilabSparse.I);
+            }
+            else
+            {
+                freeAllocatedSparseMatrix(scilabSparse.mnel, scilabSparse.icol, scilabSparse.R);
+            }
+
+            return 0;
+        }
+
+        for (K = 0; K < rank; K++)
+        {
+            pszDims[K] = dims[K];
+        }
+
         if (scilabSparse.it == 0)
         {
-            createdVar = Mat_VarCreate(name, MAT_C_SPARSE, MAT_T_DOUBLE, rank, dims, sparseData, 0 | MEM_CONSERVE);
+            createdVar = Mat_VarCreate(name, MAT_C_SPARSE, MAT_T_DOUBLE, rank, pszDims, sparseData, 0 | MAT_F_DONT_COPY_DATA);
         }
         else
         {
-            createdVar = Mat_VarCreate(name, MAT_C_SPARSE, MAT_T_DOUBLE, rank, dims, sparseData, MAT_F_COMPLEX | MEM_CONSERVE);
+            createdVar = Mat_VarCreate(name, MAT_C_SPARSE, MAT_T_DOUBLE, rank, pszDims, sparseData, MAT_F_COMPLEX | MAT_F_DONT_COPY_DATA);
+
             if (data)
             {
                 FREE(data);
@@ -313,6 +365,11 @@ matvar_t *GetSparseVariable(int iVar, const char *name, int * parent, int item_p
         {
             FREE(dims);
         }
+
+        if (pszDims)
+        {
+            FREE(pszDims);
+        }
     }
     else
     {
diff --git a/modules/matio/src/c/GetStructVariable.c b/modules/matio/src/c/GetStructVariable.c
index 20d131e..7d21f07 100644
--- a/modules/matio/src/c/GetStructVariable.c
+++ b/modules/matio/src/c/GetStructVariable.c
@@ -1,13 +1,13 @@
 /*
  * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
- * Copyright (C) 2008 - INRIA - Vincent COUVERT 
+ * Copyright (C) 2008 - INRIA - Vincent COUVERT
  * Copyright (C) 2010 - DIGITEO - Yann COLLETTE
  * Copyright (C) 2011 - DIGITEO - Vincent COUVERT
- * 
+ *
  * This file must be used under the terms of the CeCILL.
  * This source file is licensed as described in the file COPYING, which
  * you should have received as part of this distribution.  The terms
- * are also available at    
+ * are also available at
  * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
  *
  */
@@ -16,11 +16,12 @@
 #include "api_scilab.h"
 #include "freeArrayOfString.h"
 
-matvar_t *GetStructVariable(int iVar, const char *name, int matfile_version, char **fieldNames, int nbFields, int * parent, int item_position)
+matvar_t *GetStructVariable(void *pvApiCtx, int iVar, const char *name, int matfile_version, char **fieldNames, int nbFields, int * parent, int item_position)
 {
     int fieldIndex = 0;
     int valueIndex = 0;
     int K = 0;
+    size_t *pszDims = NULL;
     int prodDims = 1;
     matvar_t *dimensionsVariable = NULL;
     matvar_t **structEntries = NULL;
@@ -28,7 +29,7 @@ matvar_t *GetStructVariable(int iVar, const char *name, int matfile_version, cha
     int * list_addr = NULL;
     SciErr sciErr;
 
-    if (parent==NULL)
+    if (parent == NULL)
     {
         sciErr = getVarAddressFromPosition(pvApiCtx, iVar, &var_addr);
     }
@@ -36,7 +37,7 @@ matvar_t *GetStructVariable(int iVar, const char *name, int matfile_version, cha
     {
         sciErr = getListItemAddress(pvApiCtx, parent, item_position, &var_addr);
     }
-    if(sciErr.iErr)
+    if (sciErr.iErr)
     {
         printError(&sciErr, 0);
         return NULL;
@@ -45,23 +46,33 @@ matvar_t *GetStructVariable(int iVar, const char *name, int matfile_version, cha
     /* FIRST LIST ENTRY: fieldnames --> NO NEED TO BE READ */
 
     /* SECOND LIST ENTRY: dimensions */
-    /* Second input argument = "data" beacause we do not need to give the format because this variable is just temp */ 
-    dimensionsVariable = GetMatlabVariable(iVar, "data", 0, var_addr, 2);
+    /* Second input argument = "data" because we do not need to give the format because this variable is just temp */
+    dimensionsVariable = GetMatlabVariable(pvApiCtx, iVar, "data", 0, var_addr, 2);
+
+    pszDims = (size_t*) MALLOC(dimensionsVariable->rank * sizeof(size_t));
+    if (pszDims == NULL)
+    {
+        Scierror(999, _("%s: No more memory.\n"), "GetStructVariable");
+        freeArrayOfString(fieldNames, nbFields);
+        return NULL;
+    }
 
     /* Total number of entries */
-    for (K=0; K<dimensionsVariable->rank; K++)
+    for (K = 0; K < dimensionsVariable->rank; K++)
     {
-        prodDims *= ((int *)dimensionsVariable->data)[K];
+        prodDims *= ((int*)dimensionsVariable->data)[K];
+        pszDims[K] = ((int*)dimensionsVariable->data)[K];
     }
 
     /* OTHERS LIST ENTRIES: ALL STRUCT VALUES */
-    if ((structEntries = (matvar_t **) MALLOC (sizeof(matvar_t*)*(prodDims*(nbFields-2)+1))) == NULL)
+    structEntries = (matvar_t **) MALLOC (sizeof(matvar_t*) * (prodDims * (nbFields - 2) + 1));
+    if (structEntries == NULL)
     {
         Scierror(999, _("%s: No more memory.\n"), "GetStructVariable");
         freeArrayOfString(fieldNames, nbFields);
         return NULL;
     }
-    for (K = 0; K < prodDims*(nbFields-2)+1; K++)
+    for (K = 0; K < prodDims * (nbFields - 2) + 1; K++)
     {
         structEntries[K] = NULL;
     }
@@ -70,7 +81,7 @@ matvar_t *GetStructVariable(int iVar, const char *name, int matfile_version, cha
     {
         for (fieldIndex = 2; fieldIndex < nbFields; fieldIndex++)
         {
-            structEntries[fieldIndex - 2] = GetMatlabVariable(iVar ,fieldNames[fieldIndex], matfile_version, var_addr, fieldIndex+1);
+            structEntries[fieldIndex - 2] = GetMatlabVariable(pvApiCtx, iVar , fieldNames[fieldIndex], matfile_version, var_addr, fieldIndex + 1);
         }
     }
     else
@@ -80,8 +91,8 @@ matvar_t *GetStructVariable(int iVar, const char *name, int matfile_version, cha
         /* Read all entries */
         for (fieldIndex = 2; fieldIndex < nbFields; fieldIndex++)
         {
-            sciErr = getListInList(pvApiCtx, var_addr, fieldIndex+1, &list_addr);
-            if(sciErr.iErr)
+            sciErr = getListInList(pvApiCtx, var_addr, fieldIndex + 1, &list_addr);
+            if (sciErr.iErr)
             {
                 printError(&sciErr, 0);
                 return NULL;
@@ -89,10 +100,10 @@ matvar_t *GetStructVariable(int iVar, const char *name, int matfile_version, cha
 
             for (valueIndex = 0; valueIndex < prodDims; valueIndex++)
             {
-                structEntries[(fieldIndex-1) + (nbFields-2)*valueIndex] = GetMatlabVariable(iVar ,fieldNames[fieldIndex], matfile_version, list_addr, valueIndex+1);
+                structEntries[(fieldIndex - 1) + (nbFields - 2)*valueIndex] = GetMatlabVariable(pvApiCtx, iVar , fieldNames[fieldIndex], matfile_version, list_addr, valueIndex + 1);
             }
         }
     }
 
-    return Mat_VarCreate(name, MAT_C_STRUCT, MAT_T_STRUCT, dimensionsVariable->rank, dimensionsVariable->data, structEntries, 0);
+    return Mat_VarCreate(name, MAT_C_STRUCT, MAT_T_STRUCT, dimensionsVariable->rank, pszDims, structEntries, 0);
 }
diff --git a/modules/matio/src/c/matfile_manager.c b/modules/matio/src/c/matfile_manager.c
index 2ba34db..fe97a78 100644
--- a/modules/matio/src/c/matfile_manager.c
+++ b/modules/matio/src/c/matfile_manager.c
@@ -1,12 +1,12 @@
 /*
  * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
- * Copyright (C) 2008 - INRIA - Vincent COUVERT 
+ * Copyright (C) 2008 - INRIA - Vincent COUVERT
  * Copyright (C) 2010 - DIGITEO - Yann COLLETTE
- * 
+ *
  * This file must be used under the terms of the CeCILL.
  * This source file is licensed as described in the file COPYING, which
  * you should have received as part of this distribution.  The terms
- * are also available at    
+ * are also available at
  * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
  *
  */
@@ -23,88 +23,88 @@ static int numberOfMatfiles = 0;
 
 /*******************************************************************************
    This function manages the set of files:
-     - opened using matfile_open 
+     - opened using matfile_open
      - closed using matfile_closed
    All pointers to opened files are stored in a static variable
 *******************************************************************************/
 void matfile_manager(int action, int *fileIndex, mat_t **matfile)
 {
-  int K = 0; /* Loop index */
-  
-  if (action == MATFILEMANAGER_GETFILE) /* Get the mat_t structure corresponding to the fileIndex (fileIndex is an input) */
+    int K = 0; /* Loop index */
+
+    if (action == MATFILEMANAGER_GETFILE) /* Get the mat_t structure corresponding to the fileIndex (fileIndex is an input) */
     {
-      if((*fileIndex >= numberOfMatfiles) || (*fileIndex < 0)) /* FileIndex is too big or invalid */
+        if ((*fileIndex >= numberOfMatfiles) || (*fileIndex < 0)) /* FileIndex is too big or invalid */
         {
-          *matfile = NULL; /* Return NULL */
+            *matfile = NULL; /* Return NULL */
         }
-      else /* Return corresponding matfile */
+        else /* Return corresponding matfile */
         {
-          *matfile = openedMatfiles[*fileIndex];
+            *matfile = openedMatfiles[*fileIndex];
         }
     }
-  else if(action == MATFILEMANAGER_ADDFILE) /* Add matfile to the list of opened matfiles (fileIndex is an output) */
+    else if (action == MATFILEMANAGER_ADDFILE) /* Add matfile to the list of opened matfiles (fileIndex is an output) */
     {
-      if(numberOfMatfiles==0) /* No file opened */
+        if (numberOfMatfiles == 0) /* No file opened */
         {
-          numberOfMatfiles++;
-	  if (openedMatfiles)
-	    {
-	      openedMatfiles = (mat_t**)REALLOC(openedMatfiles, numberOfMatfiles*sizeof(mat_t*));
-	    }
-	  else
-	    {
-	      openedMatfiles = (mat_t**)MALLOC(numberOfMatfiles*sizeof(mat_t*));
-	    }
-          *fileIndex = numberOfMatfiles-1;
-          openedMatfiles[*fileIndex] = *matfile;
+            numberOfMatfiles++;
+            if (openedMatfiles)
+            {
+                openedMatfiles = (mat_t**)REALLOC(openedMatfiles, numberOfMatfiles * sizeof(mat_t*));
+            }
+            else
+            {
+                openedMatfiles = (mat_t**)MALLOC(numberOfMatfiles * sizeof(mat_t*));
+            }
+            *fileIndex = numberOfMatfiles - 1;
+            openedMatfiles[*fileIndex] = *matfile;
         }
-      else
+        else
         {
-          /* Search for an empty space in openedMatfiles */
-          for(K=0;K<numberOfMatfiles;K++)
+            /* Search for an empty space in openedMatfiles */
+            for (K = 0; K < numberOfMatfiles; K++)
             {
-              if(openedMatfiles[K]==NULL)
+                if (openedMatfiles[K] == NULL)
                 {
-                  openedMatfiles[K] = *matfile;
-                  *fileIndex = K;
-                  return;
+                    openedMatfiles[K] = *matfile;
+                    *fileIndex = K;
+                    return;
                 }
             }
-          numberOfMatfiles++;
-          openedMatfiles = (mat_t**)REALLOC(openedMatfiles, numberOfMatfiles*sizeof(mat_t*));
-          *fileIndex = numberOfMatfiles-1;
-          openedMatfiles[*fileIndex] = *matfile;
+            numberOfMatfiles++;
+            openedMatfiles = (mat_t**)REALLOC(openedMatfiles, numberOfMatfiles * sizeof(mat_t*));
+            *fileIndex = numberOfMatfiles - 1;
+            openedMatfiles[*fileIndex] = *matfile;
         }
     }
-  else if(action == MATFILEMANAGER_DELFILE) /* Close matfile (fileIndex is an input) */
+    else if (action == MATFILEMANAGER_DELFILE) /* Close matfile (fileIndex is an input) */
     {
-      if((*fileIndex >= numberOfMatfiles) || (*fileIndex < 0)) /* FileIndex is too big or invalid */
+        if ((*fileIndex >= numberOfMatfiles) || (*fileIndex < 0)) /* FileIndex is too big or invalid */
         {
-          matfile = NULL; /* Return NULL */
+            matfile = NULL; /* Return NULL */
         }
-      else /* Return corresponding matfile */
+        else /* Return corresponding matfile */
         {
-          *matfile = openedMatfiles[*fileIndex];
-          //sciprint("Have to Close %s\n", (*matfile)->filename);
-          openedMatfiles[*fileIndex] = NULL;
+            *matfile = openedMatfiles[*fileIndex];
+            //sciprint("Have to Close %s\n", (*matfile)->filename);
+            openedMatfiles[*fileIndex] = NULL;
         }
-    } 
-  else if(action == MATFILEMANAGER_VIEWFILE) /* Display names of opened matfiles */
+    }
+    else if (action == MATFILEMANAGER_VIEWFILE) /* Display names of opened matfiles */
     {
-      for(K=0;K<numberOfMatfiles;K++)
+        for (K = 0; K < numberOfMatfiles; K++)
         {
-          if(openedMatfiles[K]!=NULL)
+            if (openedMatfiles[K] != NULL)
             {
-              sciprint("%d -> %s\n", K, openedMatfiles[K]->filename);
+                sciprint("%d -> %s\n", K, Mat_GetFilename(openedMatfiles[K]));
             }
-          else
+            else
             {
-              sciprint("%d -> Empty\n", K);
+                sciprint("%d -> Empty\n", K);
             }
         }
     }
-  else /* Unknown action */
+    else /* Unknown action */
     {
-      /* Return NULL */
+        /* Return NULL */
     }
 }
diff --git a/modules/matio/tests/nonreg_tests/bug_5462.dia.ref b/modules/matio/tests/nonreg_tests/bug_5462.dia.ref
index 2b6709b..8fb3d45 100644
--- a/modules/matio/tests/nonreg_tests/bug_5462.dia.ref
+++ b/modules/matio/tests/nonreg_tests/bug_5462.dia.ref
@@ -4,7 +4,6 @@
 //
 //  This file is distributed under the same license as the Scilab package.
 // =============================================================================
-//
 // <-- CLI SHELL MODE -->
 //
 // <-- ENGLISH IMPOSED -->
@@ -17,9 +16,9 @@
 // <-- Short Description -->
 // Can not save correctly a sparse matrix in a MAT-file using savematfile.
 A = sprand(1000,1000,0.01);
-savematfile('test_matfile.mat','A');
+savematfile(TMPDIR + filesep() + "bug_5462.mat", "A");
 WARNING: Option -v7 added.
 A1 = A;
 clear A
-loadmatfile('test_matfile.mat','A');
+loadmatfile(TMPDIR + filesep() + "bug_5462.mat", "A");
 if (norm(A1 - A)>=10*%eps) then bugmes();quit;end
diff --git a/modules/matio/tests/nonreg_tests/bug_5462.tst b/modules/matio/tests/nonreg_tests/bug_5462.tst
index 9d6a0b4..5497bc4 100644
--- a/modules/matio/tests/nonreg_tests/bug_5462.tst
+++ b/modules/matio/tests/nonreg_tests/bug_5462.tst
@@ -17,9 +17,9 @@
 // Can not save correctly a sparse matrix in a MAT-file using savematfile.
 
 A = sprand(1000,1000,0.01);
-savematfile('test_matfile.mat','A');
+savematfile(TMPDIR + filesep() + "bug_5462.mat", "A");
 A1 = A;
 clear A
-loadmatfile('test_matfile.mat','A');
+loadmatfile(TMPDIR + filesep() + "bug_5462.mat", "A");
 
 if (norm(A1 - A)>=10*%eps) then pause,end
-- 
1.7.10.4

