From 2cf990f2bb971b8090ed8954f5a2868b3143afbd Mon Sep 17 00:00:00 2001
From: Liang Guo <guoliang@debian.org>
Date: Tue, 12 Jun 2012 13:46:58 +0800
Subject: [PATCH] Make celt to be optional

Like patch [1] for spice, This patch will make celt to be
optional for spice-gtk.

[1] http://lists.freedesktop.org/archives/spice-devel/2012-June/009410.html
--- a/configure.ac
+++ b/configure.ac
@@ -96,11 +96,24 @@
 AC_SUBST(PIXMAN_LIBS)
 SPICE_GLIB_REQUIRES+=" pixman-1 >= 0.17.7"
 
-PKG_CHECK_MODULES(CELT051, celt051 >= 0.5.1.1)
-AC_SUBST(CELT051_CFLAGS)
-AC_SUBST(CELT051_LIBS)
-AC_SUBST(CELT051_LIBDIR)
-SPICE_GLIB_REQUIRES+=" celt051 >= 0.5.1.1"
+AC_ARG_ENABLE([celt],
+  AS_HELP_STRING([--enable-celt=@<:@yes/no@:>@],
+                 [Enable celt support @<:@default=yes@:>@]),
+  [],
+  [enable_celt="yes"])
+
+if test "x$enable_celt" = "xno"; then
+  AM_CONDITIONAL(WITH_CELT051, false)
+else
+  PKG_CHECK_MODULES(CELT051, celt051 >= 0.5.1.1)
+  AC_SUBST(CELT051_CFLAGS)
+  AC_SUBST(CELT051_LIBS)
+  AC_SUBST(CELT051_LIBDIR)
+  SPICE_GLIB_REQUIRES+=" celt051 >= 0.5.1.1"
+  AC_DEFINE(HAVE_CELT051, [1], [Define if celt codec])
+  AM_CONDITIONAL(WITH_CELT051, true)
+fi
+
 
 PKG_CHECK_MODULES(SSL, openssl)
 AC_SUBST(SSL_CFLAGS)
@@ -665,6 +678,7 @@
         SASL support:             ${enable_sasl}
         Smartcard support:        ${have_smartcard}
         USB redirection support:  ${have_usbredir}
+        CELT support:             ${enable_celt}
         Gtk:                      $GTK_API_VERSION
 
         Now type 'make' to build $PACKAGE
--- a/gtk/channel-playback.c
+++ b/gtk/channel-playback.c
@@ -15,7 +15,6 @@
    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, see <http://www.gnu.org/licenses/>.
 */
-#include <celt051/celt.h>
 
 #include "spice-client.h"
 #include "spice-common.h"
@@ -24,6 +23,10 @@
 
 #include "spice-marshal.h"
 
+#if HAVE_CELT051
+#include <celt051/celt.h>
+#endif
+
 /**
  * SECTION:channel-playback
  * @short_description: audio stream for playback
@@ -48,8 +51,10 @@
 
 struct _SpicePlaybackChannelPrivate {
     int                         mode;
+#if HAVE_CELT051
     CELTMode                    *celt_mode;
     CELTDecoder                 *celt_decoder;
+#endif
     guint32                     frame_count;
     guint32                     last_time;
     guint8                      nchannels;
@@ -85,8 +90,10 @@
 
 static void spice_playback_channel_reset_capabilities(SpiceChannel *channel)
 {
+#ifdef HAVE_CELT051
     if (!g_getenv("SPICE_DISABLE_CELT"))
         spice_channel_set_capability(SPICE_CHANNEL(channel), SPICE_PLAYBACK_CAP_CELT_0_5_1);
+#endif
     spice_channel_set_capability(SPICE_CHANNEL(channel), SPICE_PLAYBACK_CAP_VOLUME);
 }
 
@@ -101,6 +108,7 @@
 {
     SpicePlaybackChannelPrivate *c = SPICE_PLAYBACK_CHANNEL(obj)->priv;
 
+#if HAVE_CELT051
     if (c->celt_decoder) {
         celt051_decoder_destroy(c->celt_decoder);
         c->celt_decoder = NULL;
@@ -110,7 +118,7 @@
         celt051_mode_destroy(c->celt_mode);
         c->celt_mode = NULL;
     }
-
+#endif
     g_free(c->volume);
     c->volume = NULL;
 
@@ -163,8 +171,8 @@
 /* main or coroutine context */
 static void spice_playback_channel_reset(SpiceChannel *channel, gboolean migrating)
 {
+#ifdef HAVE_CELT051
     SpicePlaybackChannelPrivate *c = SPICE_PLAYBACK_CHANNEL(channel)->priv;
-
     if (c->celt_decoder) {
         celt051_decoder_destroy(c->celt_decoder);
         c->celt_decoder = NULL;
@@ -174,7 +182,7 @@
         celt051_mode_destroy(c->celt_mode);
         c->celt_mode = NULL;
     }
-
+#endif
     SPICE_CHANNEL_CLASS(spice_playback_channel_parent_class)->channel_reset(channel, migrating);
 }
 
@@ -359,6 +367,7 @@
         emit_main_context(channel, SPICE_PLAYBACK_DATA,
                           packet->data, packet->data_size);
         break;
+#ifdef  HAVE_CELT051
     case SPICE_AUDIO_DATA_MODE_CELT_0_5_1: {
         celt_int16_t pcm[256 * 2];
 
@@ -374,6 +383,7 @@
                           (uint8_t *)pcm, sizeof(pcm));
         break;
     }
+#endif
     default:
         g_warning("%s: unhandled mode", __FUNCTION__);
         break;
@@ -396,7 +406,9 @@
     c->mode = mode->mode;
     switch (c->mode) {
     case SPICE_AUDIO_DATA_MODE_RAW:
+#ifdef HAVE_CELT051
     case SPICE_AUDIO_DATA_MODE_CELT_0_5_1:
+#endif
         break;
     default:
         g_warning("%s: unhandled mode", __FUNCTION__);
@@ -409,7 +421,9 @@
 {
     SpicePlaybackChannelPrivate *c = SPICE_PLAYBACK_CHANNEL(channel)->priv;
     SpiceMsgPlaybackStart *start = spice_msg_in_parsed(in);
+#ifdef HAVE_CELT051
     int celt_mode_err;
+#endif
 
     CHANNEL_DEBUG(channel, "%s: fmt %d channels %d freq %d time %d", __FUNCTION__,
                   start->format, start->channels, start->frequency, start->time);
@@ -422,6 +436,7 @@
         emit_main_context(channel, SPICE_PLAYBACK_START,
                           start->format, start->channels, start->frequency);
         break;
+#ifdef HAVE_CELT051
     case SPICE_AUDIO_DATA_MODE_CELT_0_5_1: {
         /* TODO: only support one setting now */
         int frame_size = 256;
@@ -441,6 +456,7 @@
                           start->format, start->channels, start->frequency);
         break;
     }
+#endif
     default:
         g_warning("%s: unhandled mode", __FUNCTION__);
         break;
--- a/gtk/channel-record.c
+++ b/gtk/channel-record.c
@@ -15,7 +15,6 @@
    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, see <http://www.gnu.org/licenses/>.
 */
-#include <celt051/celt.h>
 
 #include "spice-client.h"
 #include "spice-common.h"
@@ -24,6 +23,10 @@
 #include "spice-marshal.h"
 #include "spice-session-priv.h"
 
+#if HAVE_CELT051
+#include <celt051/celt.h>
+#endif
+
 /**
  * SECTION:channel-record
  * @short_description: audio stream for recording
@@ -51,8 +54,10 @@
 struct _SpiceRecordChannelPrivate {
     int                         mode;
     gboolean                    started;
+#ifdef HAVE_CELT051
     CELTMode                    *celt_mode;
     CELTEncoder                 *celt_encoder;
+#endif
     gsize                       frame_bytes;
     guint8                      *last_frame;
     gsize                       last_frame_current;
@@ -91,8 +96,10 @@
 
 static void spice_record_channel_reset_capabilities(SpiceChannel *channel)
 {
+#if HAVE_CELT051
     if (!g_getenv("SPICE_DISABLE_CELT"))
         spice_channel_set_capability(SPICE_CHANNEL(channel), SPICE_RECORD_CAP_CELT_0_5_1);
+#endif
     spice_channel_set_capability(SPICE_CHANNEL(channel), SPICE_RECORD_CAP_VOLUME);
 }
 
@@ -109,7 +116,7 @@
 
     g_free(c->last_frame);
     c->last_frame = NULL;
-
+#ifdef HAVE_CELT051
     if (c->celt_encoder) {
         celt051_encoder_destroy(c->celt_encoder);
         c->celt_encoder = NULL;
@@ -119,7 +126,7 @@
         celt051_mode_destroy(c->celt_mode);
         c->celt_mode = NULL;
     }
-
+#endif
     g_free(c->volume);
     c->volume = NULL;
 
@@ -175,7 +182,7 @@
 
     g_free(c->last_frame);
     c->last_frame = NULL;
-
+#ifdef HAVE_CELT051
     if (c->celt_encoder) {
         celt051_encoder_destroy(c->celt_encoder);
         c->celt_encoder = NULL;
@@ -185,7 +192,7 @@
         celt051_mode_destroy(c->celt_mode);
         c->celt_mode = NULL;
     }
-
+#endif
     SPICE_CHANNEL_CLASS(spice_record_channel_parent_class)->channel_reset(channel, migrating);
 }
 
@@ -324,12 +331,13 @@
     SpiceRecordChannelPrivate *rc;
 
     rc = SPICE_RECORD_CHANNEL(channel)->priv;
+    rc->mode = SPICE_AUDIO_DATA_MODE_RAW;
+#ifdef HAVE_CELT051
     if (!g_getenv("SPICE_DISABLE_CELT") &&
         spice_channel_test_capability(channel, SPICE_RECORD_CAP_CELT_0_5_1)) {
         rc->mode = SPICE_AUDIO_DATA_MODE_CELT_0_5_1;
-    } else {
-        rc->mode = SPICE_AUDIO_DATA_MODE_RAW;
     }
+#endif
 }
 
 /* main context */
@@ -363,9 +371,10 @@
 {
     SpiceRecordChannelPrivate *rc;
     SpiceMsgcRecordPacket p = {0, };
+#ifdef HAVE_CELT051
     int celt_compressed_frame_bytes = FRAME_SIZE * CELT_BIT_RATE / 44100 / 8;
     uint8_t *celt_buf = NULL;
-
+#endif
     g_return_if_fail(channel != NULL);
     g_return_if_fail(spice_channel_get_read_only(SPICE_CHANNEL(channel)) == FALSE);
 
@@ -376,10 +385,10 @@
         spice_record_start_mark(channel, time);
         rc->started = TRUE;
     }
-
+#ifdef HAVE_CELT051
     if (rc->mode == SPICE_AUDIO_DATA_MODE_CELT_0_5_1)
         celt_buf = g_alloca(celt_compressed_frame_bytes);
-
+#endif
     p.time = time;
 
     while (bytes > 0) {
@@ -411,7 +420,7 @@
             rc->last_frame_current = n;
             break;
         }
-
+#ifdef HAVE_CELT051
         if (rc->mode == SPICE_AUDIO_DATA_MODE_CELT_0_5_1) {
             frame_size = celt051_encode(rc->celt_encoder, (celt_int16_t *)frame, NULL, celt_buf,
                                celt_compressed_frame_bytes);
@@ -421,7 +430,7 @@
             }
             frame = celt_buf;
         }
-
+#endif
         msg = spice_msg_out_new(SPICE_CHANNEL(channel), SPICE_MSGC_RECORD_DATA);
         msg->marshallers->msgc_record_data(msg->marshaller, &p);
         spice_marshaller_add(msg->marshaller, frame, frame_size);
@@ -457,6 +466,7 @@
         emit_main_context(channel, SPICE_RECORD_START,
                           start->format, start->channels, start->frequency);
         break;
+#ifdef HAVE_CELT051
     case SPICE_AUDIO_DATA_MODE_CELT_0_5_1: {
         int celt_mode_err;
 
@@ -478,6 +488,7 @@
                           start->format, start->channels, start->frequency);
         break;
     }
+#endif
     default:
         g_warning("%s: unhandled mode %d", __FUNCTION__, c->mode);
         break;
