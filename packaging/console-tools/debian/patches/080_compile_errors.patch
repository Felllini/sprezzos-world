diff -ruN console-tools-0.2.3-old/contrib/codepage.c console-tools-0.2.3/contrib/codepage.c
--- console-tools-0.2.3-old/contrib/codepage.c	1999-04-08 22:29:41.000000000 +0100
+++ console-tools-0.2.3/contrib/codepage.c	2003-05-22 12:10:12.000000000 +0100
@@ -227,9 +227,8 @@
 	if (optc)
 	  return 0;
 
-        fprintf(stderr, "\
-Warning: CP format is a hack!\n
-         The files produced may or may not be usable!\n");
+        fprintf(stderr, "\n Warning: CP format is a hack!\n"
+         "The files produced may or may not be usable!\n");
 
 	sprintf(outfile, "%d.cp", CPEntryHeader.codepage);
 	if ((out = fopen(outfile, "w")) == NULL) {
diff -ruN console-tools-0.2.3-old/contrib/splitfont.c console-tools-0.2.3/contrib/splitfont.c
--- console-tools-0.2.3-old/contrib/splitfont.c	1999-04-08 22:29:41.000000000 +0100
+++ console-tools-0.2.3/contrib/splitfont.c	2003-05-22 15:16:10.000000000 +0100
@@ -1,7 +1,9 @@
 /* splitfont: extract characters from font */
 /* this is for iso fonts, no psf header, just 256 characters */
 
+#include <string.h>
 #include <stdio.h>
+#include <stdlib.h>
 #include <fcntl.h>
 #include <unistd.h>
 #include <sys/stat.h>
@@ -9,12 +11,12 @@
 void
 dosplit (int from, int to, char *fontbuf, int size, char *fontfile) {
 	int itemsize = size/256;
-	int i, fd;
-	char *p, *q, s;
+	int fd;
+	char *p;
 	char filename[4096];
 
 	if (from < 0 || from > 255 || to < 0 || to > 255) {
-		fprintf(stderr, "splitfont: bad argument %s,%s\n",
+		fprintf(stderr, "splitfont: bad argument %d,%d\n",
 			from, to);
 		exit(1);
 	}
diff -ruN console-tools-0.2.3-old/kbdtools/analyze.c console-tools-0.2.3/kbdtools/analyze.c
--- console-tools-0.2.3-old/kbdtools/analyze.c	1999-04-15 01:34:52.000000000 +0100
+++ console-tools-0.2.3/kbdtools/analyze.c	2003-05-22 12:09:06.000000000 +0100
@@ -9,7 +9,7 @@
 #define YY_FLEX_MINOR_VERSION 5
 
 #include <stdio.h>
-
+#include <errno.h>
 
 /* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
 #ifdef c_plusplus
@@ -22,7 +22,9 @@
 #ifdef __cplusplus
 
 #include <stdlib.h>
+#ifndef _WIN32
 #include <unistd.h>
+#endif
 
 /* Use prototypes in function declarations. */
 #define YY_USE_PROTOS
@@ -704,7 +706,7 @@
 
 #define INCLSTR 3
 
-#line 708 "lex.yy.c"
+#line 710 "lex.yy.c"
 
 /* Macros after this point can all be overridden by user definitions in
  * section 1.
@@ -804,9 +806,20 @@
 			YY_FATAL_ERROR( "input in flex scanner failed" ); \
 		result = n; \
 		} \
-	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
-		  && ferror( yyin ) ) \
-		YY_FATAL_ERROR( "input in flex scanner failed" );
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(yyin); \
+			} \
+		}
 #endif
 
 /* No semi-colon after return; correct usage is to write "yyterminate();" -
@@ -857,7 +870,7 @@
 
 #line 66 "analyze.l"
 
-#line 861 "lex.yy.c"
+#line 874 "lex.yy.c"
 
 	if ( yy_init )
 		{
@@ -1190,7 +1203,7 @@
 #line 125 "analyze.l"
 ECHO;
 	YY_BREAK
-#line 1194 "lex.yy.c"
+#line 1207 "lex.yy.c"
 case YY_STATE_EOF(INITIAL):
 case YY_STATE_EOF(RVALUE):
 case YY_STATE_EOF(STR):
@@ -1757,11 +1770,15 @@
 	}
 
 
+#ifndef _WIN32
+#include <unistd.h>
+#else
 #ifndef YY_ALWAYS_INTERACTIVE
 #ifndef YY_NEVER_INTERACTIVE
 extern int isatty YY_PROTO(( int ));
 #endif
 #endif
+#endif
 
 #ifdef YY_USE_PROTOS
 void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
@@ -2207,7 +2224,7 @@
       while(ev)
 	{
 	  char *t = index((const char*)ev, ':');
-	  char sv;
+	  char sv = 0; /* initialise to silence compiler */
 	  if (t)
 	    {
 	      sv = *t;
diff -ruN console-tools-0.2.3-old/kbdtools/analyze.l console-tools-0.2.3/kbdtools/analyze.l
--- console-tools-0.2.3-old/kbdtools/analyze.l	1999-04-08 22:29:40.000000000 +0100
+++ console-tools-0.2.3/kbdtools/analyze.l	2003-05-22 15:13:45.000000000 +0100
@@ -1,5 +1,7 @@
 %{
 #include <stdlib.h>
+#include <string.h>
+#include <errno.h>
 #include <linux/kd.h>
 #include <lct/utils.h>
 #include "loadkeys.h"
@@ -249,7 +251,7 @@
       while(ev)
 	{
 	  char *t = index((const char*)ev, ':');
-	  char sv;
+	  char sv = 0; /* initialise to silence compiler */
 	  if (t)
 	    {
 	      sv = *t;
diff -ruN console-tools-0.2.3-old/kbdtools/getkeycodes.c console-tools-0.2.3/kbdtools/getkeycodes.c
--- console-tools-0.2.3-old/kbdtools/getkeycodes.c	1999-04-08 23:11:12.000000000 +0100
+++ console-tools-0.2.3/kbdtools/getkeycodes.c	2003-05-22 12:09:06.000000000 +0100
@@ -25,7 +25,7 @@
   OPT("-V --version      ", VERSIONDESC);
 }
 
-void main(int argc, char **argv) 
+int main(int argc, char **argv) 
 {
   int fd, sc;
   struct kbkeycode a;
diff -ruN console-tools-0.2.3-old/kbdtools/kbd_mode.c console-tools-0.2.3/kbdtools/kbd_mode.c
--- console-tools-0.2.3-old/kbdtools/kbd_mode.c	1999-04-08 23:11:12.000000000 +0100
+++ console-tools-0.2.3/kbdtools/kbd_mode.c	2003-05-22 12:11:24.000000000 +0100
@@ -12,6 +12,7 @@
 #include <linux/kd.h>
 #include <getopt.h>
 
+#include <stdlib.h>
 #include <lct/local.h>
 #include <lct/utils.h>
 #include <lct/console.h>
diff -ruN console-tools-0.2.3-old/kbdtools/kbdrate.c console-tools-0.2.3/kbdtools/kbdrate.c
--- console-tools-0.2.3-old/kbdtools/kbdrate.c	2003-05-22 12:09:06.000000000 +0100
+++ console-tools-0.2.3/kbdtools/kbdrate.c	2003-05-22 15:15:27.000000000 +0100
@@ -71,6 +71,7 @@
 #include <stdio.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <string.h>
 #include <errno.h>
 #include <sys/file.h>
 #include <sys/ioctl.h>
@@ -83,6 +84,7 @@
 #endif
 
 #include <lct/local.h>
+#include <lct/utils.h>
 
 #ifdef __sparc__
 #include <asm/param.h>
diff -ruN console-tools-0.2.3-old/kbdtools/loadkeys.c console-tools-0.2.3/kbdtools/loadkeys.c
--- console-tools-0.2.3-old/kbdtools/loadkeys.c	1999-07-19 20:50:34.000000000 +0100
+++ console-tools-0.2.3/kbdtools/loadkeys.c	2003-05-22 12:09:06.000000000 +0100
@@ -1,43 +1,126 @@
+/* A Bison parser, made from loadkeys.y, by GNU bison 1.75.  */
 
-/*  A Bison parser, made from loadkeys.y
- by  GNU Bison version 1.27
-  */
-
-#define YYBISON 1  /* Identify Bison output.  */
-
-#define	EOL	257
-#define	NUMBER	258
-#define	LITERAL	259
-#define	CHARSET	260
-#define	KEYMAPS	261
-#define	KEYCODE	262
-#define	EQUALS	263
-#define	PLAIN	264
-#define	SHIFT	265
-#define	CONTROL	266
-#define	ALT	267
-#define	ALTGR	268
-#define	SHIFTL	269
-#define	SHIFTR	270
-#define	CTRLL	271
-#define	CTRLR	272
-#define	COMMA	273
-#define	DASH	274
-#define	STRING	275
-#define	STRLITERAL	276
-#define	COMPOSE	277
-#define	TO	278
-#define	CCHAR	279
-#define	ERROR	280
-#define	PLUS	281
-#define	UNUMBER	282
-#define	ALT_IS_META	283
-#define	STRINGS	284
-#define	AS	285
-#define	USUAL	286
-#define	ON	287
-#define	FOR	288
+/* Skeleton parser for Yacc-like parsing with Bison,
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002 Free Software Foundation, Inc.
 
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* As a special exception, when this file is copied by Bison into a
+   Bison output file, you may use that output file without restriction.
+   This special exception was added by the Free Software Foundation
+   in version 1.24 of Bison.  */
+
+/* Written by Richard Stallman by simplifying the original so called
+   ``semantic'' parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON	1
+
+/* Pure parsers.  */
+#define YYPURE	0
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     EOL = 258,
+     NUMBER = 259,
+     LITERAL = 260,
+     CHARSET = 261,
+     KEYMAPS = 262,
+     KEYCODE = 263,
+     EQUALS = 264,
+     PLAIN = 265,
+     SHIFT = 266,
+     CONTROL = 267,
+     ALT = 268,
+     ALTGR = 269,
+     SHIFTL = 270,
+     SHIFTR = 271,
+     CTRLL = 272,
+     CTRLR = 273,
+     COMMA = 274,
+     DASH = 275,
+     STRING = 276,
+     STRLITERAL = 277,
+     COMPOSE = 278,
+     TO = 279,
+     CCHAR = 280,
+     ERROR = 281,
+     PLUS = 282,
+     UNUMBER = 283,
+     ALT_IS_META = 284,
+     STRINGS = 285,
+     AS = 286,
+     USUAL = 287,
+     ON = 288,
+     FOR = 289
+   };
+#endif
+#define EOL 258
+#define NUMBER 259
+#define LITERAL 260
+#define CHARSET 261
+#define KEYMAPS 262
+#define KEYCODE 263
+#define EQUALS 264
+#define PLAIN 265
+#define SHIFT 266
+#define CONTROL 267
+#define ALT 268
+#define ALTGR 269
+#define SHIFTL 270
+#define SHIFTR 271
+#define CTRLL 272
+#define CTRLR 273
+#define COMMA 274
+#define DASH 275
+#define STRING 276
+#define STRLITERAL 277
+#define COMPOSE 278
+#define TO 279
+#define CCHAR 280
+#define ERROR 281
+#define PLUS 282
+#define UNUMBER 283
+#define ALT_IS_META 284
+#define STRINGS 285
+#define AS 286
+#define USUAL 287
+#define ON 288
+#define FOR 289
+
+
+
+
+/* Copy the first part of user declarations.  */
 #line 62 "loadkeys.y"
 
 #include <errno.h>
@@ -85,7 +168,7 @@
 /* What keymaps are we defining? */
 char defining[MAX_NR_KEYMAPS];
 char keymaps_line_seen = 0;
-int max_keymap = 0;		/* from here on, defining[] is false */
+int max_keymap = 0;		/* from here on, defining is false */
 int alt_is_meta = 0;
 
 /* the kernel structures we want to set or print */
@@ -113,9 +196,6 @@
 static void loadkeys(void);
 static void mktable(void);
 static void strings_as_usual(void);
-static void keypad_as_usual(char *keyboard);
-static void function_keys_as_usual(char *keyboard);
-static void consoles_as_usual(char *keyboard);
 static void compose_as_usual(char *charset);
 void lkfatal(char *);
 void lkfatal0(char *, int);
@@ -125,402 +205,608 @@
 int mod;
 int unicode_used;
 int private_error_ct = 0;
-#ifndef YYSTYPE
-#define YYSTYPE int
-#endif
-#include <stdio.h>
 
-#ifndef __cplusplus
-#ifndef __STDC__
-#define const
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
 #endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
 #endif
 
+#ifndef YYSTYPE
+typedef int yystype;
+# define YYSTYPE yystype
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+
+#ifndef YYLTYPE
+typedef struct yyltype
+{
+  int first_line;
+  int first_column;
+  int last_line;
+  int last_column;
+} yyltype;
+# define YYLTYPE yyltype
+# define YYLTYPE_IS_TRIVIAL 1
+#endif
+
+/* Copy the second part of user declarations.  */
+
+
+/* Line 213 of /usr/share/bison/yacc.c.  */
+#line 246 "y.tab.c"
+
+#if ! defined (yyoverflow) || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# if YYSTACK_USE_ALLOCA
+#  define YYSTACK_ALLOC alloca
+# else
+#  ifndef YYSTACK_USE_ALLOCA
+#   if defined (alloca) || defined (_ALLOCA_H)
+#    define YYSTACK_ALLOC alloca
+#   else
+#    ifdef __GNUC__
+#     define YYSTACK_ALLOC __builtin_alloca
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning. */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
+# else
+#  if defined (__STDC__) || defined (__cplusplus)
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   define YYSIZE_T size_t
+#  endif
+#  define YYSTACK_ALLOC malloc
+#  define YYSTACK_FREE free
+# endif
+#endif /* ! defined (yyoverflow) || YYERROR_VERBOSE */
+
+
+#if (! defined (yyoverflow) \
+     && (! defined (__cplusplus) \
+	 || (YYLTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
 
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  short yyss;
+  YYSTYPE yyvs;
+  };
 
-#define	YYFINAL		88
-#define	YYFLAG		-32768
-#define	YYNTBASE	35
-
-#define YYTRANSLATE(x) ((unsigned)(x) <= 288 ? yytranslate[x] : 54)
-
-static const char yytranslate[] = {     0,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,
-     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,
-    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
-    27,    28,    29,    30,    31,    32,    33,    34
-};
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAX (sizeof (union yyalloc) - 1)
 
-#if YYDEBUG != 0
-static const short yyprhs[] = {     0,
-     0,     1,     4,     6,     8,    10,    12,    14,    16,    18,
-    20,    22,    24,    28,    31,    36,    43,    48,    52,    56,
-    58,    62,    64,    70,    77,    84,    85,    93,   100,   103,
-   105,   107,   109,   111,   113,   115,   117,   119,   121,   127,
-   128,   131,   133,   135,   137,   140,   142
-};
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (short) + sizeof (YYSTYPE))				\
+      + YYSTACK_GAP_MAX)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  register YYSIZE_T yyi;		\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];	\
+	}					\
+      while (0)
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack)					\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack, Stack, yysize);				\
+	Stack = &yyptr->Stack;						\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAX;	\
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (0)
 
-static const short yyrhs[] = {    -1,
-    35,    36,     0,     3,     0,    37,     0,    38,     0,    39,
-     0,    40,     0,    41,     0,    50,     0,    46,     0,    44,
-     0,    45,     0,     6,    22,     3,     0,    29,     3,     0,
-    30,    31,    32,     3,     0,    23,    31,    32,    34,    22,
-     3,     0,    23,    31,    32,     3,     0,     7,    42,     3,
-     0,    42,    19,    43,     0,    43,     0,     4,    20,     4,
-     0,     4,     0,    21,     5,     9,    22,     3,     0,    23,
-    25,    25,    24,    25,     3,     0,    23,    25,    25,    24,
-    53,     3,     0,     0,    47,    48,     8,     4,     9,    53,
-     3,     0,    10,     8,     4,     9,    53,     3,     0,    48,
-    49,     0,    49,     0,    11,     0,    12,     0,    13,     0,
-    14,     0,    15,     0,    16,     0,    17,     0,    18,     0,
-     8,     4,     9,    51,     3,     0,     0,    52,    51,     0,
-    53,     0,     4,     0,    28,     0,    27,     4,     0,     5,
-     0,    27,     5,     0
-};
+#endif
 
+#if defined (__STDC__) || defined (__cplusplus)
+   typedef signed char yysigned_char;
+#else
+   typedef short yysigned_char;
 #endif
 
-#if YYDEBUG != 0
-static const short yyrline[] = { 0,
-   151,   152,   154,   155,   156,   157,   158,   159,   160,   161,
-   162,   163,   165,   170,   175,   180,   184,   189,   194,   195,
-   197,   203,   208,   217,   221,   226,   227,   231,   236,   237,
-   239,   240,   241,   242,   243,   244,   245,   246,   248,   281,
-   282,   284,   291,   293,   295,   297,   299
+/* YYFINAL -- State number of the termination state. */
+#define YYFINAL  2
+#define YYLAST   79
+
+/* YYNTOKENS -- Number of terminals. */
+#define YYNTOKENS  35
+/* YYNNTS -- Number of nonterminals. */
+#define YYNNTS  20
+/* YYNRULES -- Number of rules. */
+#define YYNRULES  48
+/* YYNRULES -- Number of states. */
+#define YYNSTATES  88
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   289
+
+#define YYTRANSLATE(X) \
+  ((unsigned)(X) <= YYMAXUTOK ? yytranslate[X] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const unsigned char yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34
 };
-#endif
 
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const unsigned char yyprhs[] =
+{
+       0,     0,     3,     4,     7,     9,    11,    13,    15,    17,
+      19,    21,    23,    25,    27,    31,    34,    39,    46,    51,
+      55,    59,    61,    65,    67,    73,    80,    87,    88,    96,
+     103,   106,   108,   110,   112,   114,   116,   118,   120,   122,
+     124,   130,   131,   134,   136,   138,   140,   143,   145
+};
 
-#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)
+/* YYRHS -- A `-1'-separated list of the rules' RHS. */
+static const yysigned_char yyrhs[] =
+{
+      36,     0,    -1,    -1,    36,    37,    -1,     3,    -1,    38,
+      -1,    39,    -1,    40,    -1,    41,    -1,    42,    -1,    51,
+      -1,    47,    -1,    45,    -1,    46,    -1,     6,    22,     3,
+      -1,    29,     3,    -1,    30,    31,    32,     3,    -1,    23,
+      31,    32,    34,    22,     3,    -1,    23,    31,    32,     3,
+      -1,     7,    43,     3,    -1,    43,    19,    44,    -1,    44,
+      -1,     4,    20,     4,    -1,     4,    -1,    21,     5,     9,
+      22,     3,    -1,    23,    25,    25,    24,    25,     3,    -1,
+      23,    25,    25,    24,    54,     3,    -1,    -1,    48,    49,
+       8,     4,     9,    54,     3,    -1,    10,     8,     4,     9,
+      54,     3,    -1,    49,    50,    -1,    50,    -1,    11,    -1,
+      12,    -1,    13,    -1,    14,    -1,    15,    -1,    16,    -1,
+      17,    -1,    18,    -1,     8,     4,     9,    52,     3,    -1,
+      -1,    53,    52,    -1,    54,    -1,     4,    -1,    28,    -1,
+      27,     4,    -1,     5,    -1,    27,     5,    -1
+};
 
-static const char * const yytname[] = {   "$","error","$undefined.","EOL","NUMBER",
-"LITERAL","CHARSET","KEYMAPS","KEYCODE","EQUALS","PLAIN","SHIFT","CONTROL","ALT",
-"ALTGR","SHIFTL","SHIFTR","CTRLL","CTRLR","COMMA","DASH","STRING","STRLITERAL",
-"COMPOSE","TO","CCHAR","ERROR","PLUS","UNUMBER","ALT_IS_META","STRINGS","AS",
-"USUAL","ON","FOR","keytable","line","charsetline","altismetaline","usualstringsline",
-"usualcomposeline","keymapline","range","range0","strline","compline","singleline",
-"@1","modifiers","modifier","fullline","rvalue0","rvalue1","rvalue", NULL
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const unsigned short yyrline[] =
+{
+       0,   148,   148,   149,   151,   152,   153,   154,   155,   156,
+     157,   158,   159,   160,   162,   167,   172,   177,   181,   186,
+     191,   192,   194,   200,   205,   214,   218,   223,   223,   228,
+     233,   234,   236,   237,   238,   239,   240,   241,   242,   243,
+     245,   278,   279,   281,   288,   290,   292,   294,   296
 };
 #endif
 
-static const short yyr1[] = {     0,
-    35,    35,    36,    36,    36,    36,    36,    36,    36,    36,
-    36,    36,    37,    38,    39,    40,    40,    41,    42,    42,
-    43,    43,    44,    45,    45,    47,    46,    46,    48,    48,
-    49,    49,    49,    49,    49,    49,    49,    49,    50,    51,
-    51,    52,    53,    53,    53,    53,    53
+#if YYDEBUG || YYERROR_VERBOSE
+/* YYTNME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals. */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "EOL", "NUMBER", "LITERAL", "CHARSET", 
+  "KEYMAPS", "KEYCODE", "EQUALS", "PLAIN", "SHIFT", "CONTROL", "ALT", 
+  "ALTGR", "SHIFTL", "SHIFTR", "CTRLL", "CTRLR", "COMMA", "DASH", 
+  "STRING", "STRLITERAL", "COMPOSE", "TO", "CCHAR", "ERROR", "PLUS", 
+  "UNUMBER", "ALT_IS_META", "STRINGS", "AS", "USUAL", "ON", "FOR", 
+  "$accept", "keytable", "line", "charsetline", "altismetaline", 
+  "usualstringsline", "usualcomposeline", "keymapline", "range", "range0", 
+  "strline", "compline", "singleline", "@1", "modifiers", "modifier", 
+  "fullline", "rvalue0", "rvalue1", "rvalue", 0
 };
+#endif
 
-static const short yyr2[] = {     0,
-     0,     2,     1,     1,     1,     1,     1,     1,     1,     1,
-     1,     1,     3,     2,     4,     6,     4,     3,     3,     1,
-     3,     1,     5,     6,     6,     0,     7,     6,     2,     1,
-     1,     1,     1,     1,     1,     1,     1,     1,     5,     0,
-     2,     1,     1,     1,     2,     1,     2
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const unsigned short yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+     285,   286,   287,   288,   289
 };
+# endif
 
-static const short yydefact[] = {     1,
-    26,     3,     0,     0,     0,     0,     0,     0,     0,     0,
-     2,     4,     5,     6,     7,     8,    11,    12,    10,     0,
-     9,     0,    22,     0,    20,     0,     0,     0,     0,     0,
-    14,     0,    31,    32,    33,    34,    35,    36,    37,    38,
-     0,    30,    13,     0,    18,     0,    40,     0,     0,     0,
-     0,     0,     0,    29,    21,    19,    43,    46,     0,    44,
-     0,    40,    42,     0,     0,     0,    17,     0,    15,     0,
-    45,    47,    39,    41,     0,    23,     0,     0,     0,     0,
-    28,    24,    25,    16,     0,    27,     0,     0
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const unsigned char yyr1[] =
+{
+       0,    35,    36,    36,    37,    37,    37,    37,    37,    37,
+      37,    37,    37,    37,    38,    39,    40,    41,    41,    42,
+      43,    43,    44,    44,    45,    46,    46,    48,    47,    47,
+      49,    49,    50,    50,    50,    50,    50,    50,    50,    50,
+      51,    52,    52,    53,    54,    54,    54,    54,    54
 };
 
-static const short yydefgoto[] = {     1,
-    11,    12,    13,    14,    15,    16,    24,    25,    17,    18,
-    19,    20,    41,    42,    21,    61,    62,    63
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const unsigned char yyr2[] =
+{
+       0,     2,     0,     2,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     1,     3,     2,     4,     6,     4,     3,
+       3,     1,     3,     1,     5,     6,     6,     0,     7,     6,
+       2,     1,     1,     1,     1,     1,     1,     1,     1,     1,
+       5,     0,     2,     1,     1,     1,     2,     1,     2
 };
 
-static const short yypact[] = {-32768,
-     3,-32768,   -15,     8,    12,    11,    18,   -23,    26,    -1,
--32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,    36,
--32768,    32,    35,    -2,-32768,    47,    53,    49,    34,    29,
--32768,    30,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-    28,-32768,-32768,    56,-32768,     8,    10,    54,    42,    41,
-    -3,    63,    64,-32768,-32768,-32768,-32768,-32768,    17,-32768,
-    66,    10,-32768,    10,    67,     0,-32768,    45,-32768,    62,
--32768,-32768,-32768,-32768,    69,-32768,    70,    71,    72,    10,
--32768,-32768,-32768,-32768,    73,-32768,    77,-32768
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const unsigned char yydefact[] =
+{
+       2,    27,     1,     4,     0,     0,     0,     0,     0,     0,
+       0,     0,     3,     5,     6,     7,     8,     9,    12,    13,
+      11,     0,    10,     0,    23,     0,    21,     0,     0,     0,
+       0,     0,    15,     0,    32,    33,    34,    35,    36,    37,
+      38,    39,     0,    31,    14,     0,    19,     0,    41,     0,
+       0,     0,     0,     0,     0,    30,    22,    20,    44,    47,
+       0,    45,     0,    41,    43,     0,     0,     0,    18,     0,
+      16,     0,    46,    48,    40,    42,     0,    24,     0,     0,
+       0,     0,    29,    25,    26,    17,     0,    28
 };
 
-static const short yypgoto[] = {-32768,
--32768,-32768,-32768,-32768,-32768,-32768,-32768,    33,-32768,-32768,
--32768,-32768,-32768,    37,-32768,    19,-32768,   -46
+/* YYDEFGOTO[NTERM-NUM]. */
+static const yysigned_char yydefgoto[] =
+{
+      -1,     1,    12,    13,    14,    15,    16,    17,    25,    26,
+      18,    19,    20,    21,    42,    43,    22,    62,    63,    64
 };
 
-
-#define	YYLAST		81
-
-
-static const short yytable[] = {    67,
-    45,    29,    87,    57,    58,     2,    22,    30,     3,     4,
-     5,    23,     6,    57,    58,    26,    46,    75,    27,    78,
-    71,    72,    28,     7,    77,     8,    59,    60,    31,    32,
-    68,     9,    10,    85,    43,    53,    59,    60,    33,    34,
-    35,    36,    37,    38,    39,    40,    33,    34,    35,    36,
-    37,    38,    39,    40,    44,    47,    48,    49,    50,    55,
-    51,    52,    64,    65,    66,    69,    79,    70,    73,    76,
-    80,    81,    82,    83,    84,    86,    88,    54,    56,     0,
-    74
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -48
+static const yysigned_char yypact[] =
+{
+     -48,     3,   -48,   -48,   -15,     8,    12,    11,    18,   -23,
+      26,    -1,   -48,   -48,   -48,   -48,   -48,   -48,   -48,   -48,
+     -48,    36,   -48,    32,    35,    -2,   -48,    47,    53,    49,
+      34,    29,   -48,    30,   -48,   -48,   -48,   -48,   -48,   -48,
+     -48,   -48,    28,   -48,   -48,    56,   -48,     8,    10,    54,
+      42,    41,    -3,    63,    64,   -48,   -48,   -48,   -48,   -48,
+      17,   -48,    66,    10,   -48,    10,    67,     0,   -48,    45,
+     -48,    62,   -48,   -48,   -48,   -48,    69,   -48,    70,    71,
+      72,    10,   -48,   -48,   -48,   -48,    73,   -48
 };
 
-static const short yycheck[] = {     3,
-     3,    25,     0,     4,     5,     3,    22,    31,     6,     7,
-     8,     4,    10,     4,     5,     4,    19,    64,     8,    66,
-     4,     5,     5,    21,    25,    23,    27,    28,     3,    31,
-    34,    29,    30,    80,     3,     8,    27,    28,    11,    12,
-    13,    14,    15,    16,    17,    18,    11,    12,    13,    14,
-    15,    16,    17,    18,    20,     9,     4,     9,    25,     4,
-    32,    32,     9,    22,    24,     3,    22,     4,     3,     3,
-     9,     3,     3,     3,     3,     3,     0,    41,    46,    -1,
-    62
+/* YYPGOTO[NTERM-NUM].  */
+static const yysigned_char yypgoto[] =
+{
+     -48,   -48,   -48,   -48,   -48,   -48,   -48,   -48,   -48,    31,
+     -48,   -48,   -48,   -48,   -48,    37,   -48,    14,   -48,   -47
 };
-/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
-#line 3 "/usr/share/misc/bison.simple"
-/* This file comes from bison-1.27.  */
-
-/* Skeleton output parser for bison,
-   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
 
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, parse error.  */
+#define YYTABLE_NINF -1
+static const unsigned char yytable[] =
+{
+      68,    46,    30,     2,    58,    59,     3,    23,    31,     4,
+       5,     6,    24,     7,    58,    59,    27,    47,    76,    28,
+      79,    72,    73,    29,     8,    78,     9,    60,    61,    32,
+      33,    69,    10,    11,    86,    44,    54,    60,    61,    34,
+      35,    36,    37,    38,    39,    40,    41,    34,    35,    36,
+      37,    38,    39,    40,    41,    45,    48,    49,    50,    51,
+      56,    52,    53,    65,    66,    67,    70,    80,    71,    74,
+      77,    81,    82,    83,    84,    85,    87,    75,    57,    55
+};
 
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
+static const unsigned char yycheck[] =
+{
+       3,     3,    25,     0,     4,     5,     3,    22,    31,     6,
+       7,     8,     4,    10,     4,     5,     4,    19,    65,     8,
+      67,     4,     5,     5,    21,    25,    23,    27,    28,     3,
+      31,    34,    29,    30,    81,     3,     8,    27,    28,    11,
+      12,    13,    14,    15,    16,    17,    18,    11,    12,    13,
+      14,    15,    16,    17,    18,    20,     9,     4,     9,    25,
+       4,    32,    32,     9,    22,    24,     3,    22,     4,     3,
+       3,     9,     3,     3,     3,     3,     3,    63,    47,    42
+};
 
-/* This is the parser code that is written into each bison parser
-  when the %semantic_parser declaration is not specified in the grammar.
-  It was written by Richard Stallman by simplifying the hairy parser
-  used when %semantic_parser is specified.  */
-
-#ifndef YYSTACK_USE_ALLOCA
-#ifdef alloca
-#define YYSTACK_USE_ALLOCA
-#else /* alloca not defined */
-#ifdef __GNUC__
-#define YYSTACK_USE_ALLOCA
-#define alloca __builtin_alloca
-#else /* not GNU C.  */
-#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))
-#define YYSTACK_USE_ALLOCA
-#include <alloca.h>
-#else /* not sparc */
-/* We think this test detects Watcom and Microsoft C.  */
-/* This used to test MSDOS, but that is a bad idea
-   since that symbol is in the user namespace.  */
-#if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)
-#if 0 /* No need for malloc.h, which pollutes the namespace;
-	 instead, just don't use alloca.  */
-#include <malloc.h>
-#endif
-#else /* not MSDOS, or __TURBOC__ */
-#if defined(_AIX)
-/* I don't know what this was needed for, but it pollutes the namespace.
-   So I turned it off.   rms, 2 May 1997.  */
-/* #include <malloc.h>  */
- #pragma alloca
-#define YYSTACK_USE_ALLOCA
-#else /* not MSDOS, or __TURBOC__, or _AIX */
-#if 0
-#ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,
-		 and on HPUX 10.  Eventually we can turn this on.  */
-#define YYSTACK_USE_ALLOCA
-#define alloca __builtin_alloca
-#endif /* __hpux */
-#endif
-#endif /* not _AIX */
-#endif /* not MSDOS, or __TURBOC__ */
-#endif /* not sparc */
-#endif /* not GNU C */
-#endif /* alloca not defined */
-#endif /* YYSTACK_USE_ALLOCA not defined */
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const unsigned char yystos[] =
+{
+       0,    36,     0,     3,     6,     7,     8,    10,    21,    23,
+      29,    30,    37,    38,    39,    40,    41,    42,    45,    46,
+      47,    48,    51,    22,     4,    43,    44,     4,     8,     5,
+      25,    31,     3,    31,    11,    12,    13,    14,    15,    16,
+      17,    18,    49,    50,     3,    20,     3,    19,     9,     4,
+       9,    25,    32,    32,     8,    50,     4,    44,     4,     5,
+      27,    28,    52,    53,    54,     9,    22,    24,     3,    34,
+       3,     4,     4,     5,     3,    52,    54,     3,    25,    54,
+      22,     9,     3,     3,     3,     3,    54,     3
+};
 
-#ifdef YYSTACK_USE_ALLOCA
-#define YYSTACK_ALLOC alloca
-#else
-#define YYSTACK_ALLOC malloc
+#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
+# define YYSIZE_T __SIZE_TYPE__
+#endif
+#if ! defined (YYSIZE_T) && defined (size_t)
+# define YYSIZE_T size_t
+#endif
+#if ! defined (YYSIZE_T)
+# if defined (__STDC__) || defined (__cplusplus)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# endif
+#endif
+#if ! defined (YYSIZE_T)
+# define YYSIZE_T unsigned int
 #endif
-
-/* Note: there must be only one dollar sign in this file.
-   It is replaced by the list of actions, each action
-   as one case of the switch.  */
 
 #define yyerrok		(yyerrstatus = 0)
 #define yyclearin	(yychar = YYEMPTY)
 #define YYEMPTY		-2
 #define YYEOF		0
+
 #define YYACCEPT	goto yyacceptlab
-#define YYABORT 	goto yyabortlab
+#define YYABORT		goto yyabortlab
 #define YYERROR		goto yyerrlab1
-/* Like YYERROR except do call yyerror.
-   This remains here temporarily to ease the
-   transition to the new meaning of YYERROR, for GCC.
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
    Once GCC version 2 has supplanted version 1, this can go.  */
+
 #define YYFAIL		goto yyerrlab
+
 #define YYRECOVERING()  (!!yyerrstatus)
-#define YYBACKUP(token, value) \
+
+#define YYBACKUP(Token, Value)					\
 do								\
   if (yychar == YYEMPTY && yylen == 1)				\
-    { yychar = (token), yylval = (value);			\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
       yychar1 = YYTRANSLATE (yychar);				\
       YYPOPSTACK;						\
       goto yybackup;						\
     }								\
   else								\
-    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
+    { 								\
+      yyerror ("syntax error: cannot back up");			\
+      YYERROR;							\
+    }								\
 while (0)
 
 #define YYTERROR	1
 #define YYERRCODE	256
 
-#ifndef YYPURE
-#define YYLEX		yylex()
-#endif
+/* YYLLOC_DEFAULT -- Compute the default location (before the actions
+   are run).  */
 
-#ifdef YYPURE
-#ifdef YYLSP_NEEDED
-#ifdef YYLEX_PARAM
-#define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
-#else
-#define YYLEX		yylex(&yylval, &yylloc)
-#endif
-#else /* not YYLSP_NEEDED */
-#ifdef YYLEX_PARAM
-#define YYLEX		yylex(&yylval, YYLEX_PARAM)
-#else
-#define YYLEX		yylex(&yylval)
-#endif
-#endif /* not YYLSP_NEEDED */
-#endif
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)           \
+  Current.first_line   = Rhs[1].first_line;      \
+  Current.first_column = Rhs[1].first_column;    \
+  Current.last_line    = Rhs[N].last_line;       \
+  Current.last_column  = Rhs[N].last_column;
+#endif
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#define YYLEX	yylex ()
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (0)
+# define YYDSYMPRINT(Args)			\
+do {						\
+  if (yydebug)					\
+    yysymprint Args;				\
+} while (0)
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YYDSYMPRINT(Args)
+#endif /* !YYDEBUG */
 
-/* If nonreentrant, generate the variables here */
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
 
-#ifndef YYPURE
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
 
-int	yychar;			/*  the lookahead symbol		*/
-YYSTYPE	yylval;			/*  the semantic value of the		*/
-				/*  lookahead symbol			*/
+   Do not make this value too large; the results are undefined if
+   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
 
-#ifdef YYLSP_NEEDED
-YYLTYPE yylloc;			/*  location data for the lookahead	*/
-				/*  symbol				*/
+#if YYMAXDEPTH == 0
+# undef YYMAXDEPTH
 #endif
 
-int yynerrs;			/*  number of parse errors so far       */
-#endif  /* not YYPURE */
-
-#if YYDEBUG != 0
-int yydebug;			/*  nonzero means print parse trace	*/
-/* Since this is uninitialized, it does not stop multiple parsers
-   from coexisting.  */
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
 #endif
 
-/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/
+
 
-#ifndef	YYINITDEPTH
-#define YYINITDEPTH 200
-#endif
+#if YYERROR_VERBOSE
 
-/*  YYMAXDEPTH is the maximum size the stacks can grow to
-    (effective only if the built-in stack extension method is used).  */
+# ifndef yystrlen
+#  if defined (__GLIBC__) && defined (_STRING_H)
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+static YYSIZE_T
+#   if defined (__STDC__) || defined (__cplusplus)
+yystrlen (const char *yystr)
+#   else
+yystrlen (yystr)
+     const char *yystr;
+#   endif
+{
+  register const char *yys = yystr;
+
+  while (*yys++ != '\0')
+    continue;
+
+  return yys - yystr - 1;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+static char *
+#   if defined (__STDC__) || defined (__cplusplus)
+yystpcpy (char *yydest, const char *yysrc)
+#   else
+yystpcpy (yydest, yysrc)
+     char *yydest;
+     const char *yysrc;
+#   endif
+{
+  register char *yyd = yydest;
+  register const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
 
-#if YYMAXDEPTH == 0
-#undef YYMAXDEPTH
-#endif
+  return yyd - 1;
+}
+#  endif
+# endif
+
+#endif /* !YYERROR_VERBOSE */
 
-#ifndef YYMAXDEPTH
-#define YYMAXDEPTH 10000
-#endif
 
-/* Define __yy_memcpy.  Note that the size argument
-   should be passed with type unsigned int, because that is what the non-GCC
-   definitions require.  With GCC, __builtin_memcpy takes an arg
-   of type size_t, but it can handle unsigned int.  */
-
-#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
-#define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
-#else				/* not GNU C or C++ */
-#ifndef __cplusplus
 
-/* This is the most reliable way to avoid incompatibilities
-   in available built-in functions on various systems.  */
+#if YYDEBUG
+/*-----------------------------.
+| Print this symbol on YYOUT.  |
+`-----------------------------*/
+
 static void
-__yy_memcpy (to, from, count)
-     char *to;
-     char *from;
-     unsigned int count;
+#if defined (__STDC__) || defined (__cplusplus)
+yysymprint (FILE* yyout, int yytype, YYSTYPE yyvalue)
+#else
+yysymprint (yyout, yytype, yyvalue)
+    FILE* yyout;
+    int yytype;
+    YYSTYPE yyvalue;
+#endif
 {
-  register char *f = from;
-  register char *t = to;
-  register int i = count;
+  /* Pacify ``unused variable'' warnings.  */
+  (void) yyvalue;
+
+  if (yytype < YYNTOKENS)
+    {
+      YYFPRINTF (yyout, "token %s (", yytname[yytype]);
+# ifdef YYPRINT
+      YYPRINT (yyout, yytoknum[yytype], yyvalue);
+# endif
+    }
+  else
+    YYFPRINTF (yyout, "nterm %s (", yytname[yytype]);
 
-  while (i-- > 0)
-    *t++ = *f++;
+  switch (yytype)
+    {
+      default:
+        break;
+    }
+  YYFPRINTF (yyout, ")");
 }
+#endif /* YYDEBUG. */
+
 
-#else /* __cplusplus */
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
 
-/* This is the most reliable way to avoid incompatibilities
-   in available built-in functions on various systems.  */
 static void
-__yy_memcpy (char *to, char *from, unsigned int count)
+#if defined (__STDC__) || defined (__cplusplus)
+yydestruct (int yytype, YYSTYPE yyvalue)
+#else
+yydestruct (yytype, yyvalue)
+    int yytype;
+    YYSTYPE yyvalue;
+#endif
 {
-  register char *t = to;
-  register char *f = from;
-  register int i = count;
+  /* Pacify ``unused variable'' warnings.  */
+  (void) yyvalue;
 
-  while (i-- > 0)
-    *t++ = *f++;
+  switch (yytype)
+    {
+      default:
+        break;
+    }
 }
 
-#endif
-#endif
 
-#line 216 "/usr/share/misc/bison.simple"
 
 /* The user can define YYPARSE_PARAM as the name of an argument to be passed
    into yyparse.  The argument should have type void *.
@@ -529,76 +815,85 @@
    to the proper pointer type.  */
 
 #ifdef YYPARSE_PARAM
-#ifdef __cplusplus
-#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL
-#else /* not __cplusplus */
-#define YYPARSE_PARAM_ARG YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
-#endif /* not __cplusplus */
-#else /* not YYPARSE_PARAM */
-#define YYPARSE_PARAM_ARG
-#define YYPARSE_PARAM_DECL
-#endif /* not YYPARSE_PARAM */
+# if defined (__STDC__) || defined (__cplusplus)
+#  define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
+#  define YYPARSE_PARAM_DECL
+# else
+#  define YYPARSE_PARAM_ARG YYPARSE_PARAM
+#  define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
+# endif
+#else /* !YYPARSE_PARAM */
+# define YYPARSE_PARAM_ARG
+# define YYPARSE_PARAM_DECL
+#endif /* !YYPARSE_PARAM */
 
 /* Prevent warning if -Wstrict-prototypes.  */
 #ifdef __GNUC__
-#ifdef YYPARSE_PARAM
+# ifdef YYPARSE_PARAM
 int yyparse (void *);
-#else
+# else
 int yyparse (void);
+# endif
 #endif
-#endif
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of parse errors so far.  */
+int yynerrs;
+
 
 int
-yyparse(YYPARSE_PARAM_ARG)
+yyparse (YYPARSE_PARAM_ARG)
      YYPARSE_PARAM_DECL
 {
+  
   register int yystate;
   register int yyn;
+  int yyresult;
+  /* Number of tokens to shift before error messages enabled.  */
+  int yyerrstatus;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yychar1 = 0;
+
+  /* Three stacks and their tools:
+     `yyss': related to states,
+     `yyvs': related to semantic values,
+     `yyls': related to locations.
+
+     Refer to the stacks thru separate pointers, to allow yyoverflow
+     to reallocate them elsewhere.  */
+
+  /* The state stack.  */
+  short	yyssa[YYINITDEPTH];
+  short *yyss = yyssa;
   register short *yyssp;
-  register YYSTYPE *yyvsp;
-  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
-  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */
 
-  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
-  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/
+  /* The semantic value stack.  */
+  YYSTYPE yyvsa[YYINITDEPTH];
+  YYSTYPE *yyvs = yyvsa;
+  register YYSTYPE *yyvsp;
 
-  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
-  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */
 
-#ifdef YYLSP_NEEDED
-  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
-  YYLTYPE *yyls = yylsa;
-  YYLTYPE *yylsp;
 
-#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
-#else
 #define YYPOPSTACK   (yyvsp--, yyssp--)
-#endif
 
-  int yystacksize = YYINITDEPTH;
-  int yyfree_stacks = 0;
+  YYSIZE_T yystacksize = YYINITDEPTH;
 
-#ifdef YYPURE
-  int yychar;
-  YYSTYPE yylval;
-  int yynerrs;
-#ifdef YYLSP_NEEDED
-  YYLTYPE yylloc;
-#endif
-#endif
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
 
-  YYSTYPE yyval;		/*  the variable used to return		*/
-				/*  semantic values from the action	*/
-				/*  routines				*/
 
+  /* When reducing, the number of symbols on the RHS of the reduced
+     rule.  */
   int yylen;
 
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Starting parse\n");
-#endif
+  YYDPRINTF ((stderr, "Starting parse\n"));
 
   yystate = 0;
   yyerrstatus = 0;
@@ -610,110 +905,96 @@
      so that they stay on the same level as the state stack.
      The wasted elements are never initialized.  */
 
-  yyssp = yyss - 1;
+  yyssp = yyss;
   yyvsp = yyvs;
-#ifdef YYLSP_NEEDED
-  yylsp = yyls;
-#endif
 
-/* Push a new state, which is found in  yystate  .  */
-/* In all cases, when you get here, the value and location stacks
-   have just been pushed. so pushing a state here evens the stacks.  */
-yynewstate:
+  goto yysetstate;
 
-  *++yyssp = yystate;
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed. so pushing a state here evens the stacks.
+     */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
 
   if (yyssp >= yyss + yystacksize - 1)
     {
-      /* Give user a chance to reallocate the stack */
-      /* Use copies of these so that the &'s don't force the real ones into memory. */
-      YYSTYPE *yyvs1 = yyvs;
-      short *yyss1 = yyss;
-#ifdef YYLSP_NEEDED
-      YYLTYPE *yyls1 = yyls;
-#endif
-
       /* Get the current used size of the three stacks, in elements.  */
-      int size = yyssp - yyss + 1;
+      YYSIZE_T yysize = yyssp - yyss + 1;
 
 #ifdef yyoverflow
-      /* Each stack pointer address is followed by the size of
-	 the data in use in that stack, in bytes.  */
-#ifdef YYLSP_NEEDED
-      /* This used to be a conditional around just the two extra args,
-	 but that might be undefined if yyoverflow is a macro.  */
-      yyoverflow("parser stack overflow",
-		 &yyss1, size * sizeof (*yyssp),
-		 &yyvs1, size * sizeof (*yyvsp),
-		 &yyls1, size * sizeof (*yylsp),
-		 &yystacksize);
-#else
-      yyoverflow("parser stack overflow",
-		 &yyss1, size * sizeof (*yyssp),
-		 &yyvs1, size * sizeof (*yyvsp),
-		 &yystacksize);
-#endif
+      {
+	/* Give user a chance to reallocate the stack. Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	short *yyss1 = yyss;
+
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow ("parser stack overflow",
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
 
-      yyss = yyss1; yyvs = yyvs1;
-#ifdef YYLSP_NEEDED
-      yyls = yyls1;
-#endif
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
 #else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyoverflowlab;
+# else
       /* Extend the stack our own way.  */
       if (yystacksize >= YYMAXDEPTH)
-	{
-	  yyerror("parser stack overflow");
-	  if (yyfree_stacks)
-	    {
-	      free (yyss);
-	      free (yyvs);
-#ifdef YYLSP_NEEDED
-	      free (yyls);
-#endif
-	    }
-	  return 2;
-	}
+	goto yyoverflowlab;
       yystacksize *= 2;
       if (yystacksize > YYMAXDEPTH)
 	yystacksize = YYMAXDEPTH;
-#ifndef YYSTACK_USE_ALLOCA
-      yyfree_stacks = 1;
-#endif
-      yyss = (short *) YYSTACK_ALLOC (yystacksize * sizeof (*yyssp));
-      __yy_memcpy ((char *)yyss, (char *)yyss1,
-		   size * (unsigned int) sizeof (*yyssp));
-      yyvs = (YYSTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yyvsp));
-      __yy_memcpy ((char *)yyvs, (char *)yyvs1,
-		   size * (unsigned int) sizeof (*yyvsp));
-#ifdef YYLSP_NEEDED
-      yyls = (YYLTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yylsp));
-      __yy_memcpy ((char *)yyls, (char *)yyls1,
-		   size * (unsigned int) sizeof (*yylsp));
-#endif
+
+      {
+	short *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyoverflowlab;
+	YYSTACK_RELOCATE (yyss);
+	YYSTACK_RELOCATE (yyvs);
+
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
 #endif /* no yyoverflow */
 
-      yyssp = yyss + size - 1;
-      yyvsp = yyvs + size - 1;
-#ifdef YYLSP_NEEDED
-      yylsp = yyls + size - 1;
-#endif
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
 
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
-#endif
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
 
       if (yyssp >= yyss + yystacksize - 1)
 	YYABORT;
     }
 
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Entering state %d\n", yystate);
-#endif
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
 
   goto yybackup;
- yybackup:
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
 
 /* Do appropriate processing given the current state.  */
 /* Read a lookahead token if we need one and don't already have one.  */
@@ -722,7 +1003,7 @@
   /* First try to decide what to do without reference to lookahead token.  */
 
   yyn = yypact[yystate];
-  if (yyn == YYFLAG)
+  if (yyn == YYPACT_NINF)
     goto yydefault;
 
   /* Not known => get a lookahead token if don't already have one.  */
@@ -732,245 +1013,259 @@
 
   if (yychar == YYEMPTY)
     {
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Reading a token: ");
-#endif
+      YYDPRINTF ((stderr, "Reading a token: "));
       yychar = YYLEX;
     }
 
-  /* Convert token to internal form (in yychar1) for indexing tables with */
+  /* Convert token to internal form (in yychar1) for indexing tables with.  */
 
-  if (yychar <= 0)		/* This means end of input. */
+  if (yychar <= 0)		/* This means end of input.  */
     {
       yychar1 = 0;
-      yychar = YYEOF;		/* Don't call YYLEX any more */
+      yychar = YYEOF;		/* Don't call YYLEX any more.  */
 
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Now at end of input.\n");
-#endif
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
     }
   else
     {
-      yychar1 = YYTRANSLATE(yychar);
+      yychar1 = YYTRANSLATE (yychar);
 
-#if YYDEBUG != 0
-      if (yydebug)
-	{
-	  fprintf (stderr, "Next token is %d (%s", yychar, yytname[yychar1]);
-	  /* Give the individual parser a way to print the precise meaning
-	     of a token, for further debugging info.  */
-#ifdef YYPRINT
-	  YYPRINT (stderr, yychar, yylval);
-#endif
-	  fprintf (stderr, ")\n");
-	}
-#endif
+      /* We have to keep this `#if YYDEBUG', since we use variables
+	 which are defined only if `YYDEBUG' is set.  */
+      YYDPRINTF ((stderr, "Next token is "));
+      YYDSYMPRINT ((stderr, yychar1, yylval));
+      YYDPRINTF ((stderr, "\n"));
     }
 
+  /* If the proper action on seeing token YYCHAR1 is to reduce or to
+     detect an error, take that action.  */
   yyn += yychar1;
-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yychar1)
     goto yydefault;
-
   yyn = yytable[yyn];
-
-  /* yyn is what to do for this token type in this state.
-     Negative => reduce, -yyn is rule number.
-     Positive => shift, yyn is new state.
-       New state is final state => don't bother to shift,
-       just return success.
-     0, or most negative number => error.  */
-
-  if (yyn < 0)
+  if (yyn <= 0)
     {
-      if (yyn == YYFLAG)
+      if (yyn == 0 || yyn == YYTABLE_NINF)
 	goto yyerrlab;
       yyn = -yyn;
       goto yyreduce;
     }
-  else if (yyn == 0)
-    goto yyerrlab;
 
   if (yyn == YYFINAL)
     YYACCEPT;
 
   /* Shift the lookahead token.  */
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
-#endif
+  YYDPRINTF ((stderr, "Shifting token %d (%s), ",
+	      yychar, yytname[yychar1]));
 
   /* Discard the token being shifted unless it is eof.  */
   if (yychar != YYEOF)
     yychar = YYEMPTY;
 
   *++yyvsp = yylval;
-#ifdef YYLSP_NEEDED
-  *++yylsp = yylloc;
-#endif
 
-  /* count tokens shifted since error; after three, turn off error status.  */
-  if (yyerrstatus) yyerrstatus--;
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
 
   yystate = yyn;
   goto yynewstate;
 
-/* Do the default action for the current state.  */
-yydefault:
 
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
   yyn = yydefact[yystate];
   if (yyn == 0)
     goto yyerrlab;
+  goto yyreduce;
 
-/* Do a reduction.  yyn is the number of a rule to reduce with.  */
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
 yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
   yylen = yyr2[yyn];
-  if (yylen > 0)
-    yyval = yyvsp[1-yylen]; /* implement default value of the action */
 
-#if YYDEBUG != 0
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+
+#if YYDEBUG
+  /* We have to keep this `#if YYDEBUG', since we use variables which
+     are defined only if `YYDEBUG' is set.  */
   if (yydebug)
     {
-      int i;
+      int yyi;
 
-      fprintf (stderr, "Reducing via rule %d (line %d), ",
-	       yyn, yyrline[yyn]);
+      YYFPRINTF (stderr, "Reducing via rule %d (line %d), ",
+		 yyn - 1, yyrline[yyn]);
 
       /* Print the symbols being reduced, and their result.  */
-      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
-	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
-      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
+      for (yyi = yyprhs[yyn]; yyrhs[yyi] >= 0; yyi++)
+	YYFPRINTF (stderr, "%s ", yytname[yyrhs[yyi]]);
+      YYFPRINTF (stderr, " -> %s\n", yytname[yyr1[yyn]]);
     }
 #endif
-
-
-  switch (yyn) {
-
-case 13:
-#line 166 "loadkeys.y"
-{
+  switch (yyn)
+    {
+        case 14:
+#line 163 "loadkeys.y"
+    {
 			    set_charset(kbs_buf.kb_string);
-			;
-    break;}
-case 14:
-#line 171 "loadkeys.y"
-{
+			}
+    break;
+
+  case 15:
+#line 168 "loadkeys.y"
+    {
 			    alt_is_meta = 1;
-			;
-    break;}
-case 15:
-#line 176 "loadkeys.y"
-{
+			}
+    break;
+
+  case 16:
+#line 173 "loadkeys.y"
+    {
 			    strings_as_usual();
-			;
-    break;}
-case 16:
-#line 181 "loadkeys.y"
-{
+			}
+    break;
+
+  case 17:
+#line 178 "loadkeys.y"
+    {
 			    compose_as_usual(kbs_buf.kb_string);
-			;
-    break;}
-case 17:
-#line 185 "loadkeys.y"
-{
+			}
+    break;
+
+  case 18:
+#line 182 "loadkeys.y"
+    {
 			    compose_as_usual(0);
-			;
-    break;}
-case 18:
-#line 190 "loadkeys.y"
-{
+			}
+    break;
+
+  case 19:
+#line 187 "loadkeys.y"
+    {
 			    keymaps_line_seen = 1;
-			;
-    break;}
-case 21:
-#line 198 "loadkeys.y"
-{
+			}
+    break;
+
+  case 22:
+#line 195 "loadkeys.y"
+    {
 			    int i;
 			    for (i = yyvsp[-2]; i<= yyvsp[0]; i++)
 			      addmap(i,1);
-			;
-    break;}
-case 22:
-#line 204 "loadkeys.y"
-{
+			}
+    break;
+
+  case 23:
+#line 201 "loadkeys.y"
+    {
 			    addmap(yyvsp[0],1);
-			;
-    break;}
-case 23:
-#line 209 "loadkeys.y"
-{
+			}
+    break;
+
+  case 24:
+#line 206 "loadkeys.y"
+    {
 			    if (KTYP(yyvsp[-3]) != KT_FN)
 				lkfatal1("'%s' is not a function key symbol",
 					syms[KTYP(yyvsp[-3])].table[KVAL(yyvsp[-3])]);
 			    kbs_buf.kb_func = KVAL(yyvsp[-3]);
 			    addfunc(kbs_buf);
-			;
-    break;}
-case 24:
-#line 218 "loadkeys.y"
-{
+			}
+    break;
+
+  case 25:
+#line 215 "loadkeys.y"
+    {
 			    compose(yyvsp[-4], yyvsp[-3], yyvsp[-1]);
-			;
-    break;}
-case 25:
-#line 222 "loadkeys.y"
-{
+			}
+    break;
+
+  case 26:
+#line 219 "loadkeys.y"
+    {
 			    compose(yyvsp[-4], yyvsp[-3], yyvsp[-1]);
-			;
-    break;}
-case 26:
-#line 226 "loadkeys.y"
-{ mod = 0; ;
-    break;}
-case 27:
-#line 228 "loadkeys.y"
-{
+			}
+    break;
+
+  case 27:
+#line 223 "loadkeys.y"
+    { mod = 0; }
+    break;
+
+  case 28:
+#line 225 "loadkeys.y"
+    {
 			    addkey(yyvsp[-3], mod, yyvsp[-1]);
-			;
-    break;}
-case 28:
-#line 232 "loadkeys.y"
-{
+			}
+    break;
+
+  case 29:
+#line 229 "loadkeys.y"
+    {
 			    addkey(yyvsp[-2], 0, yyvsp[0]);
-			;
-    break;}
-case 31:
+			}
+    break;
+
+  case 32:
+#line 236 "loadkeys.y"
+    { mod |= M_SHIFT;	}
+    break;
+
+  case 33:
+#line 237 "loadkeys.y"
+    { mod |= M_CTRL;	}
+    break;
+
+  case 34:
+#line 238 "loadkeys.y"
+    { mod |= M_ALT;		}
+    break;
+
+  case 35:
 #line 239 "loadkeys.y"
-{ mod |= M_SHIFT;	;
-    break;}
-case 32:
+    { mod |= M_ALTGR;	}
+    break;
+
+  case 36:
 #line 240 "loadkeys.y"
-{ mod |= M_CTRL;	;
-    break;}
-case 33:
+    { mod |= M_SHIFTL;	}
+    break;
+
+  case 37:
 #line 241 "loadkeys.y"
-{ mod |= M_ALT;		;
-    break;}
-case 34:
+    { mod |= M_SHIFTR;	}
+    break;
+
+  case 38:
 #line 242 "loadkeys.y"
-{ mod |= M_ALTGR;	;
-    break;}
-case 35:
+    { mod |= M_CTRLL;	}
+    break;
+
+  case 39:
 #line 243 "loadkeys.y"
-{ mod |= M_SHIFTL;	;
-    break;}
-case 36:
-#line 244 "loadkeys.y"
-{ mod |= M_SHIFTR;	;
-    break;}
-case 37:
-#line 245 "loadkeys.y"
-{ mod |= M_CTRLL;	;
-    break;}
-case 38:
+    { mod |= M_CTRLR;	}
+    break;
+
+  case 40:
 #line 246 "loadkeys.y"
-{ mod |= M_CTRLR;	;
-    break;}
-case 39:
-#line 249 "loadkeys.y"
-{
+    {
 	    int i, j;
 
 	    if (rvalct == 1) {
@@ -999,259 +1294,267 @@
 	    } else
 	      for (i = 0; i < rvalct; i++)
 		addkey(yyvsp[-3], i, key_buf[i]);
-	;
-    break;}
-case 42:
-#line 285 "loadkeys.y"
-{
+	}
+    break;
+
+  case 43:
+#line 282 "loadkeys.y"
+    {
 			    if (rvalct >= MAX_NR_KEYMAPS)
 				lkfatal(_("too many keydefinitions on one line"));
 			    key_buf[rvalct++] = yyvsp[0];
-			;
-    break;}
-case 43:
-#line 292 "loadkeys.y"
-{yyval=yyvsp[0];;
-    break;}
-case 44:
-#line 294 "loadkeys.y"
-{yyval=(yyvsp[0] ^ 0xf000); unicode_used=1;;
-    break;}
-case 45:
-#line 296 "loadkeys.y"
-{yyval=K(KT_LETTER, KVAL(yyvsp[0]));;
-    break;}
-case 46:
-#line 298 "loadkeys.y"
-{yyval=yyvsp[0];;
-    break;}
-case 47:
-#line 300 "loadkeys.y"
-{yyval=K(KT_LETTER, KVAL(yyvsp[0]));;
-    break;}
-}
-   /* the action file gets copied in in place of this dollarsign */
-#line 542 "/usr/share/misc/bison.simple"
+			}
+    break;
+
+  case 44:
+#line 289 "loadkeys.y"
+    {yyval=yyvsp[0];}
+    break;
+
+  case 45:
+#line 291 "loadkeys.y"
+    {yyval=(yyvsp[0] ^ 0xf000); unicode_used=1;}
+    break;
+
+  case 46:
+#line 293 "loadkeys.y"
+    {yyval=K(KT_LETTER, KVAL(yyvsp[0]));}
+    break;
+
+  case 47:
+#line 295 "loadkeys.y"
+    {yyval=yyvsp[0];}
+    break;
+
+  case 48:
+#line 297 "loadkeys.y"
+    {yyval=K(KT_LETTER, KVAL(yyvsp[0]));}
+    break;
+
+
+    }
+
+/* Line 1016 of /usr/share/bison/yacc.c.  */
+#line 1339 "y.tab.c"
 
   yyvsp -= yylen;
   yyssp -= yylen;
-#ifdef YYLSP_NEEDED
-  yylsp -= yylen;
-#endif
 
-#if YYDEBUG != 0
+
+#if YYDEBUG
   if (yydebug)
     {
-      short *ssp1 = yyss - 1;
-      fprintf (stderr, "state stack now");
-      while (ssp1 != yyssp)
-	fprintf (stderr, " %d", *++ssp1);
-      fprintf (stderr, "\n");
+      short *yyssp1 = yyss - 1;
+      YYFPRINTF (stderr, "state stack now");
+      while (yyssp1 != yyssp)
+	YYFPRINTF (stderr, " %d", *++yyssp1);
+      YYFPRINTF (stderr, "\n");
     }
 #endif
 
   *++yyvsp = yyval;
 
-#ifdef YYLSP_NEEDED
-  yylsp++;
-  if (yylen == 0)
-    {
-      yylsp->first_line = yylloc.first_line;
-      yylsp->first_column = yylloc.first_column;
-      yylsp->last_line = (yylsp-1)->last_line;
-      yylsp->last_column = (yylsp-1)->last_column;
-      yylsp->text = 0;
-    }
-  else
-    {
-      yylsp->last_line = (yylsp+yylen-1)->last_line;
-      yylsp->last_column = (yylsp+yylen-1)->last_column;
-    }
-#endif
 
-  /* Now "shift" the result of the reduction.
-     Determine what state that goes to,
-     based on the state we popped back to
-     and the rule number reduced by.  */
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
 
   yyn = yyr1[yyn];
 
-  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
-  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
     yystate = yytable[yystate];
   else
-    yystate = yydefgoto[yyn - YYNTBASE];
+    yystate = yydefgoto[yyn - YYNTOKENS];
 
   goto yynewstate;
 
-yyerrlab:   /* here on detecting error */
 
-  if (! yyerrstatus)
-    /* If not already recovering from an error, report this error.  */
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
     {
       ++yynerrs;
-
-#ifdef YYERROR_VERBOSE
+#if YYERROR_VERBOSE
       yyn = yypact[yystate];
 
-      if (yyn > YYFLAG && yyn < YYLAST)
+      if (YYPACT_NINF < yyn && yyn < YYLAST)
 	{
-	  int size = 0;
-	  char *msg;
-	  int x, count;
-
-	  count = 0;
-	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
-	  for (x = (yyn < 0 ? -yyn : 0);
-	       x < (sizeof(yytname) / sizeof(char *)); x++)
-	    if (yycheck[x + yyn] == x)
-	      size += strlen(yytname[x]) + 15, count++;
-	  msg = (char *) malloc(size + 15);
-	  if (msg != 0)
+	  YYSIZE_T yysize = 0;
+	  int yytype = YYTRANSLATE (yychar);
+	  char *yymsg;
+	  int yyx, yycount;
+
+	  yycount = 0;
+	  /* Start YYX at -YYN if negative to avoid negative indexes in
+	     YYCHECK.  */
+	  for (yyx = yyn < 0 ? -yyn : 0;
+	       yyx < (int) (sizeof (yytname) / sizeof (char *)); yyx++)
+	    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	      yysize += yystrlen (yytname[yyx]) + 15, yycount++;
+	  yysize += yystrlen ("parse error, unexpected ") + 1;
+	  yysize += yystrlen (yytname[yytype]);
+	  yymsg = (char *) YYSTACK_ALLOC (yysize);
+	  if (yymsg != 0)
 	    {
-	      strcpy(msg, "parse error");
+	      char *yyp = yystpcpy (yymsg, "parse error, unexpected ");
+	      yyp = yystpcpy (yyp, yytname[yytype]);
 
-	      if (count < 5)
+	      if (yycount < 5)
 		{
-		  count = 0;
-		  for (x = (yyn < 0 ? -yyn : 0);
-		       x < (sizeof(yytname) / sizeof(char *)); x++)
-		    if (yycheck[x + yyn] == x)
+		  yycount = 0;
+		  for (yyx = yyn < 0 ? -yyn : 0;
+		       yyx < (int) (sizeof (yytname) / sizeof (char *));
+		       yyx++)
+		    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
 		      {
-			strcat(msg, count == 0 ? ", expecting `" : " or `");
-			strcat(msg, yytname[x]);
-			strcat(msg, "'");
-			count++;
+			const char *yyq = ! yycount ? ", expecting " : " or ";
+			yyp = yystpcpy (yyp, yyq);
+			yyp = yystpcpy (yyp, yytname[yyx]);
+			yycount++;
 		      }
 		}
-	      yyerror(msg);
-	      free(msg);
+	      yyerror (yymsg);
+	      YYSTACK_FREE (yymsg);
 	    }
 	  else
-	    yyerror ("parse error; also virtual memory exceeded");
+	    yyerror ("parse error; also virtual memory exhausted");
 	}
       else
 #endif /* YYERROR_VERBOSE */
-	yyerror("parse error");
+	yyerror ("parse error");
     }
-
   goto yyerrlab1;
-yyerrlab1:   /* here on error raised explicitly by an action */
 
+
+/*----------------------------------------------------.
+| yyerrlab1 -- error raised explicitly by an action.  |
+`----------------------------------------------------*/
+yyerrlab1:
   if (yyerrstatus == 3)
     {
-      /* if just tried and failed to reuse lookahead token after an error, discard it.  */
+      /* If just tried and failed to reuse lookahead token after an
+	 error, discard it.  */
 
-      /* return failure if at end of input */
+      /* Return failure if at end of input.  */
       if (yychar == YYEOF)
-	YYABORT;
-
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
-#endif
+        {
+	  /* Pop the error token.  */
+          YYPOPSTACK;
+	  /* Pop the rest of the stack.  */
+	  while (yyssp > yyss)
+	    {
+	      YYDPRINTF ((stderr, "Error: popping "));
+	      YYDSYMPRINT ((stderr,
+			    yystos[*yyssp],
+			    *yyvsp));
+	      YYDPRINTF ((stderr, "\n"));
+	      yydestruct (yystos[*yyssp], *yyvsp);
+	      YYPOPSTACK;
+	    }
+	  YYABORT;
+        }
 
+      YYDPRINTF ((stderr, "Discarding token %d (%s).\n",
+		  yychar, yytname[yychar1]));
+      yydestruct (yychar1, yylval);
       yychar = YYEMPTY;
     }
 
-  /* Else will try to reuse lookahead token
-     after shifting the error token.  */
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
 
-  yyerrstatus = 3;		/* Each real token shifted decrements this */
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
 
-  goto yyerrhandle;
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
 
-yyerrdefault:  /* current state does not do anything special for the error token. */
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
 
-#if 0
-  /* This is wrong; only states that explicitly want error tokens
-     should shift them.  */
-  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
-  if (yyn) goto yydefault;
-#endif
+      YYDPRINTF ((stderr, "Error: popping "));
+      YYDSYMPRINT ((stderr,
+		    yystos[*yyssp], *yyvsp));
+      YYDPRINTF ((stderr, "\n"));
 
-yyerrpop:   /* pop the current state because it cannot handle the error token */
+      yydestruct (yystos[yystate], *yyvsp);
+      yyvsp--;
+      yystate = *--yyssp;
 
-  if (yyssp == yyss) YYABORT;
-  yyvsp--;
-  yystate = *--yyssp;
-#ifdef YYLSP_NEEDED
-  yylsp--;
-#endif
 
-#if YYDEBUG != 0
-  if (yydebug)
-    {
-      short *ssp1 = yyss - 1;
-      fprintf (stderr, "Error: state stack now");
-      while (ssp1 != yyssp)
-	fprintf (stderr, " %d", *++ssp1);
-      fprintf (stderr, "\n");
-    }
+#if YYDEBUG
+      if (yydebug)
+	{
+	  short *yyssp1 = yyss - 1;
+	  YYFPRINTF (stderr, "Error: state stack now");
+	  while (yyssp1 != yyssp)
+	    YYFPRINTF (stderr, " %d", *++yyssp1);
+	  YYFPRINTF (stderr, "\n");
+	}
 #endif
-
-yyerrhandle:
-
-  yyn = yypact[yystate];
-  if (yyn == YYFLAG)
-    goto yyerrdefault;
-
-  yyn += YYTERROR;
-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
-    goto yyerrdefault;
-
-  yyn = yytable[yyn];
-  if (yyn < 0)
-    {
-      if (yyn == YYFLAG)
-	goto yyerrpop;
-      yyn = -yyn;
-      goto yyreduce;
     }
-  else if (yyn == 0)
-    goto yyerrpop;
 
   if (yyn == YYFINAL)
     YYACCEPT;
 
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Shifting error token, ");
-#endif
+  YYDPRINTF ((stderr, "Shifting error token, "));
 
   *++yyvsp = yylval;
-#ifdef YYLSP_NEEDED
-  *++yylsp = yylloc;
-#endif
+
 
   yystate = yyn;
   goto yynewstate;
 
- yyacceptlab:
-  /* YYACCEPT comes here.  */
-  if (yyfree_stacks)
-    {
-      free (yyss);
-      free (yyvs);
-#ifdef YYLSP_NEEDED
-      free (yyls);
-#endif
-    }
-  return 0;
 
- yyabortlab:
-  /* YYABORT comes here.  */
-  if (yyfree_stacks)
-    {
-      free (yyss);
-      free (yyvs);
-#ifdef YYLSP_NEEDED
-      free (yyls);
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#ifndef yyoverflow
+/*----------------------------------------------.
+| yyoverflowlab -- parser overflow comes here.  |
+`----------------------------------------------*/
+yyoverflowlab:
+  yyerror ("parser stack overflow");
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
 #endif
-    }
-  return 1;
+  return yyresult;
 }
-#line 302 "loadkeys.y"
+
+
+#line 299 "loadkeys.y"
 			
 
 void usage()
@@ -2134,3 +2437,4 @@
 }
 
 
+
diff -ruN console-tools-0.2.3-old/kbdtools/loadkeys.h console-tools-0.2.3/kbdtools/loadkeys.h
--- console-tools-0.2.3-old/kbdtools/loadkeys.h	1999-07-19 20:50:34.000000000 +0100
+++ console-tools-0.2.3/kbdtools/loadkeys.h	2003-05-22 12:09:06.000000000 +0100
@@ -1,38 +1,114 @@
-#ifndef YYSTYPE
-#define YYSTYPE int
+/* A Bison parser, made from loadkeys.y, by GNU bison 1.75.  */
+
+/* Skeleton parser for Yacc-like parsing with Bison,
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* As a special exception, when this file is copied by Bison into a
+   Bison output file, you may use that output file without restriction.
+   This special exception was added by the Free Software Foundation
+   in version 1.24 of Bison.  */
+
+#ifndef BISON_Y_TAB_H
+# define BISON_Y_TAB_H
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     EOL = 258,
+     NUMBER = 259,
+     LITERAL = 260,
+     CHARSET = 261,
+     KEYMAPS = 262,
+     KEYCODE = 263,
+     EQUALS = 264,
+     PLAIN = 265,
+     SHIFT = 266,
+     CONTROL = 267,
+     ALT = 268,
+     ALTGR = 269,
+     SHIFTL = 270,
+     SHIFTR = 271,
+     CTRLL = 272,
+     CTRLR = 273,
+     COMMA = 274,
+     DASH = 275,
+     STRING = 276,
+     STRLITERAL = 277,
+     COMPOSE = 278,
+     TO = 279,
+     CCHAR = 280,
+     ERROR = 281,
+     PLUS = 282,
+     UNUMBER = 283,
+     ALT_IS_META = 284,
+     STRINGS = 285,
+     AS = 286,
+     USUAL = 287,
+     ON = 288,
+     FOR = 289
+   };
 #endif
-#define	EOL	257
-#define	NUMBER	258
-#define	LITERAL	259
-#define	CHARSET	260
-#define	KEYMAPS	261
-#define	KEYCODE	262
-#define	EQUALS	263
-#define	PLAIN	264
-#define	SHIFT	265
-#define	CONTROL	266
-#define	ALT	267
-#define	ALTGR	268
-#define	SHIFTL	269
-#define	SHIFTR	270
-#define	CTRLL	271
-#define	CTRLR	272
-#define	COMMA	273
-#define	DASH	274
-#define	STRING	275
-#define	STRLITERAL	276
-#define	COMPOSE	277
-#define	TO	278
-#define	CCHAR	279
-#define	ERROR	280
-#define	PLUS	281
-#define	UNUMBER	282
-#define	ALT_IS_META	283
-#define	STRINGS	284
-#define	AS	285
-#define	USUAL	286
-#define	ON	287
-#define	FOR	288
+#define EOL 258
+#define NUMBER 259
+#define LITERAL 260
+#define CHARSET 261
+#define KEYMAPS 262
+#define KEYCODE 263
+#define EQUALS 264
+#define PLAIN 265
+#define SHIFT 266
+#define CONTROL 267
+#define ALT 268
+#define ALTGR 269
+#define SHIFTL 270
+#define SHIFTR 271
+#define CTRLL 272
+#define CTRLR 273
+#define COMMA 274
+#define DASH 275
+#define STRING 276
+#define STRLITERAL 277
+#define COMPOSE 278
+#define TO 279
+#define CCHAR 280
+#define ERROR 281
+#define PLUS 282
+#define UNUMBER 283
+#define ALT_IS_META 284
+#define STRINGS 285
+#define AS 286
+#define USUAL 287
+#define ON 288
+#define FOR 289
 
 
+
+
+#ifndef YYSTYPE
+typedef int yystype;
+# define YYSTYPE yystype
+#endif
+
 extern YYSTYPE yylval;
+
+
+#endif /* not BISON_Y_TAB_H */
+
diff -ruN console-tools-0.2.3-old/kbdtools/loadkeys.y console-tools-0.2.3/kbdtools/loadkeys.y
--- console-tools-0.2.3-old/kbdtools/loadkeys.y	1999-07-19 20:39:37.000000000 +0100
+++ console-tools-0.2.3/kbdtools/loadkeys.y	2003-05-22 12:09:06.000000000 +0100
@@ -133,9 +133,6 @@
 static void loadkeys(void);
 static void mktable(void);
 static void strings_as_usual(void);
-static void keypad_as_usual(char *keyboard);
-static void function_keys_as_usual(char *keyboard);
-static void consoles_as_usual(char *keyboard);
 static void compose_as_usual(char *charset);
 void lkfatal(char *);
 void lkfatal0(char *, int);
diff -ruN console-tools-0.2.3-old/kbdtools/setkeycodes.c console-tools-0.2.3/kbdtools/setkeycodes.c
--- console-tools-0.2.3-old/kbdtools/setkeycodes.c	2003-05-22 12:09:06.000000000 +0100
+++ console-tools-0.2.3/kbdtools/setkeycodes.c	2003-05-22 12:09:06.000000000 +0100
@@ -29,7 +29,7 @@
 }
 
 
-void main(int argc, char **argv) 
+int main(int argc, char **argv) 
 {
   char *ep;
   int fd, sc;
diff -ruN console-tools-0.2.3-old/kbdtools/setleds.c console-tools-0.2.3/kbdtools/setleds.c
--- console-tools-0.2.3-old/kbdtools/setleds.c	2003-05-22 12:09:06.000000000 +0100
+++ console-tools-0.2.3/kbdtools/setleds.c	2003-05-22 15:14:54.000000000 +0100
@@ -7,6 +7,7 @@
  * In particular, setleds without arguments will only report.
  */
 
+#include <stdlib.h>
 #include <stdio.h>
 #include <fcntl.h>
 #include <string.h>
diff -ruN console-tools-0.2.3-old/kbdtools/setmetamode.c console-tools-0.2.3/kbdtools/setmetamode.c
--- console-tools-0.2.3-old/kbdtools/setmetamode.c	1999-04-08 23:11:13.000000000 +0100
+++ console-tools-0.2.3/kbdtools/setmetamode.c	2003-05-22 15:15:10.000000000 +0100
@@ -6,6 +6,7 @@
  * Without arguments setmetamode will only report.
  */
 
+#include <stdlib.h>
 #include <stdio.h>
 #include <fcntl.h>
 #include <string.h>
@@ -61,7 +62,7 @@
 
 #define SIZE(a) (sizeof(a)/sizeof(a[0]))
 
-void main(int argc, char* argv[])
+int main(int argc, char* argv[])
 {
   char ometa, nmeta;
   struct meta *mp;
diff -ruN console-tools-0.2.3-old/lib/acm.c console-tools-0.2.3/lib/acm.c
--- console-tools-0.2.3-old/lib/acm.c	1999-04-08 23:11:13.000000000 +0100
+++ console-tools-0.2.3/lib/acm.c	2003-05-22 14:16:48.000000000 +0100
@@ -6,6 +6,7 @@
 #include <stdio.h>
 #include <memory.h>
 #include <string.h>
+#include <stdlib.h>
 #include <unistd.h>
 #include <fcntl.h>
 #include <assert.h>
diff -ruN console-tools-0.2.3-old/lib/findfile.c console-tools-0.2.3/lib/findfile.c
--- console-tools-0.2.3-old/lib/findfile.c	2003-05-22 15:10:55.000000000 +0100
+++ console-tools-0.2.3/lib/findfile.c	2003-05-22 15:10:20.000000000 +0100
@@ -479,7 +479,7 @@
 
 ffr_next_component:
   /* extract the dir entry to look for into `target' */
-  ptr_to_target = target = xstrdup(fnam);
+  ptr_to_target = target = xstrdup( (char *) fnam);
   first_slash = strchr(fnam, '/');
   if (first_slash)
     target[first_slash-fnam] = 0;
diff -ruN console-tools-0.2.3-old/lib/fontdata.c console-tools-0.2.3/lib/fontdata.c
--- console-tools-0.2.3-old/lib/fontdata.c	1999-04-08 22:29:39.000000000 +0100
+++ console-tools-0.2.3/lib/fontdata.c	2003-05-22 14:14:01.000000000 +0100
@@ -2,7 +2,7 @@
 #include <string.h>
 #include <errno.h>
 #include <linux/kd.h>
-
+#include <stdlib.h>
 #include <lct/font.h>
 
 /* NOTE: the IOCTLs request 32 scanlines, whatever the fontheight */
diff -ruN console-tools-0.2.3-old/lib/unicode.c console-tools-0.2.3/lib/unicode.c
--- console-tools-0.2.3-old/lib/unicode.c	1999-04-08 22:29:40.000000000 +0100
+++ console-tools-0.2.3/lib/unicode.c	2003-05-22 12:09:06.000000000 +0100
@@ -35,8 +35,8 @@
 unicode utf8_to_ucs2 (char* buf)
 {
   int utf_count = 0;
-  long utf_char;
-  unicode tc;
+  long utf_char = 0;
+  unicode tc = 0;
   unsigned char c;
   
   do
diff -ruN console-tools-0.2.3-old/po/cat-id-tbl.c console-tools-0.2.3/po/cat-id-tbl.c
--- console-tools-0.2.3-old/po/cat-id-tbl.c	1999-10-25 21:21:21.000000000 +0100
+++ console-tools-0.2.3/po/cat-id-tbl.c	2003-05-22 12:09:06.000000000 +0100
@@ -38,13 +38,14 @@
   {"display only keymap-translated chars.", 23},
   {"display unicode-translated chars.", 24},
   {"set the timeout to N seconds.", 25},
-  {"timeout value must be numeric", 26},
-  {"no non-option arguments allowed", 27},
-  {"WARNING: Unicode mode is experimental -- output may be wrong\n", 28},
-  {"press any key (program terminates after %us of last keypress)...\n", 29},
-  {"keycode %3d %s\n", 30},
-  {"release", 31},
-  {"press", 32},
+  {"only one commands is allowed", 26},
+  {"timeout value must be numeric", 27},
+  {"no non-option arguments allowed", 28},
+  {"WARNING: Unicode mode is experimental -- output may be wrong\n", 29},
+  {"press any key (program terminates after %us of last keypress)...\n", 30},
+  {"keycode %3d %s\n", 31},
+  {"release", 32},
+  {"press", 33},
   {"\
 \n\
 Usage:\n\
@@ -52,135 +53,137 @@
 Each vt has his own copy of this bit. Use\n\
 \t%1$s [arg] < /dev/ttyn\n\
 to change the settings of another vt.\n\
-The setting before and after the change are reported.\n", 33},
-  {"Meta key sets high order bit\n", 34},
-  {"Meta key gives Esc prefix\n", 35},
-  {"Strange mode for Meta key?\n", 36},
-  {"Error reading current setting. Maybe stdin is not a VT?\n", 37},
-  {"unrecognized argument", 38},
-  {"old state:    ", 39},
-  {"new state:    ", 40},
+The setting before and after the change are reported.\n", 34},
+  {"Meta key sets high order bit\n", 35},
+  {"Meta key gives Esc prefix\n", 36},
+  {"Strange mode for Meta key?\n", 37},
+  {"Error reading current setting. Maybe stdin is not a VT?\n", 38},
+  {"unrecognized argument", 39},
+  {"old state:    ", 40},
+  {"new state:    ", 41},
   {"\
 Usage: %s [option]\n\
-Report and set keyboard mode\n", 41},
-  {"print this help information and exit", 42},
-  {"report version and exit", 43},
-  {"ASCII or 8bit mode (XLATE)", 44},
-  {"keycode mode (MEDIUMRAW)", 45},
-  {"UTF-8 mode (UNICODE)", 46},
-  {"scancode mode (RAW)", 47},
-  {"set mode", 48},
-  {"%s: unknown mode: %s\n", 49},
-  {": error reading keyboard mode\n", 50},
-  {"The keyboard is in raw (scancode) mode\n", 51},
-  {"The keyboard is in mediumraw (keycode) mode\n", 52},
-  {"The keyboard is in the default (ASCII) mode\n", 53},
-  {"The keyboard is in Unicode (UTF-8) mode\n", 54},
-  {"The keyboard is in some unknown mode\n", 55},
-  {": error setting keyboard mode\n", 56},
-  {"too many keydefinitions on one line", 57},
-  {"Usage: %s [option...] [mapfile...]\n", 58},
-  {"clear kernel compose table", 59},
-  {"load default keymap file", 60},
-  {"output a \"defkeymap.c\" to stdout", 61},
-  {"clear kernel string table", 62},
-  {"be silent", 63},
-  {"report the changes", 64},
-  {"report more changes", 65},
-  {"syntax error in map file\n", 66},
-  {"key bindings not changed\n", 67},
-  {"Cannot find %s\n", 68},
-  {"cannot open file %s\n", 69},
-  {"addmap called with bad index %d", 70},
-  {"adding map %d violates explicit keymaps line)", 71},
-  {"killkey called with bad index %d", 72},
-  {"killkey called with bad table %d", 73},
-  {"addkey called with bad index %d", 74},
-  {"addkey called with bad table %d", 75},
-  {"%s: addfunc called with bad func %d\n", 76},
-  {"%s: addfunc: func_buf overflow\n", 77},
-  {"compose table overflow\n", 78},
-  {"Warning: Compose char %4x ('%c','%c') > 0xFF will be truncated to %2x\n", 79},
-  {"  (Linux kernel < 2.3.X can't handle unicode compose chars properly)\n", 80},
-  {"Keymap %d: Permission denied\n", 81},
-  {"keycode %d, table %d = %d%s\n", 82},
-  {"    FAILED", 83},
-  {"failed to bind key %d to value %d\n", 84},
-  {"deallocate keymap %d\n", 85},
-  {"%s: could not deallocate keymap %d\n", 86},
-  {"%s: cannot deallocate or clear keymap\n", 87},
-  {"%s: failed to restore keyboard mode\n", 88},
+Report and set keyboard mode\n", 42},
+  {"print this help information and exit", 43},
+  {"report version and exit", 44},
+  {"ASCII or 8bit mode (XLATE)", 45},
+  {"keycode mode (MEDIUMRAW)", 46},
+  {"UTF-8 mode (UNICODE)", 47},
+  {"scancode mode (RAW)", 48},
+  {"set mode", 49},
+  {"%s: unknown mode: %s\n", 50},
+  {": error reading keyboard mode\n", 51},
+  {"The keyboard is in raw (scancode) mode\n", 52},
+  {"The keyboard is in mediumraw (keycode) mode\n", 53},
+  {"The keyboard is in the default (ASCII) mode\n", 54},
+  {"The keyboard is in Unicode (UTF-8) mode\n", 55},
+  {"The keyboard is in some unknown mode\n", 56},
+  {": error setting keyboard mode\n", 57},
+  {"too many keydefinitions on one line", 58},
+  {"Usage: %s [option...] [mapfile...]\n", 59},
+  {"clear kernel compose table", 60},
+  {"load default keymap file", 61},
+  {"output a \"defkeymap.c\" to stdout", 62},
+  {"clear kernel string table", 63},
+  {"be silent", 64},
+  {"report the changes", 65},
+  {"report more changes", 66},
+  {"syntax error in map file\n", 67},
+  {"key bindings not changed\n", 68},
+  {"Cannot find %s\n", 69},
+  {"cannot open file %s\n", 70},
+  {"addmap called with bad index %d", 71},
+  {"adding map %d violates explicit keymaps line)", 72},
+  {"killkey called with bad index %d", 73},
+  {"killkey called with bad table %d", 74},
+  {"addkey called with bad index %d", 75},
+  {"addkey called with bad table %d", 76},
+  {"%s: addfunc called with bad func %d\n", 77},
+  {"%s: addfunc: func_buf overflow\n", 78},
+  {"compose table overflow\n", 79},
+  {"Warning: Compose char %4x ('%c','%c') > 0xFF will be truncated to %2x\n", 80},
+  {"  (Linux kernel < 2.3.X can't handle unicode compose chars properly)\n", 81},
+  {"Keymap %d: Permission denied\n", 82},
+  {"keycode %d, table %d = %d%s\n", 83},
+  {"    FAILED", 84},
+  {"failed to bind key %d to value %d\n", 85},
+  {"deallocate keymap %d\n", 86},
+  {"%s: could not deallocate keymap %d\n", 87},
+  {"%s: cannot deallocate or clear keymap\n", 88},
+  {"%s: failed to restore keyboard mode\n", 89},
   {"\
 %s: warning: this map uses Unicode symbols\n\
-    (perhaps you want to do `kbd_mode -u'?)\n", 89},
-  {"failed to bind string '%s' to function %s\n", 90},
-  {"failed to clear string %s\n", 91},
-  {"too many compose definitions\n", 92},
-  {"KDSKBDIACR failed\n", 93},
-  {"impossible error in do_constant", 94},
+    (perhaps you want to do `kbd_mode -u'?)\n", 90},
+  {"failed to bind string '%s' to function %s\n", 91},
+  {"failed to clear string %s\n", 92},
+  {"too many compose definitions\n", 93},
+  {"KDSKBDIACR failed\n", 94},
+  {"impossible error in do_constant", 95},
   {"\
 \n\
-Changed %d key%s and %d string%s.\n", 95},
-  {"Loaded %d compose definition%s.\n", 96},
-  {"(No change in compose definitions.)\n", 97},
-  {"loadkeys: don't know how to compose for %s\n", 98},
+Changed %d key%s and %d string%s.\n", 96},
+  {"Loaded %d compose definition%s.\n", 97},
+  {"(No change in compose definitions.)\n", 98},
+  {"loadkeys: don't know how to compose for %s\n", 99},
   {"\
 Usage: %s\n\
-Print kernel scancode-to-keycode mapping table\n", 99},
-  {"Plain scancodes xx (hex) versus keycodes (dec)\n", 100},
-  {"0 is an error; for 1-88 (0x01-0x58) scancode equals keycode\n", 101},
+Print kernel scancode-to-keycode mapping table\n", 100},
+  {"Plain scancodes xx (hex) versus keycodes (dec)\n", 101},
+  {"0 is an error; for 1-88 (0x01-0x58) scancode equals keycode\n", 102},
   {"\
 \n\
 \n\
-Escaped scancodes e0 xx (hex)\n", 102},
-  {"failed to get keycode for scancode 0x%x\n", 103},
-  {"KDGKBENT at index 0 in table %d: ", 104},
-  {"%s: cannot find any keymaps?\n", 105},
-  {"%s: plain map not allocated? very strange ...\n", 106},
-  {"KDGKBENT at index %d in table %d: ", 107},
-  {"KDGKBDIACR failed\n", 108},
-  {"keycode range supported by kernel:           1 - %d\n", 109},
-  {"max number of actions bindable to a key:         %d\n", 110},
-  {"number of keymaps in actual use:                 %d\n", 111},
-  {"of which %d dynamically allocated\n", 112},
-  {"ranges of action codes supported by kernel:\n", 113},
-  {"number of function keys supported by kernel: %d\n", 114},
-  {"max nr of compose definitions: %d\n", 115},
-  {"nr of compose definitions in actual use: %d\n", 116},
+Escaped scancodes e0 xx (hex)\n", 103},
+  {"failed to get keycode for scancode 0x%x\n", 104},
+  {"KDGKBENT at index 0 in table %d: ", 105},
+  {"%s: cannot find any keymaps?\n", 106},
+  {"%s: plain map not allocated? very strange ...\n", 107},
+  {"KDGKBENT at index %d in table %d: ", 108},
+  {"KDGKBDIACR failed\n", 109},
+  {"keycode range supported by kernel:           1 - %d\n", 110},
+  {"max number of actions bindable to a key:         %d\n", 111},
+  {"number of keymaps in actual use:                 %d\n", 112},
+  {"of which %d dynamically allocated\n", 113},
+  {"ranges of action codes supported by kernel:\n", 114},
+  {"number of function keys supported by kernel: %d\n", 115},
+  {"max nr of compose definitions: %d\n", 116},
+  {"nr of compose definitions in actual use: %d\n", 117},
   {"\
 Symbols recognized by %s:\n\
 (numeric value, symbol)\n\
-\n", 117},
+\n", 118},
   {"\
 \n\
 The following synonyms are recognized:\n\
-\n", 118},
+\n", 119},
   {"\
 \n\
-Recognized modifier names and their column numbers:\n", 119},
-  {"impossible: not meta?\n", 120},
-  {"KDGKBSENT at index %d: ", 121},
-  {"Usage: %s [options...]\n", 122},
-  {"display information about keyboard driver", 123},
-  {"display above and symbols known to loadkeys", 124},
-  {"display keytable in hexadecimal notation", 125},
-  {"don't use short-hand notations, one row per keycode", 126},
-  {"one line per (modifier,keycode) pair", 127},
-  {"display only the function key strings", 128},
-  {"display only key bindings", 129},
-  {"choose output shape, where <shape> is:", 130},
-  {" 0 = default", 131},
-  {" 1 = same as --full-table", 132},
-  {" 2 = same as --separate-lines", 133},
-  {" 3 = one line per keycode, until 1st hole", 134},
-  {"display only compose key combinations", 135},
-  {"interpret character action codes to be from the", 136},
-  {"specified character set", 137},
-  {"display this help text and exit", 138},
-  {"display version information and exit", 139},
+Recognized modifier names and their column numbers:\n", 120},
+  {"impossible: not meta?\n", 121},
+  {"KDGKBSENT at index %d: ", 122},
+  {"Usage: %s [options...]\n", 123},
+  {"display information about keyboard driver", 124},
+  {"display above and symbols known to loadkeys", 125},
+  {"display keytable in hexadecimal notation", 126},
+  {"don't use short-hand notations, one row per keycode", 127},
+  {"one line per (modifier,keycode) pair", 128},
+  {"display only the function key strings", 129},
+  {"display only key bindings", 130},
+  {"choose output shape, where <shape> is:", 131},
+  {" 0 = default", 132},
+  {" 1 = same as --full-table", 133},
+  {" 2 = same as --separate-lines", 134},
+  {" 3 = one line per keycode, until 1st hole", 135},
+  {"display only compose key combinations", 136},
+  {"interpret character action codes to be from the", 137},
+  {"specified character set", 138},
+  {"display this help text and exit", 139},
+  {"display version information and exit", 140},
   {"\
 \n\
-available charsets:\n", 140},
+available charsets:\n", 141},
+  {"on ", 142},
+  {"off", 143},
   {"\
 Usage:\t%1$s [-v] [-L] [-D] [-F] [[+|-][ num | caps | scroll ]]\n\
 Thus,\n\
@@ -192,242 +195,242 @@
 (and these are usually reflected in the leds).\n\
 With -L, %1$s only sets the leds, and leaves the flags alone.\n\
 With -D, %1$s sets both the flags and the default flags, so\n\
-that a subsequent reset will not change the flags.\n", 141},
-  {"%s: unknown argument: %s\n", 142},
-  {"NumLock %s   CapsLock %s   ScrollLock %s\n", 143},
-  {"Error reading current led setting. Maybe stdin is not a VT?\n", 144},
-  {"Error reading current flags setting. Maybe an old kernel?\n", 145},
-  {"Error resetting ledmode\n", 146},
-  {"Current default flags:  ", 147},
-  {"Current flags:          ", 148},
-  {"Current leds:           ", 149},
-  {"Old default flags:    ", 150},
-  {"New default flags:    ", 151},
-  {"Old flags:            ", 152},
-  {"New flags:            ", 153},
-  {"Old leds:             ", 154},
-  {"New leds:             ", 155},
-  {"loadunimap: out of memory\n", 156},
-  {"Out of Memory\n", 157},
-  {"Out of Memory?\n", 158},
-  {"Warning: line too long in unicode map.\n", 159},
-  {"Bad input line: %s\n", 160},
-  {"unicode map: glyph number (0x%x) larger than font length\n", 161},
-  {"unicode map: bad end of range (0x%x)\n", 162},
+that a subsequent reset will not change the flags.\n", 144},
+  {"%s: unknown argument: %s\n", 145},
+  {"NumLock %s   CapsLock %s   ScrollLock %s\n", 146},
+  {"Error reading current led setting. Maybe stdin is not a VT?\n", 147},
+  {"Error reading current flags setting. Maybe an old kernel?\n", 148},
+  {"Error resetting ledmode\n", 149},
+  {"Current default flags:  ", 150},
+  {"Current flags:          ", 151},
+  {"Current leds:           ", 152},
+  {"Old default flags:    ", 153},
+  {"New default flags:    ", 154},
+  {"Old flags:            ", 155},
+  {"New flags:            ", 156},
+  {"Old leds:             ", 157},
+  {"New leds:             ", 158},
+  {"loadunimap: out of memory\n", 159},
+  {"Out of Memory\n", 160},
+  {"Out of Memory?\n", 161},
+  {"Warning: line too long in unicode map.\n", 162},
+  {"Bad input line: %s\n", 163},
+  {"unicode map: glyph number (0x%x) larger than font length\n", 164},
+  {"unicode map: bad end of range (0x%x)\n", 165},
   {"\
 unicode map: Corresponding to a range of font positions, there should be a \
-Unicode range\n", 163},
+Unicode range\n", 166},
   {"\
-unicode map: Bad Unicode range corresponding to font position range \
-0x%x-0x%x\n", 164},
+unicode map: Bad Unicode range corresponding to font position range 0x%x-0x%\
+x\n", 167},
   {"\
 unicode map: Unicode range U+%x-U+%x not of the same length as font position \
-range 0x%x-0x%x\n", 165},
-  {"unicode map: trailing junk (%s) ignored\n", 166},
-  {"Would save %d SFM entries in `%s'.\n", 167},
-  {"Couldnt get a file descriptor referring to the console\n", 168},
-  {"Unknown PSF mode number (%d).\n", 169},
-  {"Error: unknown charset `%s'.\n", 170},
-  {"assuming iso-8859-2 %s\n", 171},
-  {"assuming iso-8859-3 %s\n", 172},
-  {"assuming iso-8859-4 %s\n", 173},
-  {"unknown keysym `%s'\n", 174},
-  {"%s: %s child exited anormally with code %d.\n", 175},
-  {"%s: %s child was terminated by signal %d.\n", 176},
-  {"%s: %s child was stopped by signal %d.\n", 177},
-  {"Feeder", 178},
-  {"Decompressor", 179},
-  {"Identifier", 180},
-  {"chld_handler()", 181},
-  {"%s child exited OK.\n", 182},
-  {"fread magic", 183},
-  {"decompressor fork", 184},
-  {"decompressor: close file[1]", 185},
-  {"decompressor: close uncompressed[0]", 186},
-  {"decompressor: dup2 file[0]", 187},
-  {"decompressor: dup2 uncompressed[1]", 188},
-  {"Decompressor program not found: %s\n", 189},
-  {"decompressor: execlp", 190},
-  {"feeder fork", 191},
-  {"feeder: close uncompressed[0]", 192},
-  {"feeder: write zmagicbuf", 193},
-  {"feeder: feed", 194},
-  {"fread", 195},
-  {"identifier fork", 196},
-  {"identifier: close identified[0]", 197},
-  {"identifier: write magicIDbuf", 198},
-  {"identifier: feed", 199},
-  {"Zombie %d caught.\n", 200},
-  {"One for nothing.\n", 201},
-  {"Warning: ignoring a possible path (too long).", 202},
-  {"feeder", 203},
-  {"decompressor", 204},
-  {"identifier", 205},
-  {"findfile(): timeout waiting for undead child(ren) ?\n", 206},
-  {"Buffer overflow - aborting\n", 207},
-  {"Cannot stat map file", 208},
-  {"16bit screen-map MUST be a regular file.\n", 209},
-  {"fseek failed reading binary 16bit screen-map", 210},
-  {"Cannot read [new] map from file", 211},
-  {"Input screen-map is binary.\n", 212},
-  {"PIO_UNISCRNMAP ioctl", 213},
-  {"Assuming 8bit screen-map - MUST be a regular file.\n", 214},
-  {"fseek failed assuming 8bit screen-map", 215},
-  {"fseek() returned ESPIPE !\n", 216},
-  {"fseek for binary 8bit screen-map", 217},
-  {"Cannot read [old] map from file", 218},
-  {"PIO_SCRNMAP ioctl", 219},
-  {"Error parsing symbolic map\n", 220},
-  {"uni_screen_map_read_ascii() can't read line", 221},
-  {"GIO_UNISCRNMAP ioctl error", 222},
-  {"GIO_SCRNMAP ioctl error", 223},
-  {"Error writing map to file", 224},
-  {"%s: Unexpected arguments.\n", 225},
-  {"Usage:  %s [options] [commands]\n", 226},
-  {"List operations as they are done", 227},
-  {"Do not change the console state nor write to any file", 228},
+range 0x%x-0x%x\n", 168},
+  {"unicode map: trailing junk (%s) ignored\n", 169},
+  {"Would save %d SFM entries in `%s'.\n", 170},
+  {"Couldnt get a file descriptor referring to the console\n", 171},
+  {"Unknown PSF mode number (%d).\n", 172},
+  {"Error: unknown charset `%s'.\n", 173},
+  {"assuming iso-8859-2 %s\n", 174},
+  {"assuming iso-8859-3 %s\n", 175},
+  {"assuming iso-8859-4 %s\n", 176},
+  {"unknown keysym `%s'\n", 177},
+  {"%s: %s child exited anormally with code %d.\n", 178},
+  {"%s: %s child was terminated by signal %d.\n", 179},
+  {"%s: %s child was stopped by signal %d.\n", 180},
+  {"Feeder", 181},
+  {"Decompressor", 182},
+  {"Identifier", 183},
+  {"chld_handler()", 184},
+  {"%s child exited OK.\n", 185},
+  {"fread magic", 186},
+  {"decompressor fork", 187},
+  {"decompressor: close file[1]", 188},
+  {"decompressor: close uncompressed[0]", 189},
+  {"decompressor: dup2 file[0]", 190},
+  {"decompressor: dup2 uncompressed[1]", 191},
+  {"Decompressor program not found: %s\n", 192},
+  {"decompressor: execlp", 193},
+  {"feeder fork", 194},
+  {"feeder: close uncompressed[0]", 195},
+  {"feeder: write zmagicbuf", 196},
+  {"feeder: feed", 197},
+  {"fread", 198},
+  {"identifier fork", 199},
+  {"identifier: close identified[0]", 200},
+  {"identifier: write magicIDbuf", 201},
+  {"identifier: feed", 202},
+  {"Zombie %d caught.\n", 203},
+  {"One for nothing.\n", 204},
+  {"Warning: ignoring a possible path (too long).", 205},
+  {"feeder", 206},
+  {"decompressor", 207},
+  {"identifier", 208},
+  {"findfile(): timeout waiting for undead child(ren) ?\n", 209},
+  {"Buffer overflow - aborting\n", 210},
+  {"Cannot stat map file", 211},
+  {"16bit screen-map MUST be a regular file.\n", 212},
+  {"fseek failed reading binary 16bit screen-map", 213},
+  {"Cannot read [new] map from file", 214},
+  {"Input screen-map is binary.\n", 215},
+  {"PIO_UNISCRNMAP ioctl", 216},
+  {"Assuming 8bit screen-map - MUST be a regular file.\n", 217},
+  {"fseek failed assuming 8bit screen-map", 218},
+  {"fseek() returned ESPIPE !\n", 219},
+  {"fseek for binary 8bit screen-map", 220},
+  {"Cannot read [old] map from file", 221},
+  {"PIO_SCRNMAP ioctl", 222},
+  {"Error parsing symbolic map\n", 223},
+  {"uni_screen_map_read_ascii() can't read line", 224},
+  {"GIO_UNISCRNMAP ioctl error", 225},
+  {"GIO_SCRNMAP ioctl error", 226},
+  {"Error writing map to file", 227},
+  {"%s: Unexpected arguments.\n", 228},
+  {"Usage:  %s [options] [commands]\n", 229},
+  {"List operations as they are done", 230},
+  {"Do not change the console state nor write to any file", 231},
   {"\
 (N in 0..32) Choose the right font from a codepage that\n\
 contains three fonts (only 8/14/16 allowed then), or choose\n\
-default font, ie. \"default8xN\"", 229},
-  {"Suppress loading of a screen-font map [use with care]", 230},
-  {"When loading an ACM, activate G1 charset instead of G0", 231},
-  {"Use `device' as console device for ioctls", 232},
-  {"Load the console-font from specified file", 233},
-  {"Load a default font from a file", 234},
-  {"Restore ROM font (does not work with all kernels)", 235},
+default font, ie. \"default8xN\"", 232},
+  {"Suppress loading of a screen-font map [use with care]", 233},
+  {"When loading an ACM, activate G1 charset instead of G0", 234},
+  {"Use `device' as console device for ioctls", 235},
+  {"Load the console-font from specified file", 236},
+  {"Load a default font from a file", 237},
+  {"Restore ROM font (does not work with all kernels)", 238},
   {"\
 Load the SFM from specified file\n\
-(instead of the one in font-file, if any)", 236},
-  {"Merge SFM fallbacks from file into SFM", 237},
-  {"Load the ACM from specified file", 238},
-  {"Write current font to prefered format (now: psf-with-sfm)", 239},
-  {"Write current font to PSF file before loading a new one", 240},
-  {"Same as -old-font-psf, and add current SFM in the PSF file", 241},
-  {"Write current font to RAW file before loading a new one", 242},
-  {"Write current ACM to file before loading a new one", 243},
-  {"Write current SFM to file before loading a new one", 244},
-  {"too many `-' as filenames", 245},
-  {"--char-height argument should be in 1..31", 246},
-  {"only one font file is allowed", 247},
-  {"only one ACM is allowed", 248},
-  {"only one SFM is allowed", 249},
-  {"multiple requests for SFM handling", 250},
-  {"WARNING: not using a unimap may lead to erroneous display !\n", 251},
-  {"realloc fallback_files", 252},
-  {"only one output RAW font-file is allowed", 253},
-  {"only one output PSF font-file is allowed", 254},
-  {"only one output PSF+SFM font-file is allowed", 255},
-  {"only one output ACM file is allowed", 256},
-  {"only one output SFM file is allowed", 257},
-  {"unknown option", 258},
-  {"no non-option arguments are valid", 259},
-  {"nothing to do", 260},
-  {"Saving raw old font", 261},
-  {"Saving PSF old font", 262},
-  {"Saving PSF+unimap old font", 263},
-  {"Would save ACM to file `%s'.\n", 264},
-  {"Saving ACM to file `%s'.\n", 265},
-  {"Would load ACM from `%s'\n", 266},
-  {"Loading ACM from `%s'\n", 267},
-  {"Error reading ACM file.\n", 268},
-  {"Would read screen-font map from %s.\n", 269},
-  {"Reading screen-font map from %s.\n", 270},
-  {"Requesting SFM from kernel.\n", 271},
-  {"No valid SFM currently loaded. Aborting.\n", 272},
-  {"Reading SFM fallbacks from `%s'.\n", 273},
-  {"Read %u fallback entries.\n", 274},
-  {"WARNING: No SFM found in file or kernel ?  Ignoring fallback file.\n", 275},
-  {"Would set kernel SFM.\n", 276},
-  {"Setting kernel SFM.\n", 277},
-  {"Cannot find a default font file.\n", 278},
-  {"Cannot find default font file `default8x%02d'.\n", 279},
-  {"Cannot open font file `%s'.\n", 280},
-  {"Only fontsize 256 supported.\n", 281},
-  {"Would load %d-chars %dx%d font from file `%s'.\n", 282},
-  {"Loading %d-chars %dx%d font from file `%s'.\n", 283},
-  {"Reading default SFM from `%s'.\n", 284},
-  {"Cannot write SFM into non-PSF font-file.\n", 285},
-  {"Can only save 8bit-wide fonts for now, and font is %d-bit wide.\n", 286},
-  {"Can only save 256-chars fonts in RAW files, and font has %d chars.\n", 287},
-  {"Found nothing to save.\n", 288},
-  {"Would have saved 8x%d %s font file on `%s'%s.\n", 289},
-  {"Saved 8x%d %s font file on `%s'%s.\n", 290},
-  {", with SFM", 291},
-  {", without SFM", 292},
+(instead of the one in font-file, if any)", 239},
+  {"Merge SFM fallbacks from file into SFM", 240},
+  {"Load the ACM from specified file", 241},
+  {"Write current font to prefered format (now: psf-with-sfm)", 242},
+  {"Write current font to PSF file before loading a new one", 243},
+  {"Same as -old-font-psf, and add current SFM in the PSF file", 244},
+  {"Write current font to RAW file before loading a new one", 245},
+  {"Write current ACM to file before loading a new one", 246},
+  {"Write current SFM to file before loading a new one", 247},
+  {"too many `-' as filenames", 248},
+  {"--char-height argument should be in 1..31", 249},
+  {"only one font file is allowed", 250},
+  {"only one ACM is allowed", 251},
+  {"only one SFM is allowed", 252},
+  {"multiple requests for SFM handling", 253},
+  {"WARNING: not using a unimap may lead to erroneous display !\n", 254},
+  {"realloc fallback_files", 255},
+  {"only one output RAW font-file is allowed", 256},
+  {"only one output PSF font-file is allowed", 257},
+  {"only one output PSF+SFM font-file is allowed", 258},
+  {"only one output ACM file is allowed", 259},
+  {"only one output SFM file is allowed", 260},
+  {"unknown option", 261},
+  {"no non-option arguments are valid", 262},
+  {"nothing to do", 263},
+  {"Saving raw old font", 264},
+  {"Saving PSF old font", 265},
+  {"Saving PSF+unimap old font", 266},
+  {"Would save ACM to file `%s'.\n", 267},
+  {"Saving ACM to file `%s'.\n", 268},
+  {"Would load ACM from `%s'\n", 269},
+  {"Loading ACM from `%s'\n", 270},
+  {"Error reading ACM file.\n", 271},
+  {"Would read screen-font map from %s.\n", 272},
+  {"Reading screen-font map from %s.\n", 273},
+  {"Requesting SFM from kernel.\n", 274},
+  {"No valid SFM currently loaded. Aborting.\n", 275},
+  {"Reading SFM fallbacks from `%s'.\n", 276},
+  {"Read %u fallback entries.\n", 277},
+  {"WARNING: No SFM found in file or kernel ?  Ignoring fallback file.\n", 278},
+  {"Would set kernel SFM.\n", 279},
+  {"Setting kernel SFM.\n", 280},
+  {"Cannot find a default font file.\n", 281},
+  {"Cannot find default font file `default8x%02d'.\n", 282},
+  {"Cannot open font file `%s'.\n", 283},
+  {"Only fontsize 256 supported.\n", 284},
+  {"Would load %d-chars %dx%d font from file `%s'.\n", 285},
+  {"Loading %d-chars %dx%d font from file `%s'.\n", 286},
+  {"Reading default SFM from `%s'.\n", 287},
+  {"Cannot write SFM into non-PSF font-file.\n", 288},
+  {"Can only save 8bit-wide fonts for now, and font is %d-bit wide.\n", 289},
+  {"Can only save 256-chars fonts in RAW files, and font has %d chars.\n", 290},
+  {"Found nothing to save.\n", 291},
+  {"Would have saved 8x%d %s font file on `%s'%s.\n", 292},
+  {"Saved 8x%d %s font file on `%s'%s.\n", 293},
+  {", with SFM", 294},
+  {", without SFM", 295},
   {"\
 Usage: %s\n\
-Displays a screen-font's contents.\n", 293},
+Displays a screen-font's contents.\n", 296},
   {"\
 Usage: %s\n\
 Clears the Unicode map from the console.\n\
-Note: nowadays this kills kernel console output!\n", 294},
+Note: nowadays this kills kernel console output!\n", 297},
   {"\
 Usage: %s [console]\n\
-Dump the contents of the screen to stdout\n", 295},
-  {"dump contents of screen s", 296},
-  {"%s: Wrong number of args\n", 297},
-  {"Out of memory\n", 298},
-  {"Error reading %s\n", 299},
-  {"Could not use /dev/vcs*, trying TIOCLINUX\n", 300},
-  {"Out of memory.\n", 301},
-  {"couldn't read %s, and cannot ioctl dump\n", 302},
-  {"Strange ... screen is both %dx%d and %dx%d ??\n", 303},
-  {"Out of memory?\n", 304},
-  {"Error writing screen dump\n", 305},
+Dump the contents of the screen to stdout\n", 298},
+  {"dump contents of screen s", 299},
+  {"%s: Wrong number of args\n", 300},
+  {"Out of memory\n", 301},
+  {"Error reading %s\n", 302},
+  {"Could not use /dev/vcs*, trying TIOCLINUX\n", 303},
+  {"Out of memory.\n", 304},
+  {"couldn't read %s, and cannot ioctl dump\n", 305},
+  {"Strange ... screen is both %dx%d and %dx%d ??\n", 306},
+  {"Out of memory?\n", 307},
+  {"Error writing screen dump\n", 308},
   {"\
 Usage: %s ON|on|off\n\
 \n\
-Set VESA blanking on console.\n", 306},
-  {"turn blanking on", 307},
-  {"%s: argument '%s' should be 'ON', 'on' or 'off'\n", 308},
-  {"Usage: %s [option]\n", 309},
-  {"don't print result", 310},
-  {"Single-byte char mode.\n", 311},
+Set VESA blanking on console.\n", 309},
+  {"turn blanking on", 310},
+  {"%s: argument '%s' should be 'ON', 'on' or 'off'\n", 311},
+  {"Usage: %s [option]\n", 312},
+  {"don't print result", 313},
+  {"Single-byte char mode.\n", 314},
   {"\
 Usage:  %s COLSxROWS\n\
         %s COLS ROWS\n\
-        %s -lines ROWS, with ROWS one of 25, 28, 30, 34, 36, 40, 44, 50, 60\n", 312},
-  {"%s: Invalid number of columns: %s\n", 313},
-  {"%s: Invalid number of rows: %s\n", 314},
-  {"%s: Invalid arguments", 315},
-  {"%s: Unrecognized argument", 316},
-  {"%s: bad number of arguments\n", 317},
-  {"%s: cannot find videomode file %s\n", 318},
-  {"Invalid number of lines\n", 319},
-  {"Old mode: %dx%d  New mode: %dx%d\n", 320},
-  {"Old #scanlines: %d  New #scanlines: %d  Character height: %d\n", 321},
-  {"%s: the command `%s' failed\n", 322},
-  {"%s: don't forget to change TERM (maybe to con%dx%d or linux-%dx%d)\n", 323},
-  {"Also the variables LINES and COLUMNS may need adjusting.\n", 324},
-  {"%s: cannot get I/O permissions.\n", 325},
+        %s -lines ROWS, with ROWS one of 25, 28, 30, 34, 36, 40, 44, 50, 60\n", 315},
+  {"%s: Invalid number of columns: %s\n", 316},
+  {"%s: Invalid number of rows: %s\n", 317},
+  {"%s: Invalid arguments", 318},
+  {"%s: Unrecognized argument", 319},
+  {"%s: bad number of arguments\n", 320},
+  {"%s: cannot find videomode file %s\n", 321},
+  {"Invalid number of lines\n", 322},
+  {"Old mode: %dx%d  New mode: %dx%d\n", 323},
+  {"Old #scanlines: %d  New #scanlines: %d  Character height: %d\n", 324},
+  {"%s: the command `%s' failed\n", 325},
+  {"%s: don't forget to change TERM (maybe to con%dx%d or linux-%dx%d)\n", 326},
+  {"Also the variables LINES and COLUMNS may need adjusting.\n", 327},
+  {"%s: cannot get I/O permissions.\n", 328},
   {"\
 Usage: %s [N1 N2 ...]\n\
-Deallocate virtual terminal(s)\n", 326},
-  {"virtual terminal", 327},
-  {"%s: 0: illegal VT number\n", 328},
-  {"%s: VT 1 is the console and cannot be deallocated\n", 329},
-  {"%s: could not deallocate console %d\n", 330},
-  {"%s: deallocating all unused consoles failed\n", 331},
+Deallocate virtual terminal(s)\n", 329},
+  {"virtual terminal", 330},
+  {"%s: 0: illegal VT number\n", 331},
+  {"%s: VT 1 is the console and cannot be deallocated\n", 332},
+  {"%s: could not deallocate console %d\n", 333},
+  {"%s: deallocating all unused consoles failed\n", 334},
   {"\
 Usage: %s [vt_number]\n\
-Print foreground console\n", 332},
+Print foreground console\n", 335},
   {"\
 Usage: %s [vt_number]\n\
-Change virtual terminal\n", 333},
+Change virtual terminal\n", 336},
   {"\
 Usage: %s\n\
-Show time in upper right hand corner of the console screen\n", 334},
+Show time in upper right hand corner of the console screen\n", 337},
   {"\
 Usage: %s tty text\n\
-Put text into the input buffer of a virtual terminal.\n", 335},
-  {"device name", 336},
-  {"text to insert", 337},
-  {"%s: No tty specified.\n", 338},
-  {"%s: No text specified.\n", 339},
-  {"%s: too many arguments\n", 340},
-  {"%s: could not open tty\n", 341},
-  {"%s: TIOCSTI ioctl failed\n", 342},
+Put text into the input buffer of a virtual terminal.\n", 338},
+  {"device name", 339},
+  {"text to insert", 340},
+  {"%s: No tty specified.\n", 341},
+  {"%s: No text specified.\n", 342},
+  {"%s: too many arguments\n", 343},
+  {"%s: could not open tty\n", 344},
+  {"%s: TIOCSTI ioctl failed\n", 345},
 };
 
-int _msg_tbl_length = 342;
+int _msg_tbl_length = 345;
diff -ruN console-tools-0.2.3-old/po/console-tools.pot console-tools-0.2.3/po/console-tools.pot
--- console-tools-0.2.3-old/po/console-tools.pot	2003-05-22 12:09:06.000000000 +0100
+++ console-tools-0.2.3/po/console-tools.pot	2003-05-22 12:09:06.000000000 +0100
@@ -6,13 +6,13 @@
 msgid ""
 msgstr ""
 "Project-Id-Version: PACKAGE VERSION\n"
-"POT-Creation-Date: 1999-12-14 22:16+0100\n"
+"POT-Creation-Date: 2002-11-26 17:22+0000\n"
 "PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
 "Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
 "Language-Team: LANGUAGE <LL@li.org>\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=CHARSET\n"
-"Content-Transfer-Encoding: ENCODING\n"
+"Content-Transfer-Encoding: 8bit\n"
 
 #: fontfiletools/psfaddtable.c:30
 #, c-format
@@ -128,6 +128,10 @@
 msgid "set the timeout to N seconds."
 msgstr ""
 
+#: kbdtools/showkey.c:123
+msgid "only one commands is allowed"
+msgstr ""
+
 #: kbdtools/showkey.c:158
 msgid "timeout value must be numeric"
 msgstr ""
@@ -266,200 +270,200 @@
 msgid ": error setting keyboard mode\n"
 msgstr ""
 
-#: loadkeys.y:287
+#: loadkeys.y:284
 msgid "too many keydefinitions on one line"
 msgstr ""
 
-#: loadkeys.y:306
+#: loadkeys.y:303
 #, c-format
 msgid "Usage: %s [option...] [mapfile...]\n"
 msgstr ""
 
-#: loadkeys.y:308
+#: loadkeys.y:305
 msgid "clear kernel compose table"
 msgstr ""
 
-#: loadkeys.y:309
+#: loadkeys.y:306
 msgid "load default keymap file"
 msgstr ""
 
 #. FIXME: should print DEFKMAP
-#: loadkeys.y:310
+#: loadkeys.y:307
 msgid "output a \"defkeymap.c\" to stdout"
 msgstr ""
 
-#: loadkeys.y:311
+#: loadkeys.y:308
 msgid "clear kernel string table"
 msgstr ""
 
-#: loadkeys.y:312
+#: loadkeys.y:309
 msgid "be silent"
 msgstr ""
 
-#: loadkeys.y:313
+#: loadkeys.y:310
 msgid "report the changes"
 msgstr ""
 
-#: loadkeys.y:314
+#: loadkeys.y:311
 msgid "report more changes"
 msgstr ""
 
-#: loadkeys.y:392
+#: loadkeys.y:389
 msgid "syntax error in map file\n"
 msgstr ""
 
-#: loadkeys.y:394
+#: loadkeys.y:391
 msgid "key bindings not changed\n"
 msgstr ""
 
-#: loadkeys.y:482
+#: loadkeys.y:479
 #, c-format
 msgid "Cannot find %s\n"
 msgstr ""
 
-#: loadkeys.y:499
+#: loadkeys.y:496
 #, c-format
 msgid "cannot open file %s\n"
 msgstr ""
 
-#: loadkeys.y:524
+#: loadkeys.y:521
 #, c-format
 msgid "addmap called with bad index %d"
 msgstr ""
 
-#: loadkeys.y:529
+#: loadkeys.y:526
 #, c-format
 msgid "adding map %d violates explicit keymaps line)"
 msgstr ""
 
-#: loadkeys.y:543
+#: loadkeys.y:540
 #, c-format
 msgid "killkey called with bad index %d"
 msgstr ""
 
-#: loadkeys.y:545
+#: loadkeys.y:542
 #, c-format
 msgid "killkey called with bad table %d"
 msgstr ""
 
-#: loadkeys.y:559
+#: loadkeys.y:556
 #, c-format
 msgid "addkey called with bad index %d"
 msgstr ""
 
-#: loadkeys.y:561
+#: loadkeys.y:558
 #, c-format
 msgid "addkey called with bad table %d"
 msgstr ""
 
-#: loadkeys.y:605
+#: loadkeys.y:602
 #, c-format
 msgid "%s: addfunc called with bad func %d\n"
 msgstr ""
 
-#: loadkeys.y:628
+#: loadkeys.y:625
 #, c-format
 msgid "%s: addfunc: func_buf overflow\n"
 msgstr ""
 
-#: loadkeys.y:657
+#: loadkeys.y:654
 msgid "compose table overflow\n"
 msgstr ""
 
-#: loadkeys.y:666
+#: loadkeys.y:663
 #, c-format
 msgid "Warning: Compose char %4x ('%c','%c') > 0xFF will be truncated to %2x\n"
 msgstr ""
 
-#: loadkeys.y:669
+#: loadkeys.y:666
 msgid "  (Linux kernel < 2.3.X can't handle unicode compose chars properly)\n"
 msgstr ""
 
-#: loadkeys.y:709
+#: loadkeys.y:706
 #, c-format
 msgid "Keymap %d: Permission denied\n"
 msgstr ""
 
-#: loadkeys.y:718
+#: loadkeys.y:715
 #, c-format
 msgid "keycode %d, table %d = %d%s\n"
 msgstr ""
 
-#: loadkeys.y:719
+#: loadkeys.y:716
 msgid "    FAILED"
 msgstr ""
 
-#: loadkeys.y:721
+#: loadkeys.y:718
 #, c-format
 msgid "failed to bind key %d to value %d\n"
 msgstr ""
 
-#: loadkeys.y:734
+#: loadkeys.y:731
 #, c-format
 msgid "deallocate keymap %d\n"
 msgstr ""
 
-#: loadkeys.y:742
+#: loadkeys.y:739
 #, c-format
 msgid "%s: could not deallocate keymap %d\n"
 msgstr ""
 
-#: loadkeys.y:759
+#: loadkeys.y:756
 #, c-format
 msgid "%s: cannot deallocate or clear keymap\n"
 msgstr ""
 
-#: loadkeys.y:772
+#: loadkeys.y:769
 #, c-format
 msgid "%s: failed to restore keyboard mode\n"
 msgstr ""
 
-#: loadkeys.y:775
+#: loadkeys.y:772
 #, c-format
 msgid ""
 "%s: warning: this map uses Unicode symbols\n"
 "    (perhaps you want to do `kbd_mode -u'?)\n"
 msgstr ""
 
-#: loadkeys.y:823
+#: loadkeys.y:820
 #, c-format
 msgid "failed to bind string '%s' to function %s\n"
 msgstr ""
 
-#: loadkeys.y:832
+#: loadkeys.y:829
 #, c-format
 msgid "failed to clear string %s\n"
 msgstr ""
 
-#: loadkeys.y:850
+#: loadkeys.y:847
 msgid "too many compose definitions\n"
 msgstr ""
 
-#: loadkeys.y:857
+#: loadkeys.y:854
 msgid "KDSKBDIACR failed\n"
 msgstr ""
 
-#: loadkeys.y:918
+#: loadkeys.y:915
 msgid "impossible error in do_constant"
 msgstr ""
 
-#: loadkeys.y:939
+#: loadkeys.y:936
 #, c-format
 msgid ""
 "\n"
 "Changed %d key%s and %d string%s.\n"
 msgstr ""
 
-#: loadkeys.y:943
+#: loadkeys.y:940
 #, c-format
 msgid "Loaded %d compose definition%s.\n"
 msgstr ""
 
-#: loadkeys.y:946
+#: loadkeys.y:943
 msgid "(No change in compose definitions.)\n"
 msgstr ""
 
-#: loadkeys.y:983
+#: loadkeys.y:980
 #, c-format
 msgid "loadkeys: don't know how to compose for %s\n"
 msgstr ""
@@ -663,6 +667,14 @@
 "available charsets:\n"
 msgstr ""
 
+#: kbdtools/setleds.c:21
+msgid "on "
+msgstr ""
+
+#: kbdtools/setleds.c:21
+msgid "off"
+msgstr ""
+
 #: kbdtools/setleds.c:29
 #, c-format
 msgid ""
@@ -777,8 +789,8 @@
 #: lib/sfm-rd-ascii.c:123
 #, c-format
 msgid ""
-"unicode map: Bad Unicode range corresponding to font position range "
-"0x%x-0x%x\n"
+"unicode map: Bad Unicode range corresponding to font position range 0x%x-0x%"
+"x\n"
 msgstr ""
 
 #: lib/sfm-rd-ascii.c:131
@@ -1362,7 +1374,7 @@
 msgid "dump contents of screen s"
 msgstr ""
 
-#: vttools/chvt.c:59 vttools/screendump.c:72 vttools/setvesablank.c:81
+#: vttools/chvt.c:59 vttools/screendump.c:72 vttools/setvesablank.c:85
 #, c-format
 msgid "%s: Wrong number of args\n"
 msgstr ""
@@ -1414,7 +1426,7 @@
 msgid "turn blanking on"
 msgstr ""
 
-#: vttools/setvesablank.c:37
+#: vttools/setvesablank.c:39
 #, c-format
 msgid "%s: argument '%s' should be 'ON', 'on' or 'off'\n"
 msgstr ""
diff -ruN console-tools-0.2.3-old/screenfonttools/clrunimap.c console-tools-0.2.3/screenfonttools/clrunimap.c
--- console-tools-0.2.3-old/screenfonttools/clrunimap.c	1999-04-08 23:11:15.000000000 +0100
+++ console-tools-0.2.3/screenfonttools/clrunimap.c	2003-05-22 12:09:06.000000000 +0100
@@ -24,7 +24,7 @@
   OPT("-V --version      ", VERSIONDESC);
 }
 
-void main(int argc, char **argv)
+int main(int argc, char **argv)
 {
   struct unimapinit advice;
   int fd;
diff -ruN console-tools-0.2.3-old/screenfonttools/consolechars.c console-tools-0.2.3/screenfonttools/consolechars.c
--- console-tools-0.2.3-old/screenfonttools/consolechars.c	2003-05-22 12:09:06.000000000 +0100
+++ console-tools-0.2.3/screenfonttools/consolechars.c	2003-05-22 12:09:06.000000000 +0100
@@ -136,7 +136,7 @@
 char* default_font = "";
 char* rom_font = (char*)(-1);
 
-void main(int argc, char *argv[])
+int main(int argc, char *argv[])
 {
   char *ifil, *mfil, *ufil, *orfil, *opfil, *omfil, *oufil, *opufil, **fallback_files;
   int nb_fallback_files = 0;
diff -ruN console-tools-0.2.3-old/screenfonttools/showcfont.c console-tools-0.2.3/screenfonttools/showcfont.c
--- console-tools-0.2.3-old/screenfonttools/showcfont.c	1999-04-08 23:11:15.000000000 +0100
+++ console-tools-0.2.3/screenfonttools/showcfont.c	2003-05-22 15:15:49.000000000 +0100
@@ -5,7 +5,7 @@
 #include <sys/ioctl.h>
 #include <sys/types.h>
 #include <linux/kd.h>
-
+#include <stdlib.h>
 #include <lct/local.h>
 #include <lct/utils.h>
 #include <lct/console.h>
@@ -20,7 +20,7 @@
   OPT("-V --version      ", VERSIONDESC);
 }
 
-void main(int argc, char* argv[])
+int main(int argc, char* argv[])
 {
   int i, j, fontsize;
   char s[10];
diff -ruN console-tools-0.2.3-old/vttools/fgconsole.c console-tools-0.2.3/vttools/fgconsole.c
--- console-tools-0.2.3-old/vttools/fgconsole.c	1999-04-08 23:11:15.000000000 +0100
+++ console-tools-0.2.3/vttools/fgconsole.c	2003-05-22 14:18:19.000000000 +0100
@@ -19,7 +19,7 @@
   OPT("-V --version      ", VERSIONDESC);
 }
 
-void main(int argc, char **argv)
+int main(int argc, char **argv)
 {
   struct vt_stat vtstat;
   int fd;
@@ -36,4 +36,5 @@
       exit(1);
     }
   printf("%d\n", vtstat.v_active);
+  exit (0);
 }
diff -ruN console-tools-0.2.3-old/vttools/setvesablank.c console-tools-0.2.3/vttools/setvesablank.c
--- console-tools-0.2.3-old/vttools/setvesablank.c	2003-05-22 12:09:06.000000000 +0100
+++ console-tools-0.2.3/vttools/setvesablank.c	2003-05-22 15:12:45.000000000 +0100
@@ -6,7 +6,7 @@
 #include <stdio.h>
 #include <string.h>
 #include <sys/ioctl.h>
-
+#include <stdlib.h>
 #include <getopt.h>
 #include <lct/local.h>
 #include <lct/utils.h>
@@ -42,10 +42,10 @@
   }
 }
   
-void main(int argc, char *argv[]) 
+int main(int argc, char *argv[]) 
 {
   int fd, c;
-  struct { char ten, onoff; } arg;
+  struct { unsigned char ten, onoff; } arg;
   const struct option long_opts[] = {
     { "help", no_argument, NULL, 'h' },
     { "version", no_argument, NULL, 'V' },
@@ -55,8 +55,10 @@
 
   setuplocale();
   
-  progname = strip_path(argv[0]);
-  arg.onoff = -1;
+  progname = "setvesablank";
+  /* 255 => not set yet. Don't use signed chars; breaks on some archs */ 
+  arg.onoff = 255;   
+
 
   while ( (c = getopt_long (argc, argv, "Vhb:", long_opts, NULL)) != EOF) {
     switch (c) {
@@ -76,10 +78,10 @@
   }
 
 
-  if (arg.onoff == -1 && argc == optind+1)     
+  if (arg.onoff == 255 && argc == optind+1)     
     arg.onoff = blanking (argv[optind++]);
    
-  if (arg.onoff == -1 || argc != optind) {
+  if (arg.onoff == 255 || argc != optind) {
     fprintf (stderr, _("%s: Wrong number of args\n"),
 	     progname);
     exit(1);
diff -ruN console-tools-0.2.3-old/vttools/vt-is-UTF8.c console-tools-0.2.3/vttools/vt-is-UTF8.c
--- console-tools-0.2.3-old/vttools/vt-is-UTF8.c	2003-05-22 12:09:06.000000000 +0100
+++ console-tools-0.2.3/vttools/vt-is-UTF8.c	2003-05-22 12:09:06.000000000 +0100
@@ -30,7 +30,7 @@
     {0, 0, 0, 0}
 };
 
-void main (int argc, char* argv[])
+int main (int argc, char* argv[])
 {
   int x;
   int result;			       /* option handling */
diff -ruN console-tools-0.2.3-old/vttools/writevt.c console-tools-0.2.3/vttools/writevt.c
--- console-tools-0.2.3-old/vttools/writevt.c	1999-04-08 23:11:15.000000000 +0100
+++ console-tools-0.2.3/vttools/writevt.c	2003-05-22 14:18:39.000000000 +0100
@@ -8,6 +8,7 @@
 #include <termios.h>
 #include <sys/ioctl.h>
 #include <getopt.h>
+#include <stdlib.h>
 
 #include <lct/local.h>
 #include <lct/utils.h>
