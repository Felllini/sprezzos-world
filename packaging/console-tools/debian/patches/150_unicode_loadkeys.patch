diff -ruN console-tools-0.2.3-old/doc/man/loadkeys.1.in console-tools-0.2.3/doc/man/loadkeys.1.in
--- console-tools-0.2.3-old/doc/man/loadkeys.1.in	1999-04-08 22:29:41.000000000 +0100
+++ console-tools-0.2.3/doc/man/loadkeys.1.in	2003-08-12 22:57:39.000000000 +0100
@@ -11,6 +11,8 @@
 .B ] [
 .I \-q \-\-quiet
 .B ] [
+.I \-u \-\-unicode
+.B ] [
 .I \-v \-\-verbose
 .B [
 .I \-v \-\-verbose
@@ -139,6 +141,10 @@
 Print details about changes.  If used several times, be even more verbose.
 
 .TP
+.I \-u \-\-unicode
+Go into unicode mode; characters outputted will be in UTF\-8.
+
+.TP
 .I \-q \-\-quiet
 Do not print standard messages.
 
diff -ruN console-tools-0.2.3-old/kbdtools/analyze.c console-tools-0.2.3/kbdtools/analyze.c
--- console-tools-0.2.3-old/kbdtools/analyze.c	2003-08-12 22:57:39.000000000 +0100
+++ console-tools-0.2.3/kbdtools/analyze.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,2262 +0,0 @@
-/* A lexical scanner generated by flex */
-
-/* Scanner skeleton version:
- * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.91 96/09/10 16:58:48 vern Exp $
- */
-
-#define FLEX_SCANNER
-#define YY_FLEX_MAJOR_VERSION 2
-#define YY_FLEX_MINOR_VERSION 5
-
-#include <stdio.h>
-#include <errno.h>
-
-/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
-#ifdef c_plusplus
-#ifndef __cplusplus
-#define __cplusplus
-#endif
-#endif
-
-
-#ifdef __cplusplus
-
-#include <stdlib.h>
-#ifndef _WIN32
-#include <unistd.h>
-#endif
-
-/* Use prototypes in function declarations. */
-#define YY_USE_PROTOS
-
-/* The "const" storage-class-modifier is valid. */
-#define YY_USE_CONST
-
-#else	/* ! __cplusplus */
-
-#if __STDC__
-
-#define YY_USE_PROTOS
-#define YY_USE_CONST
-
-#endif	/* __STDC__ */
-#endif	/* ! __cplusplus */
-
-#ifdef __TURBOC__
- #pragma warn -rch
- #pragma warn -use
-#include <io.h>
-#include <stdlib.h>
-#define YY_USE_CONST
-#define YY_USE_PROTOS
-#endif
-
-#ifdef YY_USE_CONST
-#define yyconst const
-#else
-#define yyconst
-#endif
-
-
-#ifdef YY_USE_PROTOS
-#define YY_PROTO(proto) proto
-#else
-#define YY_PROTO(proto) ()
-#endif
-
-/* Returned upon end-of-file. */
-#define YY_NULL 0
-
-/* Promotes a possibly negative, possibly signed char to an unsigned
- * integer for use as an array index.  If the signed char is negative,
- * we want to instead treat it as an 8-bit unsigned char, hence the
- * double cast.
- */
-#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
-
-/* Enter a start condition.  This macro really ought to take a parameter,
- * but we do it the disgusting crufty way forced on us by the ()-less
- * definition of BEGIN.
- */
-#define BEGIN yy_start = 1 + 2 *
-
-/* Translate the current start state into a value that can be later handed
- * to BEGIN to return to the state.  The YYSTATE alias is for lex
- * compatibility.
- */
-#define YY_START ((yy_start - 1) / 2)
-#define YYSTATE YY_START
-
-/* Action number for EOF rule of a given start state. */
-#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
-
-/* Special action meaning "start processing a new file". */
-#define YY_NEW_FILE yyrestart( yyin )
-
-#define YY_END_OF_BUFFER_CHAR 0
-
-/* Size of default input buffer. */
-#define YY_BUF_SIZE 16384
-
-typedef struct yy_buffer_state *YY_BUFFER_STATE;
-
-extern int yyleng;
-extern FILE *yyin, *yyout;
-
-#define EOB_ACT_CONTINUE_SCAN 0
-#define EOB_ACT_END_OF_FILE 1
-#define EOB_ACT_LAST_MATCH 2
-
-/* The funky do-while in the following #define is used to turn the definition
- * int a single C statement (which needs a semi-colon terminator).  This
- * avoids problems with code like:
- *
- * 	if ( condition_holds )
- *		yyless( 5 );
- *	else
- *		do_something_else();
- *
- * Prior to using the do-while the compiler would get upset at the
- * "else" because it interpreted the "if" statement as being all
- * done when it reached the ';' after the yyless() call.
- */
-
-/* Return all but the first 'n' matched characters back to the input stream. */
-
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-		*yy_cp = yy_hold_char; \
-		YY_RESTORE_YY_MORE_OFFSET \
-		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
-		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
-		} \
-	while ( 0 )
-
-#define unput(c) yyunput( c, yytext_ptr )
-
-/* The following is because we cannot portably get our hands on size_t
- * (without autoconf's help, which isn't available because we want
- * flex-generated scanners to compile on their own).
- */
-typedef unsigned int yy_size_t;
-
-
-struct yy_buffer_state
-	{
-	FILE *yy_input_file;
-
-	char *yy_ch_buf;		/* input buffer */
-	char *yy_buf_pos;		/* current position in input buffer */
-
-	/* Size of input buffer in bytes, not including room for EOB
-	 * characters.
-	 */
-	yy_size_t yy_buf_size;
-
-	/* Number of characters read into yy_ch_buf, not including EOB
-	 * characters.
-	 */
-	int yy_n_chars;
-
-	/* Whether we "own" the buffer - i.e., we know we created it,
-	 * and can realloc() it to grow it, and should free() it to
-	 * delete it.
-	 */
-	int yy_is_our_buffer;
-
-	/* Whether this is an "interactive" input source; if so, and
-	 * if we're using stdio for input, then we want to use getc()
-	 * instead of fread(), to make sure we stop fetching input after
-	 * each newline.
-	 */
-	int yy_is_interactive;
-
-	/* Whether we're considered to be at the beginning of a line.
-	 * If so, '^' rules will be active on the next match, otherwise
-	 * not.
-	 */
-	int yy_at_bol;
-
-	/* Whether to try to fill the input buffer when we reach the
-	 * end of it.
-	 */
-	int yy_fill_buffer;
-
-	int yy_buffer_status;
-#define YY_BUFFER_NEW 0
-#define YY_BUFFER_NORMAL 1
-	/* When an EOF's been seen but there's still some text to process
-	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
-	 * shouldn't try reading from the input source any more.  We might
-	 * still have a bunch of tokens to match, though, because of
-	 * possible backing-up.
-	 *
-	 * When we actually see the EOF, we change the status to "new"
-	 * (via yyrestart()), so that the user can continue scanning by
-	 * just pointing yyin at a new input file.
-	 */
-#define YY_BUFFER_EOF_PENDING 2
-	};
-
-static YY_BUFFER_STATE yy_current_buffer = 0;
-
-/* We provide macros for accessing buffer states in case in the
- * future we want to put the buffer states in a more general
- * "scanner state".
- */
-#define YY_CURRENT_BUFFER yy_current_buffer
-
-
-/* yy_hold_char holds the character lost when yytext is formed. */
-static char yy_hold_char;
-
-static int yy_n_chars;		/* number of characters read into yy_ch_buf */
-
-
-int yyleng;
-
-/* Points to current character in buffer. */
-static char *yy_c_buf_p = (char *) 0;
-static int yy_init = 1;		/* whether we need to initialize */
-static int yy_start = 0;	/* start state number */
-
-/* Flag which is used to allow yywrap()'s to do buffer switches
- * instead of setting up a fresh yyin.  A bit of a hack ...
- */
-static int yy_did_buffer_switch_on_eof;
-
-void yyrestart YY_PROTO(( FILE *input_file ));
-
-void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
-void yy_load_buffer_state YY_PROTO(( void ));
-YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
-void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
-void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )
-
-YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
-YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));
-YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
-
-static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
-static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
-static void yy_flex_free YY_PROTO(( void * ));
-
-#define yy_new_buffer yy_create_buffer
-
-#define yy_set_interactive(is_interactive) \
-	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_is_interactive = is_interactive; \
-	}
-
-#define yy_set_bol(at_bol) \
-	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_at_bol = at_bol; \
-	}
-
-#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
-
-typedef unsigned char YY_CHAR;
-FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
-typedef int yy_state_type;
-extern char *yytext;
-#define yytext_ptr yytext
-
-static yy_state_type yy_get_previous_state YY_PROTO(( void ));
-static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
-static int yy_get_next_buffer YY_PROTO(( void ));
-static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
-
-/* Done after the current pattern has been matched and before the
- * corresponding action - sets up yytext.
- */
-#define YY_DO_BEFORE_ACTION \
-	yytext_ptr = yy_bp; \
-	yyleng = (int) (yy_cp - yy_bp); \
-	yy_hold_char = *yy_cp; \
-	*yy_cp = '\0'; \
-	yy_c_buf_p = yy_cp;
-
-#define YY_NUM_RULES 47
-#define YY_END_OF_BUFFER 48
-static yyconst short int yy_accept[452] =
-    {   0,
-        0,    0,    0,    0,   44,   44,    0,    0,   48,   46,
-        6,    5,   46,   39,   46,   11,   10,    9,   13,   13,
-        8,   46,   46,   46,   46,   46,   46,   46,   46,   46,
-       46,   46,   46,   46,   46,   46,   46,   46,   46,   46,
-       46,   14,   14,   14,   14,   14,   14,   14,   14,   14,
-       14,   14,   14,   14,   14,   14,   14,   14,   14,   14,
-       14,   44,   45,   47,    3,   47,    6,    0,    7,    0,
-        0,   13,    0,   13,    0,   31,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,   34,    0,    0,
-        0,    0,    0,    0,   33,    0,    0,    0,    4,    0,
-
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,   14,   14,   14,   14,   14,   14,   14,   14,   14,
-       14,   14,   14,   14,   14,   14,   14,   14,   14,   14,
-       14,   14,   14,   14,   14,   14,   14,   14,   14,   14,
-       14,   14,   14,   14,   14,   14,   14,   44,   41,   40,
-       42,   43,    0,    3,   38,    0,   38,    0,   13,   22,
-        0,   22,    0,    0,    0,    0,    0,    0,    0,    0,
-       35,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,   22,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,   14,   14,   14,   14,   14,   14,   14,
-
-       14,   14,   14,   14,   14,   14,   14,   14,   14,   14,
-       14,   14,   14,   14,   14,   14,   14,   14,   14,   14,
-       14,   14,   14,   14,   14,   14,   40,    2,   37,   36,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-       14,   14,   14,   14,   14,   14,   14,   14,   14,   14,
-       14,   14,   14,   14,   14,   14,   14,   14,   14,   14,
-       14,   14,   14,   14,   14,   14,   14,   14,   14,   14,
-
-       14,   14,   14,   14,   14,   14,   14,   14,   40,   36,
-        0,    0,   23,    0,    0,    0,   26,   27,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,   19,   20,
-        0,   20,    0,    0,   32,    0,    0,    0,    0,    0,
-        0,   20,    0,   14,   14,   14,   14,   14,   14,   14,
-       14,   14,   14,   14,   14,   14,   14,   14,   14,   14,
-       14,   14,   14,   14,   14,   14,   14,   14,   14,   14,
-       14,   14,   14,   14,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,   24,   25,
-       18,   18,   12,    0,    0,    0,    0,    0,    0,   18,
-
-       14,   14,   14,   14,   14,   14,   14,   14,   14,   14,
-       14,   14,   14,   14,   14,   14,   14,   14,   14,   14,
-       14,   14,   14,   14,   14,    0,   15,   30,   21,   17,
-       16,   29,    1,   14,   14,   14,   14,   14,   14,   14,
-        1,    0,    1,   14,    0,   14,    0,   14,   28,   14,
-        0
-    } ;
-
-static yyconst int yy_ec[256] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    2,    4,    5,    6,    1,    1,    1,    7,    1,
-        1,    1,    8,    9,   10,    1,    1,   11,   12,   12,
-       12,   12,   12,   12,   12,   13,   13,    1,    1,    1,
-       14,    1,    1,    1,   15,   16,   17,   18,   19,   20,
-       21,   22,   23,   24,   25,   26,   27,   28,   29,   30,
-       24,   31,   32,   33,   34,   24,   24,   35,   36,   24,
-        1,   37,    1,    1,   38,    1,   39,   16,   40,   41,
-
-       42,   43,   44,   45,   46,   24,   47,   48,   49,   50,
-       51,   52,   24,   53,   54,   55,   56,   24,   24,   35,
-       57,   24,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1
-    } ;
-
-static yyconst int yy_meta[58] =
-    {   0,
-        1,    1,    2,    1,    3,    1,    1,    1,    1,    1,
-        4,    4,    4,    1,    4,    4,    4,    4,    4,    4,
-        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
-        5,    5,    5,    5,    5,    5,    3,    5,    4,    4,
-        4,    4,    4,    5,    5,    5,    5,    5,    5,    5,
-        5,    5,    5,    5,    5,    5,    5
-    } ;
-
-static yyconst short int yy_base[465] =
-    {   0,
-        0,    0,   57,    0,  110,  111,  663,  662,  666,  669,
-      663,  669,  661,  669,  626,  669,  669,  669,  106,  108,
-      669,   96,  101,   98,  112,  101,  107,  120,  106,  128,
-      659,  113,  113,  610,  610,  617,  608,  609,  114,  605,
-      601,  140,    0,  141,  111,  157,  143,  147,  156,  151,
-      171,  158,  132,  603,  603,  610,  601,  602,  136,  598,
-      594,    0,  669,  193,  669,  121,  645,  643,  669,  638,
-      202,  126,    0,  204,  152,  669,  164,  629,  193,  612,
-      603,  173,  588,  609,  586,  602,  580,  669,  621,  596,
-      611,  602,  586,  578,  669,    0,  596,  573,  669,  177,
-
-      185,  589,  177,  574,  573,  585,  567,  584,  576,  568,
-      564,    0,  191,    0,  195,  604,  206,  587,  578,  186,
-      563,  584,  561,  577,  555,    0,  596,  571,  586,  577,
-      561,  553,    0,  571,  548,  196,  198,  564,  188,  549,
-      548,  560,  542,  559,  551,  543,  539,    0,  669,  230,
-      669,  669,  140,  669,  669,  587,  586,  237,    0,  235,
-      229,  237,  561,  561,  557,  563,  535,  535,  531,  537,
-      669,  173,  237,  561,  537,  562,  558,  537,  533,    0,
-      563,  538,  245,  523,  523,  519,  525,  524,  212,  525,
-      527,  523,  529,  247,  249,  250,  536,  536,  532,  538,
-
-      510,  510,  506,  512,    0,  245,  252,  536,  512,  537,
-      533,  512,  508,  538,  513,  253,  498,  498,  494,  500,
-      499,  225,  500,  502,  498,  504,  284,  669,  669,  669,
-      291,  247,  511,  488,  487,  507,  509,  506,  273,  246,
-      485,  482,  279,  505,  518,  481,  492,  479,  490,  500,
-      477,  493,  497,  469,  473,    0,  496,  473,  467,  465,
-      467,  464,  258,  460,  464,  475,  463,  457,  461,  462,
-      478,  261,  455,  454,  474,  476,  473,  282,  258,  452,
-      449,  283,  472,  485,  448,  459,  446,  457,  467,  444,
-      460,  464,  436,  440,  463,  440,  434,  432,  434,  431,
-
-      267,  427,  431,  442,  430,  424,  428,  429,  669,  669,
-      469,  284,  669,  456,  442,  444,  669,  669,  430,  429,
-      416,  418,  450,  437,  425,  413,  423,  411,  669,  291,
-      441,  292,  417,    0,  669,  418,  405,  407,  416,  415,
-      403,  271,  410,    0,  289,  434,  420,  422,    0,    0,
-      408,  407,  394,  396,  428,  415,  403,  391,  401,  389,
-        0,  299,  419,  300,  395,    0,  396,  383,  385,  394,
-      393,  381,  279,  388,  318,  398,  411,  403,  373,  372,
-      384,  377,  405,  391,  380,  367,  378,  365,  669,  669,
-      386,  363,  669,  361,  373,  366,  371,  370,  357,  356,
-
-      319,  376,  389,  381,  351,  347,  351,  337,  348,  334,
-      323,  307,  312,  299,    0,    0,  320,  297,  295,  307,
-      300,  305,  304,  291,  286,  306,  669,  669,  669,  669,
-      669,  669,  332,  309,    0,    0,    0,    0,    0,    0,
-      280,  318,  278,  320,  308,  309,  320,  329,  669,    0,
-      669,  368,  373,  378,  383,  385,  390,  395,  400,  272,
-      262,  204,  128,  121
-    } ;
-
-static yyconst short int yy_def[465] =
-    {   0,
-      451,    1,  451,    3,  452,  452,  453,  453,  451,  451,
-      451,  451,  454,  451,  455,  451,  451,  451,  451,  451,
-      451,  451,  451,  451,  451,  451,  451,  451,  451,  451,
-      451,  451,  451,  451,  451,  451,  451,  451,  451,  451,
-      451,  456,  456,  456,  456,  456,  456,  456,  456,  456,
-      456,  456,  456,  456,  456,  456,  456,  456,  456,  456,
-      456,  457,  451,  451,  451,  458,  451,  454,  451,  451,
-      459,  451,  460,  451,  451,  451,  451,  451,  451,  451,
-      451,  451,  451,  451,  451,  451,  451,  451,  451,  451,
-      451,  451,  451,  451,  451,  461,  451,  451,  451,  451,
-
-      451,  451,  451,  451,  451,  451,  451,  451,  451,  451,
-      451,  456,  456,  456,  456,  456,  456,  456,  456,  456,
-      456,  456,  456,  456,  456,  456,  456,  456,  456,  456,
-      456,  456,  456,  456,  456,  456,  456,  456,  456,  456,
-      456,  456,  456,  456,  456,  456,  456,  457,  451,  451,
-      451,  451,  458,  451,  451,  451,  451,  451,  460,  451,
-      451,  451,  451,  451,  451,  451,  451,  451,  451,  451,
-      451,  451,  451,  451,  451,  451,  451,  451,  451,  462,
-      451,  451,  451,  451,  451,  451,  451,  451,  451,  451,
-      451,  451,  451,  456,  456,  456,  456,  456,  456,  456,
-
-      456,  456,  456,  456,  456,  456,  456,  456,  456,  456,
-      456,  456,  456,  456,  456,  456,  456,  456,  456,  456,
-      456,  456,  456,  456,  456,  456,  451,  451,  451,  451,
-      451,  451,  451,  451,  451,  451,  451,  451,  451,  451,
-      451,  451,  451,  451,  451,  451,  451,  451,  451,  451,
-      451,  451,  451,  451,  451,  463,  451,  451,  451,  451,
-      451,  451,  451,  451,  451,  451,  451,  451,  451,  451,
-      456,  456,  456,  456,  456,  456,  456,  456,  456,  456,
-      456,  456,  456,  456,  456,  456,  456,  456,  456,  456,
-      456,  456,  456,  456,  456,  456,  456,  456,  456,  456,
-
-      456,  456,  456,  456,  456,  456,  456,  456,  451,  451,
-      451,  451,  451,  451,  451,  451,  451,  451,  451,  451,
-      451,  451,  451,  451,  451,  451,  451,  451,  451,  451,
-      451,  451,  451,  464,  451,  451,  451,  451,  451,  451,
-      451,  451,  451,  456,  456,  456,  456,  456,  456,  456,
-      456,  456,  456,  456,  456,  456,  456,  456,  456,  456,
-      456,  456,  456,  456,  456,  456,  456,  456,  456,  456,
-      456,  456,  456,  456,  451,  451,  451,  451,  451,  451,
-      451,  451,  451,  451,  451,  451,  451,  451,  451,  451,
-      451,  451,  451,  451,  451,  451,  451,  451,  451,  451,
-
-      456,  456,  456,  456,  456,  456,  456,  456,  456,  456,
-      456,  456,  456,  456,  456,  456,  456,  456,  456,  456,
-      456,  456,  456,  456,  456,  451,  451,  451,  451,  451,
-      451,  451,  451,  456,  456,  456,  456,  456,  456,  456,
-      456,  451,  451,  456,  451,  456,  451,  456,  451,  456,
-        0,  451,  451,  451,  451,  451,  451,  451,  451,  451,
-      451,  451,  451,  451
-    } ;
-
-static yyconst short int yy_nxt[727] =
-    {   0,
-       10,   11,   12,   13,   14,   13,   15,   16,   17,   18,
-       19,   20,   20,   21,   22,   10,   23,   10,   10,   24,
-       10,   10,   10,   10,   25,   10,   10,   10,   26,   27,
-       10,   28,   29,   30,   10,   10,   31,   10,   32,   33,
-       10,   10,   34,   10,   10,   35,   36,   10,   10,   10,
-       37,   38,   10,   39,   40,   41,   10,   10,   11,   12,
-       13,   14,   13,   15,   16,   17,   18,   19,   20,   20,
-       21,   42,   43,   44,   43,   43,   45,   43,   43,   43,
-       43,   46,   43,   43,   43,   47,   48,   43,   49,   50,
-       51,   43,   43,   31,   10,   52,   53,   43,   43,   54,
-
-       43,   43,   55,   56,   43,   43,   43,   57,   58,   43,
-       59,   60,   61,   43,   63,   63,   72,   72,   74,   74,
-       74,   75,   78,  154,  393,  154,   84,   76,   88,   79,
-       86,  334,   89,   80,   95,   96,   72,   72,  100,  122,
-       73,   91,  154,   77,  228,   81,   64,   64,   85,   76,
-       88,   82,   92,   87,   90,   83,   95,  102,  109,   97,
-      101,  123,  116,  103,   93,  113,   76,  104,  110,  117,
-      126,  114,  127,  118,   94,  124,  138,  129,   96,  133,
-      145,   98,  139,  136,  160,  119,  140,  115,  130,  244,
-      146,  120,  126,  114,  128,  121,  161,  149,  125,  245,
-
-      131,  133,  134,  150,  150,  137,  161,  256,  157,  161,
-      132,  114,  158,  158,   74,   74,   74,  161,  162,  164,
-      165,  168,  169,  194,  135,  185,  186,  195,  195,  151,
-      195,  161,  198,  199,  202,  203,  218,  219,  232,  183,
-      227,  227,  152,  230,  232,  195,  232,  231,  231,  196,
-      195,  265,  216,  246,  232,  233,  232,  234,  232,  232,
-      266,  283,  232,  247,  303,  180,  232,  271,  285,  312,
-      273,  284,  232,  304,  232,  159,  248,  319,  286,  443,
-      235,  443,  232,  345,  272,  249,  272,  272,  259,  351,
-      272,  287,  312,  274,  309,  309,  297,  310,  317,  320,
-
-      288,  311,  311,  318,  317,  317,  345,  349,  349,  318,
-      318,  352,  350,  350,  349,  375,  389,  389,  389,  350,
-      401,  390,  390,  390,  415,  415,  415,  426,  426,  416,
-      416,  416,  442,  443,  449,  444,  445,  375,  446,  440,
-      447,  448,  401,  450,  439,  438,  441,  437,  436,  435,
-      440,  440,  439,  438,  442,  426,  434,  444,  449,  445,
-      439,  446,  447,  448,  438,  439,  438,  450,   62,   62,
-       62,   62,   62,   65,   65,   65,   65,   65,   68,   68,
-       68,   68,   68,   70,  437,   70,   70,   70,  112,  112,
-      148,  148,  436,  148,  148,  153,  153,  153,  153,  153,
-
-      156,  435,  156,  156,  156,  435,  437,  436,  435,  432,
-      431,  430,  433,  429,  428,  427,  432,  432,  431,  430,
-      431,  430,  431,  430,  429,  428,  427,  427,  429,  428,
-      427,  425,  424,  423,  422,  421,  420,  419,  418,  417,
-      414,  413,  412,  411,  410,  409,  408,  407,  406,  405,
-      404,  403,  402,  400,  399,  398,  397,  396,  395,  394,
-      392,  391,  388,  387,  386,  385,  384,  383,  382,  381,
-      380,  379,  378,  377,  376,  310,  366,  374,  373,  361,
-      372,  371,  370,  369,  368,  367,  344,  366,  366,  365,
-      364,  363,  362,  361,  361,  360,  359,  358,  357,  356,
-
-      355,  354,  353,  348,  347,  346,  344,  344,  344,  335,
-      343,  342,  329,  341,  340,  339,  338,  337,  336,  313,
-      335,  335,  333,  332,  331,  330,  329,  329,  328,  327,
-      326,  325,  324,  323,  322,  321,  316,  315,  314,  313,
-      313,  313,  308,  307,  306,  305,  302,  301,  300,  299,
-      298,  296,  295,  294,  293,  292,  291,  290,  289,  282,
-      281,  280,  279,  278,  277,  276,  275,  270,  269,  268,
-      267,  264,  263,  262,  261,  260,  258,  257,  255,  254,
-      253,  252,  251,  250,  243,  242,  241,  240,  239,  238,
-      237,  236,  229,  229,  226,  225,  224,  223,  222,  221,
-
-      205,  220,  217,  215,  214,  213,  212,  211,  210,  209,
-      208,  207,  206,  205,  205,  204,  201,  200,  197,  193,
-      192,  191,  190,  189,  188,  171,  187,  184,  182,  181,
-      179,  178,  177,  176,  175,  174,  173,  172,  171,  171,
-      170,  167,  166,  163,  155,   69,   67,  147,  133,  144,
-      126,  143,  142,  141,  111,   95,  108,   88,  107,  106,
-      105,   99,   71,   69,   67,  451,   66,   66,    9,  451,
-      451,  451,  451,  451,  451,  451,  451,  451,  451,  451,
-      451,  451,  451,  451,  451,  451,  451,  451,  451,  451,
-      451,  451,  451,  451,  451,  451,  451,  451,  451,  451,
-
-      451,  451,  451,  451,  451,  451,  451,  451,  451,  451,
-      451,  451,  451,  451,  451,  451,  451,  451,  451,  451,
-      451,  451,  451,  451,  451,  451
-    } ;
-
-static yyconst short int yy_chk[727] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    3,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    5,    6,   19,   19,   20,   20,
-       20,   22,   23,   66,  464,   66,   24,   22,   26,   23,
-       25,  463,   27,   23,   29,   30,   72,   72,   32,   45,
-       19,   28,  153,   22,  153,   23,    5,    6,   24,   22,
-       26,   23,   28,   25,   27,   23,   29,   33,   39,   30,
-       32,   45,   44,   33,   28,   42,   32,   33,   39,   44,
-       47,   42,   48,   44,   28,   46,   53,   49,   51,   50,
-       59,   30,   53,   52,   75,   44,   53,   42,   49,  172,
-       59,   44,   47,   42,   48,   44,   77,   64,   46,  172,
-
-       49,   50,   51,   64,   64,   52,   75,  462,   71,  100,
-       49,   52,   71,   71,   74,   74,   74,  101,   77,   79,
-       79,   82,   82,  113,   51,  103,  103,  115,  136,   64,
-      137,  100,  117,  117,  120,  120,  139,  139,  161,  101,
-      150,  150,   64,  158,  160,  113,  162,  158,  158,  115,
-      136,  189,  137,  173,  183,  160,  194,  162,  195,  196,
-      189,  206,  216,  173,  222,  461,  161,  194,  207,  232,
-      196,  206,  160,  222,  162,  460,  173,  240,  207,  443,
-      162,  441,  183,  272,  194,  173,  195,  196,  183,  279,
-      216,  207,  232,  196,  227,  227,  216,  231,  239,  240,
-
-      207,  231,  231,  239,  243,  263,  272,  278,  282,  243,
-      263,  279,  278,  282,  301,  312,  330,  332,  342,  301,
-      345,  330,  332,  342,  362,  364,  373,  375,  401,  362,
-      364,  373,  426,  433,  447,  434,  442,  312,  444,  425,
-      445,  446,  345,  448,  424,  423,  422,  421,  420,  419,
-      418,  417,  414,  413,  426,  375,  401,  434,  447,  442,
-      412,  444,  445,  446,  411,  410,  409,  448,  452,  452,
-      452,  452,  452,  453,  453,  453,  453,  453,  454,  454,
-      454,  454,  454,  455,  408,  455,  455,  455,  456,  456,
-      457,  457,  407,  457,  457,  458,  458,  458,  458,  458,
-
-      459,  406,  459,  459,  459,  405,  404,  403,  402,  400,
-      399,  398,  397,  396,  395,  394,  392,  391,  388,  387,
-      386,  385,  384,  383,  382,  381,  380,  379,  378,  377,
-      376,  374,  372,  371,  370,  369,  368,  367,  365,  363,
-      360,  359,  358,  357,  356,  355,  354,  353,  352,  351,
-      348,  347,  346,  343,  341,  340,  339,  338,  337,  336,
-      333,  331,  328,  327,  326,  325,  324,  323,  322,  321,
-      320,  319,  316,  315,  314,  311,  308,  307,  306,  305,
-      304,  303,  302,  300,  299,  298,  297,  296,  295,  294,
-      293,  292,  291,  290,  289,  288,  287,  286,  285,  284,
-
-      283,  281,  280,  277,  276,  275,  274,  273,  271,  270,
-      269,  268,  267,  266,  265,  264,  262,  261,  260,  259,
-      258,  257,  255,  254,  253,  252,  251,  250,  249,  248,
-      247,  246,  245,  244,  242,  241,  238,  237,  236,  235,
-      234,  233,  226,  225,  224,  223,  221,  220,  219,  218,
-      217,  215,  214,  213,  212,  211,  210,  209,  208,  204,
-      203,  202,  201,  200,  199,  198,  197,  193,  192,  191,
-      190,  188,  187,  186,  185,  184,  182,  181,  179,  178,
-      177,  176,  175,  174,  170,  169,  168,  167,  166,  165,
-      164,  163,  157,  156,  147,  146,  145,  144,  143,  142,
-
-      141,  140,  138,  135,  134,  132,  131,  130,  129,  128,
-      127,  125,  124,  123,  122,  121,  119,  118,  116,  111,
-      110,  109,  108,  107,  106,  105,  104,  102,   98,   97,
-       94,   93,   92,   91,   90,   89,   87,   86,   85,   84,
-       83,   81,   80,   78,   70,   68,   67,   61,   60,   58,
-       57,   56,   55,   54,   41,   40,   38,   37,   36,   35,
-       34,   31,   15,   13,   11,    9,    8,    7,  451,  451,
-      451,  451,  451,  451,  451,  451,  451,  451,  451,  451,
-      451,  451,  451,  451,  451,  451,  451,  451,  451,  451,
-      451,  451,  451,  451,  451,  451,  451,  451,  451,  451,
-
-      451,  451,  451,  451,  451,  451,  451,  451,  451,  451,
-      451,  451,  451,  451,  451,  451,  451,  451,  451,  451,
-      451,  451,  451,  451,  451,  451
-    } ;
-
-static yy_state_type yy_last_accepting_state;
-static char *yy_last_accepting_cpos;
-
-/* The intent behind this definition is that it'll catch
- * any uses of REJECT which flex missed.
- */
-#define REJECT reject_used_but_not_detected
-#define yymore() yymore_used_but_not_detected
-#define YY_MORE_ADJ 0
-#define YY_RESTORE_YY_MORE_OFFSET
-char *yytext;
-#line 1 "analyze.l"
-#define INITIAL 0
-#line 2 "analyze.l"
-#include <stdlib.h>
-#include <linux/kd.h>
-#include <lct/utils.h>
-#include "loadkeys.h"
-
-extern int ksymtocode(char *s);
-
-extern int line_nr;
-extern int verbose;				  /* loadkeys.y */
-extern char pathname[];				  /* idem */
-int	yylval;
-int	rvalct;
-struct kbsentry kbs_buf;
-char *p, *pmax;
-char *filename;
-
-#undef yywrap
-extern int yywrap(void);
-extern int yyerror(char *s);
-extern void stringovfl(void);
-extern void lkfatal(char *s);
-extern void lkfatal1(char *s, char *s2);
-extern void open_include(char *s);
-void lkfatal(char *);
-void lkfatal0(char *, int);
-void lkfatal1(char *, char *);
-#define RVALUE 1
-
-#define STR 2
-
-#define INCLSTR 3
-
-#line 710 "lex.yy.c"
-
-/* Macros after this point can all be overridden by user definitions in
- * section 1.
- */
-
-#ifndef YY_SKIP_YYWRAP
-#ifdef __cplusplus
-extern "C" int yywrap YY_PROTO(( void ));
-#else
-extern int yywrap YY_PROTO(( void ));
-#endif
-#endif
-
-#ifndef YY_NO_UNPUT
-static void yyunput YY_PROTO(( int c, char *buf_ptr ));
-#endif
-
-#ifndef yytext_ptr
-static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
-#endif
-
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen YY_PROTO(( yyconst char * ));
-#endif
-
-#ifndef YY_NO_INPUT
-#ifdef __cplusplus
-static int yyinput YY_PROTO(( void ));
-#else
-static int input YY_PROTO(( void ));
-#endif
-#endif
-
-#if YY_STACK_USED
-static int yy_start_stack_ptr = 0;
-static int yy_start_stack_depth = 0;
-static int *yy_start_stack = 0;
-#ifndef YY_NO_PUSH_STATE
-static void yy_push_state YY_PROTO(( int new_state ));
-#endif
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state YY_PROTO(( void ));
-#endif
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state YY_PROTO(( void ));
-#endif
-
-#else
-#define YY_NO_PUSH_STATE 1
-#define YY_NO_POP_STATE 1
-#define YY_NO_TOP_STATE 1
-#endif
-
-#ifdef YY_MALLOC_DECL
-YY_MALLOC_DECL
-#else
-#if __STDC__
-#ifndef __cplusplus
-#include <stdlib.h>
-#endif
-#else
-/* Just try to get by without declaring the routines.  This will fail
- * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
- * or sizeof(void*) != sizeof(int).
- */
-#endif
-#endif
-
-/* Amount of stuff to slurp up with each read. */
-#ifndef YY_READ_BUF_SIZE
-#define YY_READ_BUF_SIZE 8192
-#endif
-
-/* Copy whatever the last rule matched to the standard output. */
-
-#ifndef ECHO
-/* This used to be an fputs(), but since the string might contain NUL's,
- * we now use fwrite().
- */
-#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
-#endif
-
-/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
- * is returned in "result".
- */
-#ifndef YY_INPUT
-#define YY_INPUT(buf,result,max_size) \
-	if ( yy_current_buffer->yy_is_interactive ) \
-		{ \
-		int c = '*', n; \
-		for ( n = 0; n < max_size && \
-			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
-			buf[n] = (char) c; \
-		if ( c == '\n' ) \
-			buf[n++] = (char) c; \
-		if ( c == EOF && ferror( yyin ) ) \
-			YY_FATAL_ERROR( "input in flex scanner failed" ); \
-		result = n; \
-		} \
-	else \
-		{ \
-		errno=0; \
-		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
-			{ \
-			if( errno != EINTR) \
-				{ \
-				YY_FATAL_ERROR( "input in flex scanner failed" ); \
-				break; \
-				} \
-			errno=0; \
-			clearerr(yyin); \
-			} \
-		}
-#endif
-
-/* No semi-colon after return; correct usage is to write "yyterminate();" -
- * we don't want an extra ';' after the "return" because that will cause
- * some compilers to complain about unreachable statements.
- */
-#ifndef yyterminate
-#define yyterminate() return YY_NULL
-#endif
-
-/* Number of entries by which start-condition stack grows. */
-#ifndef YY_START_STACK_INCR
-#define YY_START_STACK_INCR 25
-#endif
-
-/* Report a fatal error. */
-#ifndef YY_FATAL_ERROR
-#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
-#endif
-
-/* Default declaration of generated scanner - a define so the user can
- * easily add parameters.
- */
-#ifndef YY_DECL
-#define YY_DECL int yylex YY_PROTO(( void ))
-#endif
-
-/* Code executed at the beginning of each rule, after yytext and yyleng
- * have been set up.
- */
-#ifndef YY_USER_ACTION
-#define YY_USER_ACTION
-#endif
-
-/* Code executed at the end of each rule. */
-#ifndef YY_BREAK
-#define YY_BREAK break;
-#endif
-
-#define YY_RULE_SETUP \
-	YY_USER_ACTION
-
-YY_DECL
-	{
-	register yy_state_type yy_current_state;
-	register char *yy_cp, *yy_bp;
-	register int yy_act;
-
-#line 66 "analyze.l"
-
-#line 874 "lex.yy.c"
-
-	if ( yy_init )
-		{
-		yy_init = 0;
-
-#ifdef YY_USER_INIT
-		YY_USER_INIT;
-#endif
-
-		if ( ! yy_start )
-			yy_start = 1;	/* first start state */
-
-		if ( ! yyin )
-			yyin = stdin;
-
-		if ( ! yyout )
-			yyout = stdout;
-
-		if ( ! yy_current_buffer )
-			yy_current_buffer =
-				yy_create_buffer( yyin, YY_BUF_SIZE );
-
-		yy_load_buffer_state();
-		}
-
-	while ( 1 )		/* loops until end-of-file is reached */
-		{
-		yy_cp = yy_c_buf_p;
-
-		/* Support of yytext. */
-		*yy_cp = yy_hold_char;
-
-		/* yy_bp points to the position in yy_ch_buf of the start of
-		 * the current run.
-		 */
-		yy_bp = yy_cp;
-
-		yy_current_state = yy_start;
-yy_match:
-		do
-			{
-			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
-			if ( yy_accept[yy_current_state] )
-				{
-				yy_last_accepting_state = yy_current_state;
-				yy_last_accepting_cpos = yy_cp;
-				}
-			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-				{
-				yy_current_state = (int) yy_def[yy_current_state];
-				if ( yy_current_state >= 452 )
-					yy_c = yy_meta[(unsigned int) yy_c];
-				}
-			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-			++yy_cp;
-			}
-		while ( yy_base[yy_current_state] != 669 );
-
-yy_find_action:
-		yy_act = yy_accept[yy_current_state];
-		if ( yy_act == 0 )
-			{ /* have to back up */
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
-			yy_act = yy_accept[yy_current_state];
-			}
-
-		YY_DO_BEFORE_ACTION;
-
-
-do_action:	/* This label is used only to access EOF actions. */
-
-
-		switch ( yy_act )
-	{ /* beginning of action switch */
-			case 0: /* must back up */
-			/* undo the effects of YY_DO_BEFORE_ACTION */
-			*yy_cp = yy_hold_char;
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
-			goto yy_find_action;
-
-case 1:
-YY_RULE_SETUP
-#line 67 "analyze.l"
-{BEGIN(INCLSTR);}
-	YY_BREAK
-case 2:
-YY_RULE_SETUP
-#line 68 "analyze.l"
-{ int l; char *s;
-			 l = strlen(yytext);
-			 s = (char*)xmalloc(l);
-			 strcpy(s, yytext+1);
-			 s[l-2] = 0;		/* wipe out " */
-			 open_include(s);
-			 BEGIN(0);
-			}
-	YY_BREAK
-case 3:
-YY_RULE_SETUP
-#line 76 "analyze.l"
-{
-			  yyerror("expected filename between quotes");
-			  BEGIN(0); }
-	YY_BREAK
-case 4:
-YY_RULE_SETUP
-#line 79 "analyze.l"
-{line_nr++;}
-	YY_BREAK
-case 5:
-YY_RULE_SETUP
-#line 80 "analyze.l"
-{line_nr++;BEGIN(0);return(EOL);}
-	YY_BREAK
-case 6:
-YY_RULE_SETUP
-#line 81 "analyze.l"
-; /* do nothing */
-	YY_BREAK
-case 7:
-*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
-yy_c_buf_p = yy_cp -= 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 82 "analyze.l"
-; /* do nothing */
-	YY_BREAK
-case 8:
-YY_RULE_SETUP
-#line 83 "analyze.l"
-{BEGIN(RVALUE);rvalct=0;return(EQUALS);}
-	YY_BREAK
-case 9:
-YY_RULE_SETUP
-#line 84 "analyze.l"
-{return(DASH);}
-	YY_BREAK
-case 10:
-YY_RULE_SETUP
-#line 85 "analyze.l"
-{return(COMMA);}
-	YY_BREAK
-case 11:
-YY_RULE_SETUP
-#line 86 "analyze.l"
-{return(PLUS);}
-	YY_BREAK
-case 12:
-YY_RULE_SETUP
-#line 87 "analyze.l"
-{yylval=strtol(yytext+1,NULL,16);return(UNUMBER);}
-	YY_BREAK
-case 13:
-YY_RULE_SETUP
-#line 88 "analyze.l"
-{yylval=strtol(yytext,NULL,0);return(NUMBER);}
-	YY_BREAK
-case 14:
-YY_RULE_SETUP
-#line 89 "analyze.l"
-{return((yylval=ksymtocode(yytext))==-1?ERROR:LITERAL);}
-	YY_BREAK
-case 15:
-YY_RULE_SETUP
-#line 90 "analyze.l"
-{return(CHARSET);}
-	YY_BREAK
-case 16:
-YY_RULE_SETUP
-#line 91 "analyze.l"
-{return(KEYMAPS);}
-	YY_BREAK
-case 17:
-YY_RULE_SETUP
-#line 92 "analyze.l"
-{return(KEYCODE);}
-	YY_BREAK
-case 18:
-YY_RULE_SETUP
-#line 93 "analyze.l"
-{BEGIN(RVALUE);return(STRING);}
-	YY_BREAK
-case 19:
-YY_RULE_SETUP
-#line 94 "analyze.l"
-{return(PLAIN);}
-	YY_BREAK
-case 20:
-YY_RULE_SETUP
-#line 95 "analyze.l"
-{return(SHIFT);}
-	YY_BREAK
-case 21:
-YY_RULE_SETUP
-#line 96 "analyze.l"
-{return(CONTROL);}
-	YY_BREAK
-case 22:
-YY_RULE_SETUP
-#line 97 "analyze.l"
-{return(ALT);}
-	YY_BREAK
-case 23:
-YY_RULE_SETUP
-#line 98 "analyze.l"
-{return(ALTGR);}
-	YY_BREAK
-case 24:
-YY_RULE_SETUP
-#line 99 "analyze.l"
-{return(SHIFTL);}
-	YY_BREAK
-case 25:
-YY_RULE_SETUP
-#line 100 "analyze.l"
-{return(SHIFTR);}
-	YY_BREAK
-case 26:
-YY_RULE_SETUP
-#line 101 "analyze.l"
-{return(CTRLL);}
-	YY_BREAK
-case 27:
-YY_RULE_SETUP
-#line 102 "analyze.l"
-{return(CTRLR);}
-	YY_BREAK
-case 28:
-YY_RULE_SETUP
-#line 103 "analyze.l"
-{return(ALT_IS_META);}
-	YY_BREAK
-case 29:
-YY_RULE_SETUP
-#line 104 "analyze.l"
-{return(STRINGS);}
-	YY_BREAK
-case 30:
-YY_RULE_SETUP
-#line 105 "analyze.l"
-{return(COMPOSE);}
-	YY_BREAK
-case 31:
-YY_RULE_SETUP
-#line 106 "analyze.l"
-{return(AS);}
-	YY_BREAK
-case 32:
-YY_RULE_SETUP
-#line 107 "analyze.l"
-{return(USUAL);}
-	YY_BREAK
-case 33:
-YY_RULE_SETUP
-#line 108 "analyze.l"
-{BEGIN(RVALUE); return(TO);}
-	YY_BREAK
-case 34:
-YY_RULE_SETUP
-#line 109 "analyze.l"
-{return(ON);}
-	YY_BREAK
-case 35:
-YY_RULE_SETUP
-#line 110 "analyze.l"
-{return(FOR);}
-	YY_BREAK
-case 36:
-YY_RULE_SETUP
-#line 111 "analyze.l"
-{yylval = strtol(yytext+2,NULL,8); return(CCHAR);}
-	YY_BREAK
-case 37:
-YY_RULE_SETUP
-#line 112 "analyze.l"
-{yylval = yytext[2]; return(CCHAR);}
-	YY_BREAK
-case 38:
-YY_RULE_SETUP
-#line 113 "analyze.l"
-{yylval = yytext[1]; return(CCHAR);}
-	YY_BREAK
-case 39:
-YY_RULE_SETUP
-#line 114 "analyze.l"
-{p=kbs_buf.kb_string;
-				pmax=p+sizeof(kbs_buf.kb_string)-1;
-				BEGIN(STR);}
-	YY_BREAK
-case 40:
-YY_RULE_SETUP
-#line 117 "analyze.l"
-{if(p>=pmax)stringovfl();*p++=strtol(yytext+1,NULL,8);}
-	YY_BREAK
-case 41:
-YY_RULE_SETUP
-#line 118 "analyze.l"
-{if(p>=pmax)stringovfl();*p++='"';}
-	YY_BREAK
-case 42:
-YY_RULE_SETUP
-#line 119 "analyze.l"
-{if(p>=pmax)stringovfl();*p++='\\';}
-	YY_BREAK
-case 43:
-YY_RULE_SETUP
-#line 120 "analyze.l"
-{if(p>=pmax)stringovfl();*p++='\n';}
-	YY_BREAK
-case 44:
-YY_RULE_SETUP
-#line 121 "analyze.l"
-{char *ptmp=p;p+=strlen(yytext);
-				if(p>pmax)stringovfl();strcpy(ptmp,yytext);}
-	YY_BREAK
-case 45:
-YY_RULE_SETUP
-#line 123 "analyze.l"
-{*p='\0';BEGIN(0);return(STRLITERAL); /*"*/}
-	YY_BREAK
-case 46:
-YY_RULE_SETUP
-#line 124 "analyze.l"
-{return(ERROR); /* report any unknown characters */}
-	YY_BREAK
-case 47:
-YY_RULE_SETUP
-#line 125 "analyze.l"
-ECHO;
-	YY_BREAK
-#line 1207 "lex.yy.c"
-case YY_STATE_EOF(INITIAL):
-case YY_STATE_EOF(RVALUE):
-case YY_STATE_EOF(STR):
-case YY_STATE_EOF(INCLSTR):
-	yyterminate();
-
-	case YY_END_OF_BUFFER:
-		{
-		/* Amount of text matched not including the EOB char. */
-		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
-
-		/* Undo the effects of YY_DO_BEFORE_ACTION. */
-		*yy_cp = yy_hold_char;
-		YY_RESTORE_YY_MORE_OFFSET
-
-		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
-			{
-			/* We're scanning a new file or input source.  It's
-			 * possible that this happened because the user
-			 * just pointed yyin at a new source and called
-			 * yylex().  If so, then we have to assure
-			 * consistency between yy_current_buffer and our
-			 * globals.  Here is the right place to do so, because
-			 * this is the first action (other than possibly a
-			 * back-up) that will match for the new input source.
-			 */
-			yy_n_chars = yy_current_buffer->yy_n_chars;
-			yy_current_buffer->yy_input_file = yyin;
-			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
-			}
-
-		/* Note that here we test for yy_c_buf_p "<=" to the position
-		 * of the first EOB in the buffer, since yy_c_buf_p will
-		 * already have been incremented past the NUL character
-		 * (since all states make transitions on EOB to the
-		 * end-of-buffer state).  Contrast this with the test
-		 * in input().
-		 */
-		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
-			{ /* This was really a NUL. */
-			yy_state_type yy_next_state;
-
-			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
-
-			yy_current_state = yy_get_previous_state();
-
-			/* Okay, we're now positioned to make the NUL
-			 * transition.  We couldn't have
-			 * yy_get_previous_state() go ahead and do it
-			 * for us because it doesn't know how to deal
-			 * with the possibility of jamming (and we don't
-			 * want to build jamming into it because then it
-			 * will run more slowly).
-			 */
-
-			yy_next_state = yy_try_NUL_trans( yy_current_state );
-
-			yy_bp = yytext_ptr + YY_MORE_ADJ;
-
-			if ( yy_next_state )
-				{
-				/* Consume the NUL. */
-				yy_cp = ++yy_c_buf_p;
-				yy_current_state = yy_next_state;
-				goto yy_match;
-				}
-
-			else
-				{
-				yy_cp = yy_c_buf_p;
-				goto yy_find_action;
-				}
-			}
-
-		else switch ( yy_get_next_buffer() )
-			{
-			case EOB_ACT_END_OF_FILE:
-				{
-				yy_did_buffer_switch_on_eof = 0;
-
-				if ( yywrap() )
-					{
-					/* Note: because we've taken care in
-					 * yy_get_next_buffer() to have set up
-					 * yytext, we can now set up
-					 * yy_c_buf_p so that if some total
-					 * hoser (like flex itself) wants to
-					 * call the scanner after we return the
-					 * YY_NULL, it'll still work - another
-					 * YY_NULL will get returned.
-					 */
-					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
-
-					yy_act = YY_STATE_EOF(YY_START);
-					goto do_action;
-					}
-
-				else
-					{
-					if ( ! yy_did_buffer_switch_on_eof )
-						YY_NEW_FILE;
-					}
-				break;
-				}
-
-			case EOB_ACT_CONTINUE_SCAN:
-				yy_c_buf_p =
-					yytext_ptr + yy_amount_of_matched_text;
-
-				yy_current_state = yy_get_previous_state();
-
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
-				goto yy_match;
-
-			case EOB_ACT_LAST_MATCH:
-				yy_c_buf_p =
-				&yy_current_buffer->yy_ch_buf[yy_n_chars];
-
-				yy_current_state = yy_get_previous_state();
-
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
-				goto yy_find_action;
-			}
-		break;
-		}
-
-	default:
-		YY_FATAL_ERROR(
-			"fatal flex scanner internal error--no action found" );
-	} /* end of action switch */
-		} /* end of scanning one token */
-	} /* end of yylex */
-
-
-/* yy_get_next_buffer - try to read in a new buffer
- *
- * Returns a code representing an action:
- *	EOB_ACT_LAST_MATCH -
- *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
- *	EOB_ACT_END_OF_FILE - end of file
- */
-
-static int yy_get_next_buffer()
-	{
-	register char *dest = yy_current_buffer->yy_ch_buf;
-	register char *source = yytext_ptr;
-	register int number_to_move, i;
-	int ret_val;
-
-	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
-		YY_FATAL_ERROR(
-		"fatal flex scanner internal error--end of buffer missed" );
-
-	if ( yy_current_buffer->yy_fill_buffer == 0 )
-		{ /* Don't try to fill the buffer, so this is an EOF. */
-		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
-			{
-			/* We matched a single character, the EOB, so
-			 * treat this as a final EOF.
-			 */
-			return EOB_ACT_END_OF_FILE;
-			}
-
-		else
-			{
-			/* We matched some text prior to the EOB, first
-			 * process it.
-			 */
-			return EOB_ACT_LAST_MATCH;
-			}
-		}
-
-	/* Try to read more data. */
-
-	/* First move last chars to start of buffer. */
-	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
-
-	for ( i = 0; i < number_to_move; ++i )
-		*(dest++) = *(source++);
-
-	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
-		/* don't do the read, it's not guaranteed to return an EOF,
-		 * just force an EOF
-		 */
-		yy_current_buffer->yy_n_chars = yy_n_chars = 0;
-
-	else
-		{
-		int num_to_read =
-			yy_current_buffer->yy_buf_size - number_to_move - 1;
-
-		while ( num_to_read <= 0 )
-			{ /* Not enough room in the buffer - grow it. */
-#ifdef YY_USES_REJECT
-			YY_FATAL_ERROR(
-"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
-#else
-
-			/* just a shorter name for the current buffer */
-			YY_BUFFER_STATE b = yy_current_buffer;
-
-			int yy_c_buf_p_offset =
-				(int) (yy_c_buf_p - b->yy_ch_buf);
-
-			if ( b->yy_is_our_buffer )
-				{
-				int new_size = b->yy_buf_size * 2;
-
-				if ( new_size <= 0 )
-					b->yy_buf_size += b->yy_buf_size / 8;
-				else
-					b->yy_buf_size *= 2;
-
-				b->yy_ch_buf = (char *)
-					/* Include room in for 2 EOB chars. */
-					yy_flex_realloc( (void *) b->yy_ch_buf,
-							 b->yy_buf_size + 2 );
-				}
-			else
-				/* Can't grow it, we don't own it. */
-				b->yy_ch_buf = 0;
-
-			if ( ! b->yy_ch_buf )
-				YY_FATAL_ERROR(
-				"fatal error - scanner input buffer overflow" );
-
-			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
-
-			num_to_read = yy_current_buffer->yy_buf_size -
-						number_to_move - 1;
-#endif
-			}
-
-		if ( num_to_read > YY_READ_BUF_SIZE )
-			num_to_read = YY_READ_BUF_SIZE;
-
-		/* Read in more data. */
-		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
-			yy_n_chars, num_to_read );
-
-		yy_current_buffer->yy_n_chars = yy_n_chars;
-		}
-
-	if ( yy_n_chars == 0 )
-		{
-		if ( number_to_move == YY_MORE_ADJ )
-			{
-			ret_val = EOB_ACT_END_OF_FILE;
-			yyrestart( yyin );
-			}
-
-		else
-			{
-			ret_val = EOB_ACT_LAST_MATCH;
-			yy_current_buffer->yy_buffer_status =
-				YY_BUFFER_EOF_PENDING;
-			}
-		}
-
-	else
-		ret_val = EOB_ACT_CONTINUE_SCAN;
-
-	yy_n_chars += number_to_move;
-	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
-	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
-
-	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
-
-	return ret_val;
-	}
-
-
-/* yy_get_previous_state - get the state just before the EOB char was reached */
-
-static yy_state_type yy_get_previous_state()
-	{
-	register yy_state_type yy_current_state;
-	register char *yy_cp;
-
-	yy_current_state = yy_start;
-
-	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
-		{
-		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
-		if ( yy_accept[yy_current_state] )
-			{
-			yy_last_accepting_state = yy_current_state;
-			yy_last_accepting_cpos = yy_cp;
-			}
-		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-			{
-			yy_current_state = (int) yy_def[yy_current_state];
-			if ( yy_current_state >= 452 )
-				yy_c = yy_meta[(unsigned int) yy_c];
-			}
-		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-		}
-
-	return yy_current_state;
-	}
-
-
-/* yy_try_NUL_trans - try to make a transition on the NUL character
- *
- * synopsis
- *	next_state = yy_try_NUL_trans( current_state );
- */
-
-#ifdef YY_USE_PROTOS
-static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
-#else
-static yy_state_type yy_try_NUL_trans( yy_current_state )
-yy_state_type yy_current_state;
-#endif
-	{
-	register int yy_is_jam;
-	register char *yy_cp = yy_c_buf_p;
-
-	register YY_CHAR yy_c = 1;
-	if ( yy_accept[yy_current_state] )
-		{
-		yy_last_accepting_state = yy_current_state;
-		yy_last_accepting_cpos = yy_cp;
-		}
-	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-		{
-		yy_current_state = (int) yy_def[yy_current_state];
-		if ( yy_current_state >= 452 )
-			yy_c = yy_meta[(unsigned int) yy_c];
-		}
-	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-	yy_is_jam = (yy_current_state == 451);
-
-	return yy_is_jam ? 0 : yy_current_state;
-	}
-
-
-#ifndef YY_NO_UNPUT
-#ifdef YY_USE_PROTOS
-static void yyunput( int c, register char *yy_bp )
-#else
-static void yyunput( c, yy_bp )
-int c;
-register char *yy_bp;
-#endif
-	{
-	register char *yy_cp = yy_c_buf_p;
-
-	/* undo effects of setting up yytext */
-	*yy_cp = yy_hold_char;
-
-	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
-		{ /* need to shift things up to make room */
-		/* +2 for EOB chars. */
-		register int number_to_move = yy_n_chars + 2;
-		register char *dest = &yy_current_buffer->yy_ch_buf[
-					yy_current_buffer->yy_buf_size + 2];
-		register char *source =
-				&yy_current_buffer->yy_ch_buf[number_to_move];
-
-		while ( source > yy_current_buffer->yy_ch_buf )
-			*--dest = *--source;
-
-		yy_cp += (int) (dest - source);
-		yy_bp += (int) (dest - source);
-		yy_current_buffer->yy_n_chars =
-			yy_n_chars = yy_current_buffer->yy_buf_size;
-
-		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
-			YY_FATAL_ERROR( "flex scanner push-back overflow" );
-		}
-
-	*--yy_cp = (char) c;
-
-
-	yytext_ptr = yy_bp;
-	yy_hold_char = *yy_cp;
-	yy_c_buf_p = yy_cp;
-	}
-#endif	/* ifndef YY_NO_UNPUT */
-
-
-#ifdef __cplusplus
-static int yyinput()
-#else
-static int input()
-#endif
-	{
-	int c;
-
-	*yy_c_buf_p = yy_hold_char;
-
-	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
-		{
-		/* yy_c_buf_p now points to the character we want to return.
-		 * If this occurs *before* the EOB characters, then it's a
-		 * valid NUL; if not, then we've hit the end of the buffer.
-		 */
-		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
-			/* This was really a NUL. */
-			*yy_c_buf_p = '\0';
-
-		else
-			{ /* need more input */
-			int offset = yy_c_buf_p - yytext_ptr;
-			++yy_c_buf_p;
-
-			switch ( yy_get_next_buffer() )
-				{
-				case EOB_ACT_LAST_MATCH:
-					/* This happens because yy_g_n_b()
-					 * sees that we've accumulated a
-					 * token and flags that we need to
-					 * try matching the token before
-					 * proceeding.  But for input(),
-					 * there's no matching to consider.
-					 * So convert the EOB_ACT_LAST_MATCH
-					 * to EOB_ACT_END_OF_FILE.
-					 */
-
-					/* Reset buffer status. */
-					yyrestart( yyin );
-
-					/* fall through */
-
-				case EOB_ACT_END_OF_FILE:
-					{
-					if ( yywrap() )
-						return EOF;
-
-					if ( ! yy_did_buffer_switch_on_eof )
-						YY_NEW_FILE;
-#ifdef __cplusplus
-					return yyinput();
-#else
-					return input();
-#endif
-					}
-
-				case EOB_ACT_CONTINUE_SCAN:
-					yy_c_buf_p = yytext_ptr + offset;
-					break;
-				}
-			}
-		}
-
-	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
-	*yy_c_buf_p = '\0';	/* preserve yytext */
-	yy_hold_char = *++yy_c_buf_p;
-
-
-	return c;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yyrestart( FILE *input_file )
-#else
-void yyrestart( input_file )
-FILE *input_file;
-#endif
-	{
-	if ( ! yy_current_buffer )
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
-
-	yy_init_buffer( yy_current_buffer, input_file );
-	yy_load_buffer_state();
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
-#else
-void yy_switch_to_buffer( new_buffer )
-YY_BUFFER_STATE new_buffer;
-#endif
-	{
-	if ( yy_current_buffer == new_buffer )
-		return;
-
-	if ( yy_current_buffer )
-		{
-		/* Flush out information for old buffer. */
-		*yy_c_buf_p = yy_hold_char;
-		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
-		yy_current_buffer->yy_n_chars = yy_n_chars;
-		}
-
-	yy_current_buffer = new_buffer;
-	yy_load_buffer_state();
-
-	/* We don't actually know whether we did this switch during
-	 * EOF (yywrap()) processing, but the only time this flag
-	 * is looked at is after yywrap() is called, so it's safe
-	 * to go ahead and always set it.
-	 */
-	yy_did_buffer_switch_on_eof = 1;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_load_buffer_state( void )
-#else
-void yy_load_buffer_state()
-#endif
-	{
-	yy_n_chars = yy_current_buffer->yy_n_chars;
-	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
-	yyin = yy_current_buffer->yy_input_file;
-	yy_hold_char = *yy_c_buf_p;
-	}
-
-
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
-#else
-YY_BUFFER_STATE yy_create_buffer( file, size )
-FILE *file;
-int size;
-#endif
-	{
-	YY_BUFFER_STATE b;
-
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_buf_size = size;
-
-	/* yy_ch_buf has to be 2 characters longer than the size given because
-	 * we need to put in 2 end-of-buffer characters.
-	 */
-	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
-	if ( ! b->yy_ch_buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_is_our_buffer = 1;
-
-	yy_init_buffer( b, file );
-
-	return b;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_delete_buffer( YY_BUFFER_STATE b )
-#else
-void yy_delete_buffer( b )
-YY_BUFFER_STATE b;
-#endif
-	{
-	if ( ! b )
-		return;
-
-	if ( b == yy_current_buffer )
-		yy_current_buffer = (YY_BUFFER_STATE) 0;
-
-	if ( b->yy_is_our_buffer )
-		yy_flex_free( (void *) b->yy_ch_buf );
-
-	yy_flex_free( (void *) b );
-	}
-
-
-#ifndef _WIN32
-#include <unistd.h>
-#else
-#ifndef YY_ALWAYS_INTERACTIVE
-#ifndef YY_NEVER_INTERACTIVE
-extern int isatty YY_PROTO(( int ));
-#endif
-#endif
-#endif
-
-#ifdef YY_USE_PROTOS
-void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
-#else
-void yy_init_buffer( b, file )
-YY_BUFFER_STATE b;
-FILE *file;
-#endif
-
-
-	{
-	yy_flush_buffer( b );
-
-	b->yy_input_file = file;
-	b->yy_fill_buffer = 1;
-
-#if YY_ALWAYS_INTERACTIVE
-	b->yy_is_interactive = 1;
-#else
-#if YY_NEVER_INTERACTIVE
-	b->yy_is_interactive = 0;
-#else
-	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
-#endif
-#endif
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_flush_buffer( YY_BUFFER_STATE b )
-#else
-void yy_flush_buffer( b )
-YY_BUFFER_STATE b;
-#endif
-
-	{
-	if ( ! b )
-		return;
-
-	b->yy_n_chars = 0;
-
-	/* We always need two end-of-buffer characters.  The first causes
-	 * a transition to the end-of-buffer state.  The second causes
-	 * a jam in that state.
-	 */
-	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
-	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
-
-	b->yy_buf_pos = &b->yy_ch_buf[0];
-
-	b->yy_at_bol = 1;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	if ( b == yy_current_buffer )
-		yy_load_buffer_state();
-	}
-
-
-#ifndef YY_NO_SCAN_BUFFER
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
-#else
-YY_BUFFER_STATE yy_scan_buffer( base, size )
-char *base;
-yy_size_t size;
-#endif
-	{
-	YY_BUFFER_STATE b;
-
-	if ( size < 2 ||
-	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
-	     base[size-1] != YY_END_OF_BUFFER_CHAR )
-		/* They forgot to leave room for the EOB's. */
-		return 0;
-
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
-
-	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
-	b->yy_buf_pos = b->yy_ch_buf = base;
-	b->yy_is_our_buffer = 0;
-	b->yy_input_file = 0;
-	b->yy_n_chars = b->yy_buf_size;
-	b->yy_is_interactive = 0;
-	b->yy_at_bol = 1;
-	b->yy_fill_buffer = 0;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	yy_switch_to_buffer( b );
-
-	return b;
-	}
-#endif
-
-
-#ifndef YY_NO_SCAN_STRING
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
-#else
-YY_BUFFER_STATE yy_scan_string( yy_str )
-yyconst char *yy_str;
-#endif
-	{
-	int len;
-	for ( len = 0; yy_str[len]; ++len )
-		;
-
-	return yy_scan_bytes( yy_str, len );
-	}
-#endif
-
-
-#ifndef YY_NO_SCAN_BYTES
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
-#else
-YY_BUFFER_STATE yy_scan_bytes( bytes, len )
-yyconst char *bytes;
-int len;
-#endif
-	{
-	YY_BUFFER_STATE b;
-	char *buf;
-	yy_size_t n;
-	int i;
-
-	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = len + 2;
-	buf = (char *) yy_flex_alloc( n );
-	if ( ! buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
-
-	for ( i = 0; i < len; ++i )
-		buf[i] = bytes[i];
-
-	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
-
-	b = yy_scan_buffer( buf, n );
-	if ( ! b )
-		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
-
-	/* It's okay to grow etc. this buffer, and we should throw it
-	 * away when we're done.
-	 */
-	b->yy_is_our_buffer = 1;
-
-	return b;
-	}
-#endif
-
-
-#ifndef YY_NO_PUSH_STATE
-#ifdef YY_USE_PROTOS
-static void yy_push_state( int new_state )
-#else
-static void yy_push_state( new_state )
-int new_state;
-#endif
-	{
-	if ( yy_start_stack_ptr >= yy_start_stack_depth )
-		{
-		yy_size_t new_size;
-
-		yy_start_stack_depth += YY_START_STACK_INCR;
-		new_size = yy_start_stack_depth * sizeof( int );
-
-		if ( ! yy_start_stack )
-			yy_start_stack = (int *) yy_flex_alloc( new_size );
-
-		else
-			yy_start_stack = (int *) yy_flex_realloc(
-					(void *) yy_start_stack, new_size );
-
-		if ( ! yy_start_stack )
-			YY_FATAL_ERROR(
-			"out of memory expanding start-condition stack" );
-		}
-
-	yy_start_stack[yy_start_stack_ptr++] = YY_START;
-
-	BEGIN(new_state);
-	}
-#endif
-
-
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state()
-	{
-	if ( --yy_start_stack_ptr < 0 )
-		YY_FATAL_ERROR( "start-condition stack underflow" );
-
-	BEGIN(yy_start_stack[yy_start_stack_ptr]);
-	}
-#endif
-
-
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state()
-	{
-	return yy_start_stack[yy_start_stack_ptr - 1];
-	}
-#endif
-
-#ifndef YY_EXIT_FAILURE
-#define YY_EXIT_FAILURE 2
-#endif
-
-#ifdef YY_USE_PROTOS
-static void yy_fatal_error( yyconst char msg[] )
-#else
-static void yy_fatal_error( msg )
-char msg[];
-#endif
-	{
-	(void) fprintf( stderr, "%s\n", msg );
-	exit( YY_EXIT_FAILURE );
-	}
-
-
-
-/* Redefine yyless() so it works in section 3 code. */
-
-#undef yyless
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-		yytext[yyleng] = yy_hold_char; \
-		yy_c_buf_p = yytext + n; \
-		yy_hold_char = *yy_c_buf_p; \
-		*yy_c_buf_p = '\0'; \
-		yyleng = n; \
-		} \
-	while ( 0 )
-
-
-/* Internal utility routines. */
-
-#ifndef yytext_ptr
-#ifdef YY_USE_PROTOS
-static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
-#else
-static void yy_flex_strncpy( s1, s2, n )
-char *s1;
-yyconst char *s2;
-int n;
-#endif
-	{
-	register int i;
-	for ( i = 0; i < n; ++i )
-		s1[i] = s2[i];
-	}
-#endif
-
-#ifdef YY_NEED_STRLEN
-#ifdef YY_USE_PROTOS
-static int yy_flex_strlen( yyconst char *s )
-#else
-static int yy_flex_strlen( s )
-yyconst char *s;
-#endif
-	{
-	register int n;
-	for ( n = 0; s[n]; ++n )
-		;
-
-	return n;
-	}
-#endif
-
-
-#ifdef YY_USE_PROTOS
-static void *yy_flex_alloc( yy_size_t size )
-#else
-static void *yy_flex_alloc( size )
-yy_size_t size;
-#endif
-	{
-	return (void *) malloc( size );
-	}
-
-#ifdef YY_USE_PROTOS
-static void *yy_flex_realloc( void *ptr, yy_size_t size )
-#else
-static void *yy_flex_realloc( ptr, size )
-void *ptr;
-yy_size_t size;
-#endif
-	{
-	/* The cast to (char *) in the following accommodates both
-	 * implementations that use char* generic pointers, and those
-	 * that use void* generic pointers.  It works with the latter
-	 * because both ANSI C and C++ allow castless assignment from
-	 * any pointer type to void*, and deal with argument conversions
-	 * as though doing an assignment.
-	 */
-	return (void *) realloc( (char *) ptr, size );
-	}
-
-#ifdef YY_USE_PROTOS
-static void yy_flex_free( void *ptr )
-#else
-static void yy_flex_free( ptr )
-void *ptr;
-#endif
-	{
-	free( ptr );
-	}
-
-#if YY_MAIN
-int main()
-	{
-	yylex();
-	return 0;
-	}
-#endif
-#line 125 "analyze.l"
-
-#include <string.h>
-#include <lct/ksyms.h>
-#include <linux/keyboard.h>
-
-void
-stringovfl(void) {
-	lkfatal("string too long");
-}
-
-/* Include file handling - unfortunately flex-specific. */
-#define MAX_INCLUDE_DEPTH 20
-struct infile {
-	int linenr;
-	char *filename;
-	YY_BUFFER_STATE bs;
-} infile_stack[MAX_INCLUDE_DEPTH];
-int infile_stack_ptr = 0;
-
-void lk_push(void)
-{
-  if (infile_stack_ptr >= MAX_INCLUDE_DEPTH)
-    lkfatal("includes nested too deeply");
-
-  /* preserve current state */
-  infile_stack[infile_stack_ptr].filename = filename;
-  infile_stack[infile_stack_ptr].linenr = line_nr;
-  infile_stack[infile_stack_ptr++].bs =
-    YY_CURRENT_BUFFER;
-}
-
-int lk_pop(void)
-{
-  if (--infile_stack_ptr >= 0)
-    {
-      filename = infile_stack[infile_stack_ptr].filename;
-      line_nr = infile_stack[infile_stack_ptr].linenr;
-      yy_delete_buffer(YY_CURRENT_BUFFER);
-      yy_switch_to_buffer(infile_stack[infile_stack_ptr].bs);
-      return 0;
-    }
-  return 1;
-}
-
-/*
- * Where shall we look for an include file?
- * Current strategy (undocumented, may change):
- *
- * 1. Look for a user-specified LOADKEYS_INCLUDE_PATH
- * 2. Try . and ../include and ../../include
- * 3. Try D and D/../include and D/../../include
- *    where D is the directory from where we are loading the current file.
- * 4. Try KD/include and KD/#/include where KD = DATADIR/KEYMAPDIR.
- *
- * Expected layout:
- * KD has subdirectories amiga, atari, sun, i386, include
- * KD/include contains architecture-independent stuff
- * like strings and iso-8859-x compose tables.
- * KD/i386 has subdirectories qwerty, ... and include;
- * this latter include dir contains stuff with keycode=...
- *
- * (Of course, if the present setup turns out to be reasonable,
- * then later also the other architectures will grow and get
- * subdirectories, and the hard-coded i386 below will go again.)
- *
- * People that dislike a dozen lookups for loadkeys
- * can easily do "loadkeys file_with_includes; dumpkeys > my_keymap"
- * and afterwards use only "loadkeys /fullpath/mykeymap", where no
- * lookups are required.
- */
-const char *include_dirpath0[] = { "", 0 };
-const char *include_dirpath1[] = { "", "../include/", "../../include/", 0 };
-char *include_dirpath2[] = { 0, 0, 0, 0 };
-const char *include_dirpath3[] = { DATADIR "/" KEYMAPDIR "/include/",
-			     DATADIR "/" KEYMAPDIR "/i386/include/", 0 };
-const char *include_suffixes[] = { "", ".inc", 0 };
-
-FILE *find_standard_incl_file(char *s)
-{
-  FILE *f;
-  char *t, *te, *t1, *t2;
-  int len;
-
-  /* Try . and ../include and ../../include */
-  f = findfile_simple(s, include_dirpath1, include_suffixes);
-  if (f)
-    return f;
-
-  /* Try D and D/../include and D/../../include */
-  t = xstrdup(filename);
-  te = rindex(t, '/');
-  if (te)
-    {
-      te[1] = 0;
-      include_dirpath2[0] = t;
-      len = strlen(t);
-      include_dirpath2[1] = t1 = (char*)xmalloc(len + 12);
-      include_dirpath2[2] = t2 = (char*)xmalloc(len + 15);
-      strcpy(t1, t);
-      strcat(t1, "../include/");
-      strcpy(t2, t);
-      strcat(t2, "../../include/");
-      f = findfile_simple(s, (const char**)include_dirpath2, include_suffixes);
-      if (f)
-	return f;
-    }
-
-  /* Try KD/include and KD/#/include */
-  return findfile_simple(s, include_dirpath3, include_suffixes);
-}
-
-FILE *find_incl_file(char *s)
-{
-  FILE *f;
-  char *ev;
-  if (!s || !*s)
-    return NULL;
-  if (*s == '/')		/* no path required */
-    return (findfile_simple(s, include_dirpath0, include_suffixes));
-
-  if((ev = getenv("LOADKEYS_INCLUDE_PATH")) != NULL)
-    {
-      /* try user-specified path */
-      char *user_dir[2] = { 0, 0 };
-      while(ev)
-	{
-	  char *t = index((const char*)ev, ':');
-	  char sv = 0; /* initialise to silence compiler */
-	  if (t)
-	    {
-	      sv = *t;
-	      *t = 0;
-	    }
-	  user_dir[0] = ev;
-	  if (*ev)
-	    f = findfile_simple(s, (const char**)user_dir, include_suffixes);
-	  else	/* empty string denotes system path */
-	    f = find_standard_incl_file(s);
-	  if (f)
-	    return f;
-	  if (t)
-	    *t++ = sv;
-	  ev = t;
-	}
-      return NULL;
-    }
-  return find_standard_incl_file(s);
-}
-
-void open_include(char *s)
-{
-  if (verbose)
-    fprintf(stderr, "switching to %s\n", s);
-
-  lk_push();
-
-  yyin = find_incl_file(s);
-  if (!yyin)
-    lkfatal1("cannot open include file %s", s);
-  filename = xstrdup(pathname);
-  line_nr = 1;
-  yy_switch_to_buffer(yy_create_buffer(yyin, YY_BUF_SIZE));
-}
diff -ruN console-tools-0.2.3-old/kbdtools/analyze.l console-tools-0.2.3/kbdtools/analyze.l
--- console-tools-0.2.3-old/kbdtools/analyze.l	2003-08-12 22:57:39.000000000 +0100
+++ console-tools-0.2.3/kbdtools/analyze.l	2003-08-12 22:57:40.000000000 +0100
@@ -6,7 +6,7 @@
 #include <lct/utils.h>
 #include "loadkeys.h"
 
-extern int ksymtocode(char *s);
+extern int ksymtocode(char *s,int *unicode_used);
 
 extern int line_nr;
 extern int verbose;				  /* loadkeys.y */
@@ -16,6 +16,7 @@
 struct kbsentry kbs_buf;
 char *p, *pmax;
 char *filename;
+extern int unicode_used;
 
 #undef yywrap
 extern int yywrap(void);
@@ -88,7 +89,7 @@
 \+			{return(PLUS);}
 {Unicode}		{yylval=strtol(yytext+1,NULL,16);return(UNUMBER);}
 {Decimal}|{Octal}|{Hex}	{yylval=strtol(yytext,NULL,0);return(NUMBER);}
-<RVALUE>{Literal}	{return((yylval=ksymtocode(yytext))==-1?ERROR:LITERAL);}
+<RVALUE>{Literal}	{return((yylval=ksymtocode(yytext,&unicode_used))==-1?ERROR:LITERAL);}
 {Charset}		{return(CHARSET);}
 {Keymaps}		{return(KEYMAPS);}
 {Keycode}		{return(KEYCODE);}
diff -ruN console-tools-0.2.3-old/kbdtools/loadkeys.c console-tools-0.2.3/kbdtools/loadkeys.c
--- console-tools-0.2.3-old/kbdtools/loadkeys.c	2003-08-12 22:57:39.000000000 +0100
+++ console-tools-0.2.3/kbdtools/loadkeys.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,2440 +0,0 @@
-/* A Bison parser, made from loadkeys.y, by GNU bison 1.75.  */
-
-/* Skeleton parser for Yacc-like parsing with Bison,
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002 Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-/* Written by Richard Stallman by simplifying the original so called
-   ``semantic'' parser.  */
-
-/* All symbols defined below should begin with yy or YY, to avoid
-   infringing on user name space.  This should be done even for local
-   variables, as they might otherwise be expanded by user macros.
-   There are some unavoidable exceptions within include files to
-   define necessary library symbols; they are noted "INFRINGES ON
-   USER NAME SPACE" below.  */
-
-/* Identify Bison output.  */
-#define YYBISON	1
-
-/* Pure parsers.  */
-#define YYPURE	0
-
-/* Using locations.  */
-#define YYLSP_NEEDED 0
-
-
-
-/* Tokens.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-   /* Put the tokens into the symbol table, so that GDB and other debuggers
-      know about them.  */
-   enum yytokentype {
-     EOL = 258,
-     NUMBER = 259,
-     LITERAL = 260,
-     CHARSET = 261,
-     KEYMAPS = 262,
-     KEYCODE = 263,
-     EQUALS = 264,
-     PLAIN = 265,
-     SHIFT = 266,
-     CONTROL = 267,
-     ALT = 268,
-     ALTGR = 269,
-     SHIFTL = 270,
-     SHIFTR = 271,
-     CTRLL = 272,
-     CTRLR = 273,
-     COMMA = 274,
-     DASH = 275,
-     STRING = 276,
-     STRLITERAL = 277,
-     COMPOSE = 278,
-     TO = 279,
-     CCHAR = 280,
-     ERROR = 281,
-     PLUS = 282,
-     UNUMBER = 283,
-     ALT_IS_META = 284,
-     STRINGS = 285,
-     AS = 286,
-     USUAL = 287,
-     ON = 288,
-     FOR = 289
-   };
-#endif
-#define EOL 258
-#define NUMBER 259
-#define LITERAL 260
-#define CHARSET 261
-#define KEYMAPS 262
-#define KEYCODE 263
-#define EQUALS 264
-#define PLAIN 265
-#define SHIFT 266
-#define CONTROL 267
-#define ALT 268
-#define ALTGR 269
-#define SHIFTL 270
-#define SHIFTR 271
-#define CTRLL 272
-#define CTRLR 273
-#define COMMA 274
-#define DASH 275
-#define STRING 276
-#define STRLITERAL 277
-#define COMPOSE 278
-#define TO 279
-#define CCHAR 280
-#define ERROR 281
-#define PLUS 282
-#define UNUMBER 283
-#define ALT_IS_META 284
-#define STRINGS 285
-#define AS 286
-#define USUAL 287
-#define ON 288
-#define FOR 289
-
-
-
-
-/* Copy the first part of user declarations.  */
-#line 62 "loadkeys.y"
-
-#include <errno.h>
-#include <stdio.h>
-#include <getopt.h>
-#include <stdlib.h>
-#include <string.h>
-#include <fcntl.h>
-#include <linux/kd.h>
-#include <linux/keyboard.h>
-#include <sys/ioctl.h>
-#include <ctype.h>
-#include <sysexits.h>
-#include <signal.h>
-
-#include <lct/local.h>
-#include <lct/utils.h>
-#include <lct/console.h>
-#include <lct/font.h>		/* findkeymap() */
-#include <lct/ksyms.h>
-#include <lct/modifiers.h>
-
-int verbose;
-void lk_push(void);				  /* in analyze.c */
-int lk_pop(void);				  /* idem */
-extern int infile_stack_ptr;			  /* idem */
-
-#ifndef KT_LETTER
-#define KT_LETTER KT_LATIN
-#endif
-
-#undef yywrap
-int yywrap(void);
-
-/* externs from analyse.l */
-extern int line_nr, rvalct;
-extern struct kbsentry kbs_buf;
-extern FILE* yyin;
-
-/* name to use in error messages */
-char *progname;
-
-/* give error message if using unicode compose strings? */
-int unicode_warning = 0;
-/* What keymaps are we defining? */
-char defining[MAX_NR_KEYMAPS];
-char keymaps_line_seen = 0;
-int max_keymap = 0;		/* from here on, defining is false */
-int alt_is_meta = 0;
-
-/* the kernel structures we want to set or print */
-u_short *key_map[MAX_NR_KEYMAPS];
-char *func_table[MAX_NR_FUNC];
-struct kbdiacr accent_table[MAX_DIACR];
-unsigned int accent_table_size = 0;
-
-char key_is_constant[NR_KEYS];
-char *keymap_was_set[MAX_NR_KEYMAPS];
-char func_buf[4096];		/* should be allocated dynamically */
-char *fp = func_buf;
-
-#define U(x) ((x) ^ 0xf000)
-
-#undef ECHO
-
-static void addmap(int map, int explicit);
-static void addkey(int index, int table, int keycode);
-static void addfunc(struct kbsentry kbs_buf);
-static void killkey(int index, int table);
-static void compose(int diacr, int base, int res);
-static void do_constant(void);
-static void do_constant_key (int, u_short);
-static void loadkeys(void);
-static void mktable(void);
-static void strings_as_usual(void);
-static void compose_as_usual(char *charset);
-void lkfatal(char *);
-void lkfatal0(char *, int);
-void lkfatal1(char *, char *);
-extern char *xstrdup(char *);
-int key_buf[MAX_NR_KEYMAPS];
-int mod;
-int unicode_used;
-int private_error_ct = 0;
-
-
-/* Enabling traces.  */
-#ifndef YYDEBUG
-# define YYDEBUG 0
-#endif
-
-/* Enabling verbose error messages.  */
-#ifdef YYERROR_VERBOSE
-# undef YYERROR_VERBOSE
-# define YYERROR_VERBOSE 1
-#else
-# define YYERROR_VERBOSE 0
-#endif
-
-#ifndef YYSTYPE
-typedef int yystype;
-# define YYSTYPE yystype
-# define YYSTYPE_IS_TRIVIAL 1
-#endif
-
-#ifndef YYLTYPE
-typedef struct yyltype
-{
-  int first_line;
-  int first_column;
-  int last_line;
-  int last_column;
-} yyltype;
-# define YYLTYPE yyltype
-# define YYLTYPE_IS_TRIVIAL 1
-#endif
-
-/* Copy the second part of user declarations.  */
-
-
-/* Line 213 of /usr/share/bison/yacc.c.  */
-#line 246 "y.tab.c"
-
-#if ! defined (yyoverflow) || YYERROR_VERBOSE
-
-/* The parser invokes alloca or malloc; define the necessary symbols.  */
-
-# if YYSTACK_USE_ALLOCA
-#  define YYSTACK_ALLOC alloca
-# else
-#  ifndef YYSTACK_USE_ALLOCA
-#   if defined (alloca) || defined (_ALLOCA_H)
-#    define YYSTACK_ALLOC alloca
-#   else
-#    ifdef __GNUC__
-#     define YYSTACK_ALLOC __builtin_alloca
-#    endif
-#   endif
-#  endif
-# endif
-
-# ifdef YYSTACK_ALLOC
-   /* Pacify GCC's `empty if-body' warning. */
-#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
-# else
-#  if defined (__STDC__) || defined (__cplusplus)
-#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#   define YYSIZE_T size_t
-#  endif
-#  define YYSTACK_ALLOC malloc
-#  define YYSTACK_FREE free
-# endif
-#endif /* ! defined (yyoverflow) || YYERROR_VERBOSE */
-
-
-#if (! defined (yyoverflow) \
-     && (! defined (__cplusplus) \
-	 || (YYLTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
-
-/* A type that is properly aligned for any stack member.  */
-union yyalloc
-{
-  short yyss;
-  YYSTYPE yyvs;
-  };
-
-/* The size of the maximum gap between one aligned stack and the next.  */
-# define YYSTACK_GAP_MAX (sizeof (union yyalloc) - 1)
-
-/* The size of an array large to enough to hold all stacks, each with
-   N elements.  */
-# define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (short) + sizeof (YYSTYPE))				\
-      + YYSTACK_GAP_MAX)
-
-/* Copy COUNT objects from FROM to TO.  The source and destination do
-   not overlap.  */
-# ifndef YYCOPY
-#  if 1 < __GNUC__
-#   define YYCOPY(To, From, Count) \
-      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
-#  else
-#   define YYCOPY(To, From, Count)		\
-      do					\
-	{					\
-	  register YYSIZE_T yyi;		\
-	  for (yyi = 0; yyi < (Count); yyi++)	\
-	    (To)[yyi] = (From)[yyi];	\
-	}					\
-      while (0)
-#  endif
-# endif
-
-/* Relocate STACK from its old location to the new one.  The
-   local variables YYSIZE and YYSTACKSIZE give the old and new number of
-   elements in the stack, and YYPTR gives the new location of the
-   stack.  Advance YYPTR to a properly aligned location for the next
-   stack.  */
-# define YYSTACK_RELOCATE(Stack)					\
-    do									\
-      {									\
-	YYSIZE_T yynewbytes;						\
-	YYCOPY (&yyptr->Stack, Stack, yysize);				\
-	Stack = &yyptr->Stack;						\
-	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAX;	\
-	yyptr += yynewbytes / sizeof (*yyptr);				\
-      }									\
-    while (0)
-
-#endif
-
-#if defined (__STDC__) || defined (__cplusplus)
-   typedef signed char yysigned_char;
-#else
-   typedef short yysigned_char;
-#endif
-
-/* YYFINAL -- State number of the termination state. */
-#define YYFINAL  2
-#define YYLAST   79
-
-/* YYNTOKENS -- Number of terminals. */
-#define YYNTOKENS  35
-/* YYNNTS -- Number of nonterminals. */
-#define YYNNTS  20
-/* YYNRULES -- Number of rules. */
-#define YYNRULES  48
-/* YYNRULES -- Number of states. */
-#define YYNSTATES  88
-
-/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
-#define YYUNDEFTOK  2
-#define YYMAXUTOK   289
-
-#define YYTRANSLATE(X) \
-  ((unsigned)(X) <= YYMAXUTOK ? yytranslate[X] : YYUNDEFTOK)
-
-/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
-static const unsigned char yytranslate[] =
-{
-       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
-       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
-      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
-      25,    26,    27,    28,    29,    30,    31,    32,    33,    34
-};
-
-#if YYDEBUG
-/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
-   YYRHS.  */
-static const unsigned char yyprhs[] =
-{
-       0,     0,     3,     4,     7,     9,    11,    13,    15,    17,
-      19,    21,    23,    25,    27,    31,    34,    39,    46,    51,
-      55,    59,    61,    65,    67,    73,    80,    87,    88,    96,
-     103,   106,   108,   110,   112,   114,   116,   118,   120,   122,
-     124,   130,   131,   134,   136,   138,   140,   143,   145
-};
-
-/* YYRHS -- A `-1'-separated list of the rules' RHS. */
-static const yysigned_char yyrhs[] =
-{
-      36,     0,    -1,    -1,    36,    37,    -1,     3,    -1,    38,
-      -1,    39,    -1,    40,    -1,    41,    -1,    42,    -1,    51,
-      -1,    47,    -1,    45,    -1,    46,    -1,     6,    22,     3,
-      -1,    29,     3,    -1,    30,    31,    32,     3,    -1,    23,
-      31,    32,    34,    22,     3,    -1,    23,    31,    32,     3,
-      -1,     7,    43,     3,    -1,    43,    19,    44,    -1,    44,
-      -1,     4,    20,     4,    -1,     4,    -1,    21,     5,     9,
-      22,     3,    -1,    23,    25,    25,    24,    25,     3,    -1,
-      23,    25,    25,    24,    54,     3,    -1,    -1,    48,    49,
-       8,     4,     9,    54,     3,    -1,    10,     8,     4,     9,
-      54,     3,    -1,    49,    50,    -1,    50,    -1,    11,    -1,
-      12,    -1,    13,    -1,    14,    -1,    15,    -1,    16,    -1,
-      17,    -1,    18,    -1,     8,     4,     9,    52,     3,    -1,
-      -1,    53,    52,    -1,    54,    -1,     4,    -1,    28,    -1,
-      27,     4,    -1,     5,    -1,    27,     5,    -1
-};
-
-/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
-static const unsigned short yyrline[] =
-{
-       0,   148,   148,   149,   151,   152,   153,   154,   155,   156,
-     157,   158,   159,   160,   162,   167,   172,   177,   181,   186,
-     191,   192,   194,   200,   205,   214,   218,   223,   223,   228,
-     233,   234,   236,   237,   238,   239,   240,   241,   242,   243,
-     245,   278,   279,   281,   288,   290,   292,   294,   296
-};
-#endif
-
-#if YYDEBUG || YYERROR_VERBOSE
-/* YYTNME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
-   First, the terminals, then, starting at YYNTOKENS, nonterminals. */
-static const char *const yytname[] =
-{
-  "$end", "error", "$undefined", "EOL", "NUMBER", "LITERAL", "CHARSET", 
-  "KEYMAPS", "KEYCODE", "EQUALS", "PLAIN", "SHIFT", "CONTROL", "ALT", 
-  "ALTGR", "SHIFTL", "SHIFTR", "CTRLL", "CTRLR", "COMMA", "DASH", 
-  "STRING", "STRLITERAL", "COMPOSE", "TO", "CCHAR", "ERROR", "PLUS", 
-  "UNUMBER", "ALT_IS_META", "STRINGS", "AS", "USUAL", "ON", "FOR", 
-  "$accept", "keytable", "line", "charsetline", "altismetaline", 
-  "usualstringsline", "usualcomposeline", "keymapline", "range", "range0", 
-  "strline", "compline", "singleline", "@1", "modifiers", "modifier", 
-  "fullline", "rvalue0", "rvalue1", "rvalue", 0
-};
-#endif
-
-# ifdef YYPRINT
-/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
-   token YYLEX-NUM.  */
-static const unsigned short yytoknum[] =
-{
-       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
-     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
-     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
-     285,   286,   287,   288,   289
-};
-# endif
-
-/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
-static const unsigned char yyr1[] =
-{
-       0,    35,    36,    36,    37,    37,    37,    37,    37,    37,
-      37,    37,    37,    37,    38,    39,    40,    41,    41,    42,
-      43,    43,    44,    44,    45,    46,    46,    48,    47,    47,
-      49,    49,    50,    50,    50,    50,    50,    50,    50,    50,
-      51,    52,    52,    53,    54,    54,    54,    54,    54
-};
-
-/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
-static const unsigned char yyr2[] =
-{
-       0,     2,     0,     2,     1,     1,     1,     1,     1,     1,
-       1,     1,     1,     1,     3,     2,     4,     6,     4,     3,
-       3,     1,     3,     1,     5,     6,     6,     0,     7,     6,
-       2,     1,     1,     1,     1,     1,     1,     1,     1,     1,
-       5,     0,     2,     1,     1,     1,     2,     1,     2
-};
-
-/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
-   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
-   means the default is an error.  */
-static const unsigned char yydefact[] =
-{
-       2,    27,     1,     4,     0,     0,     0,     0,     0,     0,
-       0,     0,     3,     5,     6,     7,     8,     9,    12,    13,
-      11,     0,    10,     0,    23,     0,    21,     0,     0,     0,
-       0,     0,    15,     0,    32,    33,    34,    35,    36,    37,
-      38,    39,     0,    31,    14,     0,    19,     0,    41,     0,
-       0,     0,     0,     0,     0,    30,    22,    20,    44,    47,
-       0,    45,     0,    41,    43,     0,     0,     0,    18,     0,
-      16,     0,    46,    48,    40,    42,     0,    24,     0,     0,
-       0,     0,    29,    25,    26,    17,     0,    28
-};
-
-/* YYDEFGOTO[NTERM-NUM]. */
-static const yysigned_char yydefgoto[] =
-{
-      -1,     1,    12,    13,    14,    15,    16,    17,    25,    26,
-      18,    19,    20,    21,    42,    43,    22,    62,    63,    64
-};
-
-/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
-   STATE-NUM.  */
-#define YYPACT_NINF -48
-static const yysigned_char yypact[] =
-{
-     -48,     3,   -48,   -48,   -15,     8,    12,    11,    18,   -23,
-      26,    -1,   -48,   -48,   -48,   -48,   -48,   -48,   -48,   -48,
-     -48,    36,   -48,    32,    35,    -2,   -48,    47,    53,    49,
-      34,    29,   -48,    30,   -48,   -48,   -48,   -48,   -48,   -48,
-     -48,   -48,    28,   -48,   -48,    56,   -48,     8,    10,    54,
-      42,    41,    -3,    63,    64,   -48,   -48,   -48,   -48,   -48,
-      17,   -48,    66,    10,   -48,    10,    67,     0,   -48,    45,
-     -48,    62,   -48,   -48,   -48,   -48,    69,   -48,    70,    71,
-      72,    10,   -48,   -48,   -48,   -48,    73,   -48
-};
-
-/* YYPGOTO[NTERM-NUM].  */
-static const yysigned_char yypgoto[] =
-{
-     -48,   -48,   -48,   -48,   -48,   -48,   -48,   -48,   -48,    31,
-     -48,   -48,   -48,   -48,   -48,    37,   -48,    14,   -48,   -47
-};
-
-/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
-   positive, shift that token.  If negative, reduce the rule which
-   number is the opposite.  If zero, do what YYDEFACT says.
-   If YYTABLE_NINF, parse error.  */
-#define YYTABLE_NINF -1
-static const unsigned char yytable[] =
-{
-      68,    46,    30,     2,    58,    59,     3,    23,    31,     4,
-       5,     6,    24,     7,    58,    59,    27,    47,    76,    28,
-      79,    72,    73,    29,     8,    78,     9,    60,    61,    32,
-      33,    69,    10,    11,    86,    44,    54,    60,    61,    34,
-      35,    36,    37,    38,    39,    40,    41,    34,    35,    36,
-      37,    38,    39,    40,    41,    45,    48,    49,    50,    51,
-      56,    52,    53,    65,    66,    67,    70,    80,    71,    74,
-      77,    81,    82,    83,    84,    85,    87,    75,    57,    55
-};
-
-static const unsigned char yycheck[] =
-{
-       3,     3,    25,     0,     4,     5,     3,    22,    31,     6,
-       7,     8,     4,    10,     4,     5,     4,    19,    65,     8,
-      67,     4,     5,     5,    21,    25,    23,    27,    28,     3,
-      31,    34,    29,    30,    81,     3,     8,    27,    28,    11,
-      12,    13,    14,    15,    16,    17,    18,    11,    12,    13,
-      14,    15,    16,    17,    18,    20,     9,     4,     9,    25,
-       4,    32,    32,     9,    22,    24,     3,    22,     4,     3,
-       3,     9,     3,     3,     3,     3,     3,    63,    47,    42
-};
-
-/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
-   symbol of state STATE-NUM.  */
-static const unsigned char yystos[] =
-{
-       0,    36,     0,     3,     6,     7,     8,    10,    21,    23,
-      29,    30,    37,    38,    39,    40,    41,    42,    45,    46,
-      47,    48,    51,    22,     4,    43,    44,     4,     8,     5,
-      25,    31,     3,    31,    11,    12,    13,    14,    15,    16,
-      17,    18,    49,    50,     3,    20,     3,    19,     9,     4,
-       9,    25,    32,    32,     8,    50,     4,    44,     4,     5,
-      27,    28,    52,    53,    54,     9,    22,    24,     3,    34,
-       3,     4,     4,     5,     3,    52,    54,     3,    25,    54,
-      22,     9,     3,     3,     3,     3,    54,     3
-};
-
-#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
-# define YYSIZE_T __SIZE_TYPE__
-#endif
-#if ! defined (YYSIZE_T) && defined (size_t)
-# define YYSIZE_T size_t
-#endif
-#if ! defined (YYSIZE_T)
-# if defined (__STDC__) || defined (__cplusplus)
-#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYSIZE_T size_t
-# endif
-#endif
-#if ! defined (YYSIZE_T)
-# define YYSIZE_T unsigned int
-#endif
-
-#define yyerrok		(yyerrstatus = 0)
-#define yyclearin	(yychar = YYEMPTY)
-#define YYEMPTY		-2
-#define YYEOF		0
-
-#define YYACCEPT	goto yyacceptlab
-#define YYABORT		goto yyabortlab
-#define YYERROR		goto yyerrlab1
-
-/* Like YYERROR except do call yyerror.  This remains here temporarily
-   to ease the transition to the new meaning of YYERROR, for GCC.
-   Once GCC version 2 has supplanted version 1, this can go.  */
-
-#define YYFAIL		goto yyerrlab
-
-#define YYRECOVERING()  (!!yyerrstatus)
-
-#define YYBACKUP(Token, Value)					\
-do								\
-  if (yychar == YYEMPTY && yylen == 1)				\
-    {								\
-      yychar = (Token);						\
-      yylval = (Value);						\
-      yychar1 = YYTRANSLATE (yychar);				\
-      YYPOPSTACK;						\
-      goto yybackup;						\
-    }								\
-  else								\
-    { 								\
-      yyerror ("syntax error: cannot back up");			\
-      YYERROR;							\
-    }								\
-while (0)
-
-#define YYTERROR	1
-#define YYERRCODE	256
-
-/* YYLLOC_DEFAULT -- Compute the default location (before the actions
-   are run).  */
-
-#ifndef YYLLOC_DEFAULT
-# define YYLLOC_DEFAULT(Current, Rhs, N)           \
-  Current.first_line   = Rhs[1].first_line;      \
-  Current.first_column = Rhs[1].first_column;    \
-  Current.last_line    = Rhs[N].last_line;       \
-  Current.last_column  = Rhs[N].last_column;
-#endif
-
-/* YYLEX -- calling `yylex' with the right arguments.  */
-
-#define YYLEX	yylex ()
-
-/* Enable debugging if requested.  */
-#if YYDEBUG
-
-# ifndef YYFPRINTF
-#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYFPRINTF fprintf
-# endif
-
-# define YYDPRINTF(Args)			\
-do {						\
-  if (yydebug)					\
-    YYFPRINTF Args;				\
-} while (0)
-# define YYDSYMPRINT(Args)			\
-do {						\
-  if (yydebug)					\
-    yysymprint Args;				\
-} while (0)
-/* Nonzero means print parse trace.  It is left uninitialized so that
-   multiple parsers can coexist.  */
-int yydebug;
-#else /* !YYDEBUG */
-# define YYDPRINTF(Args)
-# define YYDSYMPRINT(Args)
-#endif /* !YYDEBUG */
-
-/* YYINITDEPTH -- initial size of the parser's stacks.  */
-#ifndef	YYINITDEPTH
-# define YYINITDEPTH 200
-#endif
-
-/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
-   if the built-in stack extension method is used).
-
-   Do not make this value too large; the results are undefined if
-   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)
-   evaluated with infinite-precision integer arithmetic.  */
-
-#if YYMAXDEPTH == 0
-# undef YYMAXDEPTH
-#endif
-
-#ifndef YYMAXDEPTH
-# define YYMAXDEPTH 10000
-#endif
-
-
-
-#if YYERROR_VERBOSE
-
-# ifndef yystrlen
-#  if defined (__GLIBC__) && defined (_STRING_H)
-#   define yystrlen strlen
-#  else
-/* Return the length of YYSTR.  */
-static YYSIZE_T
-#   if defined (__STDC__) || defined (__cplusplus)
-yystrlen (const char *yystr)
-#   else
-yystrlen (yystr)
-     const char *yystr;
-#   endif
-{
-  register const char *yys = yystr;
-
-  while (*yys++ != '\0')
-    continue;
-
-  return yys - yystr - 1;
-}
-#  endif
-# endif
-
-# ifndef yystpcpy
-#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
-#   define yystpcpy stpcpy
-#  else
-/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
-   YYDEST.  */
-static char *
-#   if defined (__STDC__) || defined (__cplusplus)
-yystpcpy (char *yydest, const char *yysrc)
-#   else
-yystpcpy (yydest, yysrc)
-     char *yydest;
-     const char *yysrc;
-#   endif
-{
-  register char *yyd = yydest;
-  register const char *yys = yysrc;
-
-  while ((*yyd++ = *yys++) != '\0')
-    continue;
-
-  return yyd - 1;
-}
-#  endif
-# endif
-
-#endif /* !YYERROR_VERBOSE */
-
-
-
-#if YYDEBUG
-/*-----------------------------.
-| Print this symbol on YYOUT.  |
-`-----------------------------*/
-
-static void
-#if defined (__STDC__) || defined (__cplusplus)
-yysymprint (FILE* yyout, int yytype, YYSTYPE yyvalue)
-#else
-yysymprint (yyout, yytype, yyvalue)
-    FILE* yyout;
-    int yytype;
-    YYSTYPE yyvalue;
-#endif
-{
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvalue;
-
-  if (yytype < YYNTOKENS)
-    {
-      YYFPRINTF (yyout, "token %s (", yytname[yytype]);
-# ifdef YYPRINT
-      YYPRINT (yyout, yytoknum[yytype], yyvalue);
-# endif
-    }
-  else
-    YYFPRINTF (yyout, "nterm %s (", yytname[yytype]);
-
-  switch (yytype)
-    {
-      default:
-        break;
-    }
-  YYFPRINTF (yyout, ")");
-}
-#endif /* YYDEBUG. */
-
-
-/*-----------------------------------------------.
-| Release the memory associated to this symbol.  |
-`-----------------------------------------------*/
-
-static void
-#if defined (__STDC__) || defined (__cplusplus)
-yydestruct (int yytype, YYSTYPE yyvalue)
-#else
-yydestruct (yytype, yyvalue)
-    int yytype;
-    YYSTYPE yyvalue;
-#endif
-{
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvalue;
-
-  switch (yytype)
-    {
-      default:
-        break;
-    }
-}
-
-
-
-/* The user can define YYPARSE_PARAM as the name of an argument to be passed
-   into yyparse.  The argument should have type void *.
-   It should actually point to an object.
-   Grammar actions can access the variable by casting it
-   to the proper pointer type.  */
-
-#ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
-#  define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
-#  define YYPARSE_PARAM_DECL
-# else
-#  define YYPARSE_PARAM_ARG YYPARSE_PARAM
-#  define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
-# endif
-#else /* !YYPARSE_PARAM */
-# define YYPARSE_PARAM_ARG
-# define YYPARSE_PARAM_DECL
-#endif /* !YYPARSE_PARAM */
-
-/* Prevent warning if -Wstrict-prototypes.  */
-#ifdef __GNUC__
-# ifdef YYPARSE_PARAM
-int yyparse (void *);
-# else
-int yyparse (void);
-# endif
-#endif
-
-
-/* The lookahead symbol.  */
-int yychar;
-
-/* The semantic value of the lookahead symbol.  */
-YYSTYPE yylval;
-
-/* Number of parse errors so far.  */
-int yynerrs;
-
-
-int
-yyparse (YYPARSE_PARAM_ARG)
-     YYPARSE_PARAM_DECL
-{
-  
-  register int yystate;
-  register int yyn;
-  int yyresult;
-  /* Number of tokens to shift before error messages enabled.  */
-  int yyerrstatus;
-  /* Lookahead token as an internal (translated) token number.  */
-  int yychar1 = 0;
-
-  /* Three stacks and their tools:
-     `yyss': related to states,
-     `yyvs': related to semantic values,
-     `yyls': related to locations.
-
-     Refer to the stacks thru separate pointers, to allow yyoverflow
-     to reallocate them elsewhere.  */
-
-  /* The state stack.  */
-  short	yyssa[YYINITDEPTH];
-  short *yyss = yyssa;
-  register short *yyssp;
-
-  /* The semantic value stack.  */
-  YYSTYPE yyvsa[YYINITDEPTH];
-  YYSTYPE *yyvs = yyvsa;
-  register YYSTYPE *yyvsp;
-
-
-
-#define YYPOPSTACK   (yyvsp--, yyssp--)
-
-  YYSIZE_T yystacksize = YYINITDEPTH;
-
-  /* The variables used to return semantic value and location from the
-     action routines.  */
-  YYSTYPE yyval;
-
-
-  /* When reducing, the number of symbols on the RHS of the reduced
-     rule.  */
-  int yylen;
-
-  YYDPRINTF ((stderr, "Starting parse\n"));
-
-  yystate = 0;
-  yyerrstatus = 0;
-  yynerrs = 0;
-  yychar = YYEMPTY;		/* Cause a token to be read.  */
-
-  /* Initialize stack pointers.
-     Waste one element of value and location stack
-     so that they stay on the same level as the state stack.
-     The wasted elements are never initialized.  */
-
-  yyssp = yyss;
-  yyvsp = yyvs;
-
-  goto yysetstate;
-
-/*------------------------------------------------------------.
-| yynewstate -- Push a new state, which is found in yystate.  |
-`------------------------------------------------------------*/
- yynewstate:
-  /* In all cases, when you get here, the value and location stacks
-     have just been pushed. so pushing a state here evens the stacks.
-     */
-  yyssp++;
-
- yysetstate:
-  *yyssp = yystate;
-
-  if (yyssp >= yyss + yystacksize - 1)
-    {
-      /* Get the current used size of the three stacks, in elements.  */
-      YYSIZE_T yysize = yyssp - yyss + 1;
-
-#ifdef yyoverflow
-      {
-	/* Give user a chance to reallocate the stack. Use copies of
-	   these so that the &'s don't force the real ones into
-	   memory.  */
-	YYSTYPE *yyvs1 = yyvs;
-	short *yyss1 = yyss;
-
-
-	/* Each stack pointer address is followed by the size of the
-	   data in use in that stack, in bytes.  This used to be a
-	   conditional around just the two extra args, but that might
-	   be undefined if yyoverflow is a macro.  */
-	yyoverflow ("parser stack overflow",
-		    &yyss1, yysize * sizeof (*yyssp),
-		    &yyvs1, yysize * sizeof (*yyvsp),
-
-		    &yystacksize);
-
-	yyss = yyss1;
-	yyvs = yyvs1;
-      }
-#else /* no yyoverflow */
-# ifndef YYSTACK_RELOCATE
-      goto yyoverflowlab;
-# else
-      /* Extend the stack our own way.  */
-      if (yystacksize >= YYMAXDEPTH)
-	goto yyoverflowlab;
-      yystacksize *= 2;
-      if (yystacksize > YYMAXDEPTH)
-	yystacksize = YYMAXDEPTH;
-
-      {
-	short *yyss1 = yyss;
-	union yyalloc *yyptr =
-	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
-	if (! yyptr)
-	  goto yyoverflowlab;
-	YYSTACK_RELOCATE (yyss);
-	YYSTACK_RELOCATE (yyvs);
-
-#  undef YYSTACK_RELOCATE
-	if (yyss1 != yyssa)
-	  YYSTACK_FREE (yyss1);
-      }
-# endif
-#endif /* no yyoverflow */
-
-      yyssp = yyss + yysize - 1;
-      yyvsp = yyvs + yysize - 1;
-
-
-      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
-		  (unsigned long int) yystacksize));
-
-      if (yyssp >= yyss + yystacksize - 1)
-	YYABORT;
-    }
-
-  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
-
-  goto yybackup;
-
-/*-----------.
-| yybackup.  |
-`-----------*/
-yybackup:
-
-/* Do appropriate processing given the current state.  */
-/* Read a lookahead token if we need one and don't already have one.  */
-/* yyresume: */
-
-  /* First try to decide what to do without reference to lookahead token.  */
-
-  yyn = yypact[yystate];
-  if (yyn == YYPACT_NINF)
-    goto yydefault;
-
-  /* Not known => get a lookahead token if don't already have one.  */
-
-  /* yychar is either YYEMPTY or YYEOF
-     or a valid token in external form.  */
-
-  if (yychar == YYEMPTY)
-    {
-      YYDPRINTF ((stderr, "Reading a token: "));
-      yychar = YYLEX;
-    }
-
-  /* Convert token to internal form (in yychar1) for indexing tables with.  */
-
-  if (yychar <= 0)		/* This means end of input.  */
-    {
-      yychar1 = 0;
-      yychar = YYEOF;		/* Don't call YYLEX any more.  */
-
-      YYDPRINTF ((stderr, "Now at end of input.\n"));
-    }
-  else
-    {
-      yychar1 = YYTRANSLATE (yychar);
-
-      /* We have to keep this `#if YYDEBUG', since we use variables
-	 which are defined only if `YYDEBUG' is set.  */
-      YYDPRINTF ((stderr, "Next token is "));
-      YYDSYMPRINT ((stderr, yychar1, yylval));
-      YYDPRINTF ((stderr, "\n"));
-    }
-
-  /* If the proper action on seeing token YYCHAR1 is to reduce or to
-     detect an error, take that action.  */
-  yyn += yychar1;
-  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yychar1)
-    goto yydefault;
-  yyn = yytable[yyn];
-  if (yyn <= 0)
-    {
-      if (yyn == 0 || yyn == YYTABLE_NINF)
-	goto yyerrlab;
-      yyn = -yyn;
-      goto yyreduce;
-    }
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  /* Shift the lookahead token.  */
-  YYDPRINTF ((stderr, "Shifting token %d (%s), ",
-	      yychar, yytname[yychar1]));
-
-  /* Discard the token being shifted unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
-
-  *++yyvsp = yylval;
-
-
-  /* Count tokens shifted since error; after three, turn off error
-     status.  */
-  if (yyerrstatus)
-    yyerrstatus--;
-
-  yystate = yyn;
-  goto yynewstate;
-
-
-/*-----------------------------------------------------------.
-| yydefault -- do the default action for the current state.  |
-`-----------------------------------------------------------*/
-yydefault:
-  yyn = yydefact[yystate];
-  if (yyn == 0)
-    goto yyerrlab;
-  goto yyreduce;
-
-
-/*-----------------------------.
-| yyreduce -- Do a reduction.  |
-`-----------------------------*/
-yyreduce:
-  /* yyn is the number of a rule to reduce with.  */
-  yylen = yyr2[yyn];
-
-  /* If YYLEN is nonzero, implement the default value of the action:
-     `$$ = $1'.
-
-     Otherwise, the following line sets YYVAL to garbage.
-     This behavior is undocumented and Bison
-     users should not rely upon it.  Assigning to YYVAL
-     unconditionally makes the parser a bit smaller, and it avoids a
-     GCC warning that YYVAL may be used uninitialized.  */
-  yyval = yyvsp[1-yylen];
-
-
-
-#if YYDEBUG
-  /* We have to keep this `#if YYDEBUG', since we use variables which
-     are defined only if `YYDEBUG' is set.  */
-  if (yydebug)
-    {
-      int yyi;
-
-      YYFPRINTF (stderr, "Reducing via rule %d (line %d), ",
-		 yyn - 1, yyrline[yyn]);
-
-      /* Print the symbols being reduced, and their result.  */
-      for (yyi = yyprhs[yyn]; yyrhs[yyi] >= 0; yyi++)
-	YYFPRINTF (stderr, "%s ", yytname[yyrhs[yyi]]);
-      YYFPRINTF (stderr, " -> %s\n", yytname[yyr1[yyn]]);
-    }
-#endif
-  switch (yyn)
-    {
-        case 14:
-#line 163 "loadkeys.y"
-    {
-			    set_charset(kbs_buf.kb_string);
-			}
-    break;
-
-  case 15:
-#line 168 "loadkeys.y"
-    {
-			    alt_is_meta = 1;
-			}
-    break;
-
-  case 16:
-#line 173 "loadkeys.y"
-    {
-			    strings_as_usual();
-			}
-    break;
-
-  case 17:
-#line 178 "loadkeys.y"
-    {
-			    compose_as_usual(kbs_buf.kb_string);
-			}
-    break;
-
-  case 18:
-#line 182 "loadkeys.y"
-    {
-			    compose_as_usual(0);
-			}
-    break;
-
-  case 19:
-#line 187 "loadkeys.y"
-    {
-			    keymaps_line_seen = 1;
-			}
-    break;
-
-  case 22:
-#line 195 "loadkeys.y"
-    {
-			    int i;
-			    for (i = yyvsp[-2]; i<= yyvsp[0]; i++)
-			      addmap(i,1);
-			}
-    break;
-
-  case 23:
-#line 201 "loadkeys.y"
-    {
-			    addmap(yyvsp[0],1);
-			}
-    break;
-
-  case 24:
-#line 206 "loadkeys.y"
-    {
-			    if (KTYP(yyvsp[-3]) != KT_FN)
-				lkfatal1("'%s' is not a function key symbol",
-					syms[KTYP(yyvsp[-3])].table[KVAL(yyvsp[-3])]);
-			    kbs_buf.kb_func = KVAL(yyvsp[-3]);
-			    addfunc(kbs_buf);
-			}
-    break;
-
-  case 25:
-#line 215 "loadkeys.y"
-    {
-			    compose(yyvsp[-4], yyvsp[-3], yyvsp[-1]);
-			}
-    break;
-
-  case 26:
-#line 219 "loadkeys.y"
-    {
-			    compose(yyvsp[-4], yyvsp[-3], yyvsp[-1]);
-			}
-    break;
-
-  case 27:
-#line 223 "loadkeys.y"
-    { mod = 0; }
-    break;
-
-  case 28:
-#line 225 "loadkeys.y"
-    {
-			    addkey(yyvsp[-3], mod, yyvsp[-1]);
-			}
-    break;
-
-  case 29:
-#line 229 "loadkeys.y"
-    {
-			    addkey(yyvsp[-2], 0, yyvsp[0]);
-			}
-    break;
-
-  case 32:
-#line 236 "loadkeys.y"
-    { mod |= M_SHIFT;	}
-    break;
-
-  case 33:
-#line 237 "loadkeys.y"
-    { mod |= M_CTRL;	}
-    break;
-
-  case 34:
-#line 238 "loadkeys.y"
-    { mod |= M_ALT;		}
-    break;
-
-  case 35:
-#line 239 "loadkeys.y"
-    { mod |= M_ALTGR;	}
-    break;
-
-  case 36:
-#line 240 "loadkeys.y"
-    { mod |= M_SHIFTL;	}
-    break;
-
-  case 37:
-#line 241 "loadkeys.y"
-    { mod |= M_SHIFTR;	}
-    break;
-
-  case 38:
-#line 242 "loadkeys.y"
-    { mod |= M_CTRLL;	}
-    break;
-
-  case 39:
-#line 243 "loadkeys.y"
-    { mod |= M_CTRLR;	}
-    break;
-
-  case 40:
-#line 246 "loadkeys.y"
-    {
-	    int i, j;
-
-	    if (rvalct == 1) {
-	        /* Some files do not have a keymaps line, and
-		   we have to wait until all input has been read
-		   before we know which maps to fill. */
-	        key_is_constant[yyvsp[-3]] = 1;
-	    
-		/* On the other hand, we now have include files,
-		   and it should be possible to override lines
-		   from an include file. So, kill old defs. */
-		for (j = 0; j < max_keymap; j++)
-		    if (defining[j])
-		        killkey(yyvsp[-3], j);
-	    }
-	    if (keymaps_line_seen) {
-		i = 0;
-		for (j = 0; j < max_keymap; j++)
-		  if (defining[j]) {
-		      if (rvalct != 1 || i == 0)
-			addkey(yyvsp[-3], j, (i < rvalct) ? key_buf[i] : K_HOLE);
-		      i++;
-		  }
-		if (i < rvalct)
-		    lkfatal0("too many (%d) entries on one line", rvalct);
-	    } else
-	      for (i = 0; i < rvalct; i++)
-		addkey(yyvsp[-3], i, key_buf[i]);
-	}
-    break;
-
-  case 43:
-#line 282 "loadkeys.y"
-    {
-			    if (rvalct >= MAX_NR_KEYMAPS)
-				lkfatal(_("too many keydefinitions on one line"));
-			    key_buf[rvalct++] = yyvsp[0];
-			}
-    break;
-
-  case 44:
-#line 289 "loadkeys.y"
-    {yyval=yyvsp[0];}
-    break;
-
-  case 45:
-#line 291 "loadkeys.y"
-    {yyval=(yyvsp[0] ^ 0xf000); unicode_used=1;}
-    break;
-
-  case 46:
-#line 293 "loadkeys.y"
-    {yyval=K(KT_LETTER, KVAL(yyvsp[0]));}
-    break;
-
-  case 47:
-#line 295 "loadkeys.y"
-    {yyval=yyvsp[0];}
-    break;
-
-  case 48:
-#line 297 "loadkeys.y"
-    {yyval=K(KT_LETTER, KVAL(yyvsp[0]));}
-    break;
-
-
-    }
-
-/* Line 1016 of /usr/share/bison/yacc.c.  */
-#line 1339 "y.tab.c"
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-
-
-#if YYDEBUG
-  if (yydebug)
-    {
-      short *yyssp1 = yyss - 1;
-      YYFPRINTF (stderr, "state stack now");
-      while (yyssp1 != yyssp)
-	YYFPRINTF (stderr, " %d", *++yyssp1);
-      YYFPRINTF (stderr, "\n");
-    }
-#endif
-
-  *++yyvsp = yyval;
-
-
-  /* Now `shift' the result of the reduction.  Determine what state
-     that goes to, based on the state we popped back to and the rule
-     number reduced by.  */
-
-  yyn = yyr1[yyn];
-
-  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
-  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
-    yystate = yytable[yystate];
-  else
-    yystate = yydefgoto[yyn - YYNTOKENS];
-
-  goto yynewstate;
-
-
-/*------------------------------------.
-| yyerrlab -- here on detecting error |
-`------------------------------------*/
-yyerrlab:
-  /* If not already recovering from an error, report this error.  */
-  if (!yyerrstatus)
-    {
-      ++yynerrs;
-#if YYERROR_VERBOSE
-      yyn = yypact[yystate];
-
-      if (YYPACT_NINF < yyn && yyn < YYLAST)
-	{
-	  YYSIZE_T yysize = 0;
-	  int yytype = YYTRANSLATE (yychar);
-	  char *yymsg;
-	  int yyx, yycount;
-
-	  yycount = 0;
-	  /* Start YYX at -YYN if negative to avoid negative indexes in
-	     YYCHECK.  */
-	  for (yyx = yyn < 0 ? -yyn : 0;
-	       yyx < (int) (sizeof (yytname) / sizeof (char *)); yyx++)
-	    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
-	      yysize += yystrlen (yytname[yyx]) + 15, yycount++;
-	  yysize += yystrlen ("parse error, unexpected ") + 1;
-	  yysize += yystrlen (yytname[yytype]);
-	  yymsg = (char *) YYSTACK_ALLOC (yysize);
-	  if (yymsg != 0)
-	    {
-	      char *yyp = yystpcpy (yymsg, "parse error, unexpected ");
-	      yyp = yystpcpy (yyp, yytname[yytype]);
-
-	      if (yycount < 5)
-		{
-		  yycount = 0;
-		  for (yyx = yyn < 0 ? -yyn : 0;
-		       yyx < (int) (sizeof (yytname) / sizeof (char *));
-		       yyx++)
-		    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
-		      {
-			const char *yyq = ! yycount ? ", expecting " : " or ";
-			yyp = yystpcpy (yyp, yyq);
-			yyp = yystpcpy (yyp, yytname[yyx]);
-			yycount++;
-		      }
-		}
-	      yyerror (yymsg);
-	      YYSTACK_FREE (yymsg);
-	    }
-	  else
-	    yyerror ("parse error; also virtual memory exhausted");
-	}
-      else
-#endif /* YYERROR_VERBOSE */
-	yyerror ("parse error");
-    }
-  goto yyerrlab1;
-
-
-/*----------------------------------------------------.
-| yyerrlab1 -- error raised explicitly by an action.  |
-`----------------------------------------------------*/
-yyerrlab1:
-  if (yyerrstatus == 3)
-    {
-      /* If just tried and failed to reuse lookahead token after an
-	 error, discard it.  */
-
-      /* Return failure if at end of input.  */
-      if (yychar == YYEOF)
-        {
-	  /* Pop the error token.  */
-          YYPOPSTACK;
-	  /* Pop the rest of the stack.  */
-	  while (yyssp > yyss)
-	    {
-	      YYDPRINTF ((stderr, "Error: popping "));
-	      YYDSYMPRINT ((stderr,
-			    yystos[*yyssp],
-			    *yyvsp));
-	      YYDPRINTF ((stderr, "\n"));
-	      yydestruct (yystos[*yyssp], *yyvsp);
-	      YYPOPSTACK;
-	    }
-	  YYABORT;
-        }
-
-      YYDPRINTF ((stderr, "Discarding token %d (%s).\n",
-		  yychar, yytname[yychar1]));
-      yydestruct (yychar1, yylval);
-      yychar = YYEMPTY;
-    }
-
-  /* Else will try to reuse lookahead token after shifting the error
-     token.  */
-
-  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
-
-  for (;;)
-    {
-      yyn = yypact[yystate];
-      if (yyn != YYPACT_NINF)
-	{
-	  yyn += YYTERROR;
-	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
-	    {
-	      yyn = yytable[yyn];
-	      if (0 < yyn)
-		break;
-	    }
-	}
-
-      /* Pop the current state because it cannot handle the error token.  */
-      if (yyssp == yyss)
-	YYABORT;
-
-      YYDPRINTF ((stderr, "Error: popping "));
-      YYDSYMPRINT ((stderr,
-		    yystos[*yyssp], *yyvsp));
-      YYDPRINTF ((stderr, "\n"));
-
-      yydestruct (yystos[yystate], *yyvsp);
-      yyvsp--;
-      yystate = *--yyssp;
-
-
-#if YYDEBUG
-      if (yydebug)
-	{
-	  short *yyssp1 = yyss - 1;
-	  YYFPRINTF (stderr, "Error: state stack now");
-	  while (yyssp1 != yyssp)
-	    YYFPRINTF (stderr, " %d", *++yyssp1);
-	  YYFPRINTF (stderr, "\n");
-	}
-#endif
-    }
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  YYDPRINTF ((stderr, "Shifting error token, "));
-
-  *++yyvsp = yylval;
-
-
-  yystate = yyn;
-  goto yynewstate;
-
-
-/*-------------------------------------.
-| yyacceptlab -- YYACCEPT comes here.  |
-`-------------------------------------*/
-yyacceptlab:
-  yyresult = 0;
-  goto yyreturn;
-
-/*-----------------------------------.
-| yyabortlab -- YYABORT comes here.  |
-`-----------------------------------*/
-yyabortlab:
-  yyresult = 1;
-  goto yyreturn;
-
-#ifndef yyoverflow
-/*----------------------------------------------.
-| yyoverflowlab -- parser overflow comes here.  |
-`----------------------------------------------*/
-yyoverflowlab:
-  yyerror ("parser stack overflow");
-  yyresult = 2;
-  /* Fall through.  */
-#endif
-
-yyreturn:
-#ifndef yyoverflow
-  if (yyss != yyssa)
-    YYSTACK_FREE (yyss);
-#endif
-  return yyresult;
-}
-
-
-#line 299 "loadkeys.y"
-			
-
-void usage()
-{
-  printf(_("Usage: %s [option...] [mapfile...]\n"), progname);
-  OPTIONS_ARE();
-  OPT("-c --clearcompose ", _("clear kernel compose table"));
-  OPT("-d --default      ", _("load default keymap file")); /* FIXME: should print DEFKMAP */
-  OPT("-m --mktable      ", _("output a \"defkeymap.c\" to stdout"));
-  OPT("-s --clearstrings ", _("clear kernel string table"));
-  OPT("-q --quiet        ", _("be silent"));
-  OPT("-v --verbose      ", _("report the changes"));
-  OPT("-v --verbose      ", _("report more changes"));
-
-  OPT("-h --help         ", HELPDESC);
-  OPT("-V --version      ", VERSIONDESC);
-}
-
-char **args;
-int optd = 0;
-int optm = 0;
-int opts = 0;
-int quiet = 0;
-int nocompose = 0;
-
-int main(int argc, char *argv[])
-{
-  const char *short_opts = "cdhmsqvV";
-  const struct option long_opts[] = {
-    { "clearcompose", no_argument, NULL, 'c' },
-    { "default",    no_argument, NULL, 'd' },
-    { "help",	no_argument, NULL, 'h' },
-    { "mktable",    no_argument, NULL, 'm' },
-    { "clearstrings", no_argument, NULL, 's' },
-    { "quiet",	no_argument, NULL, 'q' },
-    { "verbose",    no_argument, NULL, 'v' },
-    { "version", no_argument, NULL, 'V' },
-    { NULL, 0, NULL, 0 }
-  };
-  int c;
-  sigset_t sigset, old_sigset;
-  
-  setuplocale();
-
-  progname = strip_path(argv[0]);
-
-  while ((c = getopt_long(argc, argv,
-			  short_opts, long_opts, NULL)) != EOF)
-    {
-      switch (c)
-	{
-	case 'c':
-	  nocompose = 1;
-	  break;
-	case 'd':
-	  optd = 1;
-	  break;
-	case 'm':
-	  optm = 1;
-	  break;
-	case 's':
-	  opts = 1;
-	  break;
-	case 'q':
-	  quiet = 1;
-	  break;
-	case 'v':
-	  verbose++;
-	  break;
-	case 'V':
-	  version(progname);
-	  exit(0);
-	case 'h':
-	  usage();
-	  exit (0);
-	case '?':
-	  badusage(NULL);
-	}
-    }
-
-  args = argv + optind - 1;
-  unicode_used = 0;
-  /* set up the first input file, if any */
-  yywrap();
-  /* block SIGCHLD or it would break the scanner */
-  sigemptyset (&sigset);
-  sigaddset (&sigset, SIGCHLD);
-  sigprocmask (SIG_BLOCK, &sigset, &old_sigset);
-  if (yyparse() || private_error_ct)
-    {
-      fprintf(stderr, _("syntax error in map file\n"));
-      if(!optm)
-	fprintf(stderr, _("key bindings not changed\n"));
-      exit(1);
-    }
-  /* restore mask */
-  sigprocmask (SIG_SETMASK, &old_sigset, NULL);
-  do_constant();
-  if(optm)
-    mktable();
-  else
-    loadkeys();
-  exit(0);
-}
-
-char pathname[1024];
-char *filename;
-int line_nr = 1;
-
-int yyerror(char *s)
-{
-  fprintf(stderr, "%s:%d: %s\n", pathname, line_nr, s);
-  private_error_ct++;
-  return(0);
-}
-
-/* fatal errors - change to varargs next time */
-void lkfatal(char *s)
-{
-  fprintf(stderr, "%s: %s:%d: %s\n", progname, filename, line_nr, s);
-  exit(1);
-}
-
-void lkfatal0(char *s, int d)
-{
-  fprintf(stderr, "%s: %s:%d: ", progname, filename, line_nr);
-  fprintf(stderr, s, d);
-  fprintf(stderr, "\n");
-  exit(1);
-}
-
-void lkfatal1(char *s, char *s2)
-{
-  fprintf(stderr, "%s: %s:%d: ", progname, filename, line_nr);
-  fprintf(stderr, s, s2);
-  fprintf(stderr, "\n");
-  exit(1);
-}
-
-/* String file handling - flex-specific. */
-int in_string = 0;
-
-void lk_scan_string(char *s)
-{
-  lk_push();
-  in_string = 1;
-  yy_scan_string(s);
-}
-
-void lk_end_string(void)
-{
-  lk_pop();
-  in_string = 0;
-}
-
-#undef yywrap
-int yywrap(void) 
-{
-  FILE *f;
-  static int first_file = 1; /* ugly kludge flag */
-
-  if (in_string)
-    {
-      lk_end_string();
-      return 0;
-    }
-
-  if (infile_stack_ptr > 0)
-    {
-      lk_pop();
-      return 0;
-    }
-
-  line_nr = 1;
-  if (optd) {
-    /* first read default map */
-    optd = 0;
-    if((f = findkeymap(DEFKMAP, pathname, sizeof(pathname), stdin, NULL)) == NULL)
-      {
-	perror("findkeymap");
-	fprintf(stderr, _("Cannot find %s\n"), DEFKMAP);
-	exit(1);
-      }
-    goto gotf;
-  }
-  if (*args)
-    args++;
-  if (!*args)
-    return 1;
-  if (!strcmp(*args, "-"))
-    {
-      f = stdin;
-      strcpy(pathname, "<stdin>");
-    }
-  else if ((f = findkeymap(*args, pathname, sizeof(pathname), stdin, NULL)) == NULL)
-    {
-      perror("findkeymap");
-      fprintf(stderr, _("cannot open file %s\n"), *args);
-      exit(1);
-    }
-  /*
-    Can't use yyrestart if this is called before entering yyparse()
-    I think assigning directly to yyin isn't necessarily safe in
-    other situations, hence the flag.
-    */
-gotf:
-  filename = xstrdup(pathname);
-  if (!quiet)
-    fprintf(stderr, "Loading %s\n", pathname);
-  if (first_file)
-    {
-      yyin = f;
-      first_file = 0;
-    }
-  else
-    yyrestart(f);
-  return 0;
-}
-
-static void addmap(int i, int explicit)
-{
-  if (i < 0 || i >= MAX_NR_KEYMAPS)
-    lkfatal0(_("addmap called with bad index %d"), i);
-  
-  if (!defining[i])
-    {
-      if (keymaps_line_seen && !explicit)
-	lkfatal0(_("adding map %d violates explicit keymaps line)"), i);
-      
-      defining[i] = 1;
-      if (max_keymap <= i)
-	max_keymap = i+1;
-    }
-}
-
-/* unset a key */
-static void killkey(int index, int table)
-{
-  /* roughly: addkey(index, table, K_HOLE); */
-
-  if (index < 0 || index >= NR_KEYS)
-    lkfatal0(_("killkey called with bad index %d"), index);
-  if (table < 0 || table >= MAX_NR_KEYMAPS)
-    lkfatal0(_("killkey called with bad table %d"), table);
-  if (key_map[table])
-    (key_map[table])[index] = K_HOLE;
-  if (keymap_was_set[table])
-    (keymap_was_set[table])[index] = 0;
-}
-
-static void addkey(int index, int table, int keycode)
-{
-  int i;
-
-  if (keycode == -1)
-    return;
-  if (index < 0 || index >= NR_KEYS)
-    lkfatal0(_("addkey called with bad index %d"), index);
-  if (table < 0 || table >= MAX_NR_KEYMAPS)
-    lkfatal0(_("addkey called with bad table %d"), table);
-
-  if (!defining[table])
-    addmap(table, 0);
-  if (!key_map[table])
-    {
-      key_map[table] = (u_short *)xmalloc(NR_KEYS * sizeof(u_short));
-      for (i = 0; i < NR_KEYS; i++)
-	(key_map[table])[i] = K_HOLE;
-    }
-  if (!keymap_was_set[table])
-    {
-      keymap_was_set[table] = (char *) xmalloc(NR_KEYS);
-      for (i = 0; i < NR_KEYS; i++)
-	(keymap_was_set[table])[i] = 0;
-    }
-
-  if (alt_is_meta && keycode == K_HOLE && (keymap_was_set[table])[index])
-    return;
-
-  (key_map[table])[index] = keycode;
-  (keymap_was_set[table])[index] = 1;
-
-  if (alt_is_meta)
-    {
-      int alttable = table | M_ALT;
-      int type = KTYP(keycode);
-      int val = KVAL(keycode);
-
-      if (alttable != table && defining[alttable] &&
-	  (!keymap_was_set[alttable] ||
-	   !(keymap_was_set[alttable])[index]) &&
-	  (type == KT_LATIN || type == KT_LETTER) && val < 128)
-	addkey(index, alttable, K(KT_META, val));
-    }
-}
-
-static void addfunc(struct kbsentry kbs)
-{
-  int sh, i;
-  char *p, *q, *r;
-
-  if (kbs.kb_func >= MAX_NR_FUNC)
-    {
-      fprintf(stderr, _("%s: addfunc called with bad func %d\n"),
-	      progname, kbs.kb_func);
-      exit(1);
-    }
-  if ((q = func_table[kbs.kb_func]))	  /* throw out old previous def */
-    {
-      sh = strlen(q) + 1;
-      p = q + sh;
-      while (p < fp)
-	*q++ = *p++;
-      fp -= sh;
-    }
-  p = func_buf;                        /* find place for new def */
-  for (i = 0; i < kbs.kb_func; i++)
-    if (func_table[i])
-      {
-	p = func_table[i];
-	while(*p++);
-      }
-  func_table[kbs.kb_func] = p;
-  sh = strlen(kbs.kb_string) + 1;
-  if (fp + sh > func_buf + sizeof(func_buf))
-    {
-      fprintf(stderr, _("%s: addfunc: func_buf overflow\n"), progname);
-      exit(1);
-    }
-  q = fp;
-  fp += sh;
-  r = fp;
-  while (q > p)
-    *--r = *--q;
-  strcpy(p, kbs.kb_string);
-  for (i++; i < MAX_NR_FUNC; i++)
-    if (func_table[i])
-      func_table[i] += sh;
-}
-
-static int unicode_problem(void)
-{
-  /* Return TRUE if this kernel cannot handle unicode compose chars
-   *  properly;
-   * (Currently struct kbdiacr has 3 chars: { base, diacr, result},
-   * But result needs to be a string for proper Unicode handling)
-   */
-  return 1;
-}
-     
-static void compose(int diacr, int base, int res)
-{
-  struct kbdiacr *p;
-  if (accent_table_size == MAX_DIACR)
-    {
-      fprintf(stderr, _("compose table overflow\n"));
-      exit(1);
-    }
-  p = &accent_table[accent_table_size++];
-  p->diacr = diacr;
-  p->base = base;
-  p->result = res;
-  if (unicode_problem() && res > 0xFF) {
-    fprintf(stderr,
-	    _("Warning: Compose char %4x ('%c','%c') > 0xFF will be truncated to %2x\n"),
-	    res, p->base, p->diacr, p->result);
-    if (!unicode_warning) {
-      fprintf(stderr,_("  (Linux kernel < 2.3.X can't handle unicode compose chars properly)\n"));
-      unicode_warning = 1;
-    }
-  }
-}
-
-static int defkeys(int fd)
-{
-  struct kbentry ke;
-  int ct = 0;
-  int i,j,fail;
-  int oldm;
-
-  if (unicode_used)
-    {
-      /* Switch keyboard mode for a moment -
-	 do not complain about errors.
-	 Do not attempt a reset if the change failed. */
-      if (ioctl(fd, KDGKBMODE, &oldm)
-	  || (oldm != K_UNICODE && ioctl(fd, KDSKBMODE, K_UNICODE)))
-	oldm = K_UNICODE;
-    }
-
-  for(i=0; i<MAX_NR_KEYMAPS; i++)
-    {
-      if (key_map[i])
-	{
-	  for(j=0; j<NR_KEYS; j++)
-	    {
-	      if ((keymap_was_set[i])[j])
-		{
-		  ke.kb_index = j;
-		  ke.kb_table = i;
-		  ke.kb_value = (key_map[i])[j];
-
-		  fail = ioctl(fd, KDSKBENT, (unsigned long)&ke);
-		  if (fail)
-		    {
-		      if (errno == EPERM)
-			{
-			  fprintf(stderr, _("Keymap %d: Permission denied\n"), i);
-			  j = NR_KEYS;
-			  continue;
-			}
-		      perror("KDSKBENT");
-		    }
-		  else
-		    ct++;
-		  if(verbose)
-		    printf(_("keycode %d, table %d = %d%s\n"), j, i,
-			   (key_map[i])[j], fail ? _("    FAILED") : "");
-		  else if (fail)
-		    fprintf(stderr, _("failed to bind key %d to value %d\n"),
-			    j, (key_map[i])[j]);
-		}
-	    }
-	}
-      else if (keymaps_line_seen && !defining[i])
-	{
-	  /* deallocate keymap */
-	  ke.kb_index = 0;
-	  ke.kb_table = i;
-	  ke.kb_value = K_NOSUCHMAP;
-
-	  if (verbose > 1)
-	    printf(_("deallocate keymap %d\n"), i);
-
-	  if(ioctl(fd, KDSKBENT, (unsigned long)&ke))
-	    {
-	      if (errno != EINVAL)
-		{
-		  perror("KDSKBENT");
-		  fprintf(stderr,
-			  _("%s: could not deallocate keymap %d\n"),
-			  progname, i);
-		  exit(1);
-		}
-	      /* probably an old kernel */
-	      /* clear keymap by hand */
-	      for (j = 0; j < NR_KEYS; j++)
-		{
-		  ke.kb_index = j;
-		  ke.kb_table = i;
-		  ke.kb_value = K_HOLE;
-		  if(ioctl(fd, KDSKBENT, (unsigned long)&ke))
-		    {
-		      if (errno == EINVAL && i >= 16)
-			break; /* old kernel */
-		      perror("KDSKBENT");
-		      fprintf(stderr,
-			      _("%s: cannot deallocate or clear keymap\n"),
-			      progname);
-		      exit(1);
-		    }
-		}
-	    }
-	}
-    }
-
-  if(unicode_used && oldm != K_UNICODE)
-    {
-      if (ioctl(fd, KDSKBMODE, oldm))
-	{
-	  fprintf(stderr, _("%s: failed to restore keyboard mode\n"),
-		  progname);
-	}
-      fprintf(stderr, _("%s: warning: this map uses Unicode symbols\n"
-	      "    (perhaps you want to do `kbd_mode -u'?)\n"),
-	      progname);
-    }
-  return ct;
-}
-
-static char * ostr(char *s)
-{
-  int lth = strlen(s);
-  char *ns0 = (char*)xmalloc(4*lth + 1);
-  char *ns = ns0;
-
-  while(*s)
-    {
-      switch(*s)
-	{
-	case '\n':
-	  *ns++ = '\\';
-	  *ns++ = 'n';
-	  break;
-	case '\033':
-	  *ns++ = '\\';
-	  *ns++ = '0';
-	  *ns++ = '3';
-	  *ns++ = '3';
-	  break;
-	default:
-	  *ns++ = *s;
-	}
-      s++;
-    }
-  *ns = 0;
-  return ns0;
-}
-
-static int deffuncs(int fd)
-{
-  int i, ct = 0;
-  char *p;
-
-  for (i = 0; i < MAX_NR_FUNC; i++)
-    {
-      kbs_buf.kb_func = i;
-      if ((p = func_table[i]))
-	{
-	  strcpy(kbs_buf.kb_string, p);
-	  if (ioctl(fd, KDSKBSENT, (unsigned long)&kbs_buf))
-	    fprintf(stderr, _("failed to bind string '%s' to function %s\n"),
-		    ostr(kbs_buf.kb_string), syms[KT_FN].table[kbs_buf.kb_func]);
-	  else
-	    ct++;
-	}
-      else if (opts)
-	{
-	  kbs_buf.kb_string[0] = 0;
-	  if (ioctl(fd, KDSKBSENT, (unsigned long)&kbs_buf))
-	    fprintf(stderr, _("failed to clear string %s\n"),
-		    syms[KT_FN].table[kbs_buf.kb_func]);
-	  else
-	    ct++;
-	}
-    }
-  return ct;
-}
-
-static int defdiacs(int fd)
-{
-  struct kbdiacrs kd;
-  unsigned i;
-
-  kd.kb_cnt = accent_table_size;
-  if (kd.kb_cnt > MAX_DIACR) 
-    {
-      kd.kb_cnt = MAX_DIACR;
-      fprintf(stderr, _("too many compose definitions\n"));
-    }
-  for (i = 0; i < kd.kb_cnt; i++)
-      kd.kbdiacr[i] = accent_table[i];
-  
-  if(ioctl(fd, KDSKBDIACR, (unsigned long) &kd)) 
-    {
-      fprintf(stderr, _("KDSKBDIACR failed\n"));
-      perror("");
-      exit(1);
-    }
-  return kd.kb_cnt;
-}
-
-void do_constant_key (int i, u_short key)
-{
-  int typ, val, j;
-
-  typ = KTYP(key);
-  val = KVAL(key);
-  if ((typ == KT_LATIN || typ == KT_LETTER) &&
-      ((val >= 'a' && val <= 'z') ||
-       (val >= 'A' && val <= 'Z')))
-    {
-      u_short defs[16];
-      defs[0] = K(KT_LETTER, val);
-      defs[1] = K(KT_LETTER, val ^ 32);
-      defs[2] = defs[0];
-      defs[3] = defs[1];
-      for(j=4; j<8; j++)
-	defs[j] = K(KT_LATIN, val & ~96);
-      for(j=8; j<16; j++)
-	defs[j] = K(KT_META, KVAL(defs[j-8]));
-      for(j=0; j<max_keymap; j++)
-	{
-	  if (!defining[j])
-	    continue;
-	  if (j > 0 &&
-	      keymap_was_set[j] && (keymap_was_set[j])[i])
-	    continue;
-	  addkey(i, j, defs[j%16]);
-	}
-    }
-  else
-    {
-      /* do this also for keys like Escape,
-	 as promised in the man page */
-      for (j=1; j<max_keymap; j++)
-	if(defining[j] &&
-	   (!(keymap_was_set[j]) || !(keymap_was_set[j])[i]))
-	  addkey(i, j, key);
-    }
-}
-
-static void do_constant (void)
-{
-  int i, r0 = 0;
-
-  if (keymaps_line_seen)
-    while (r0 < max_keymap && !defining[r0])
-      r0++;
-
-  for (i=0; i<NR_KEYS; i++)
-    {
-      if (key_is_constant[i])
-	{
-	  u_short key;
-	  if (!key_map[r0])
-	    lkfatal(_("impossible error in do_constant"));
-	  key = (key_map[r0])[i];
-	  do_constant_key (i, key);
-	}
-    }
-}
-
-static void loadkeys (void)
-{
-  int fd;
-  int keyct, funcct, diacct;
-
-  if (-1 == (fd = get_console_fd(NULL)))
-    exit (1);
-		
-  keyct = defkeys(fd);
-  funcct = deffuncs(fd);
-  if (accent_table_size > 0 || nocompose)
-    diacct = defdiacs(fd);
-  if (verbose)
-    {
-      printf(_("\nChanged %d key%s and %d string%s.\n"),
-	     keyct, (keyct == 1) ? "" : "s",
-	     funcct, (funcct == 1) ? "" : "s");
-      if (accent_table_size > 0 || nocompose)
-	printf(_("Loaded %d compose definition%s.\n"),
-	       diacct, (diacct == 1) ? "" : "s");
-      else
-	printf(_("(No change in compose definitions.)\n"));
-    }
-}
-
-static void strings_as_usual(void)
-{
-  /*
-   * 28 strings, mostly inspired by the VT100 family
-   */
-  char *stringvalues[30] = {
-    /* F1 .. F20 */
-    "\033[[A", "\033[[B", "\033[[C", "\033[[D", "\033[[E",
-    "\033[17~", "\033[18~", "\033[19~", "\033[20~", "\033[21~",
-    "\033[23~", "\033[24~", "\033[25~", "\033[26~",
-    "\033[28~", "\033[29~",
-    "\033[31~", "\033[32~", "\033[33~", "\033[34~",
-    /* Find,    Insert,    Remove,    Select,    Prior */
-    "\033[1~", "\033[2~", "\033[3~", "\033[4~", "\033[5~",
-    /* Next,    Macro,  Help, Do,  Pause */
-    "\033[6~", "\033[M",  0,   0, "\033[P"
-  };
-  int i;
-  for (i=0; i<30; i++)
-    if(stringvalues[i])
-      {
-	struct kbsentry ke;
-	ke.kb_func = i;
-	strncpy(ke.kb_string, stringvalues[i], sizeof(ke.kb_string));
-	ke.kb_string[sizeof(ke.kb_string)-1] = 0;
-	addfunc(ke);
-      }
-}
-
-static void compose_as_usual(char *charset)
-{
-  if (charset && strcmp(charset, "iso-8859-1"))
-    {
-      fprintf(stderr, _("loadkeys: don't know how to compose for %s\n"),
-	      charset);
-      exit(1);
-    }
-  else
-    {
-      struct ccc {
-	char c1, c2, c3;
-      } def_latin1_composes[68] = {
-	{ '`', 'A', 0300 }, { '`', 'a', 0340 },
-	{ '\'', 'A', 0301 }, { '\'', 'a', 0341 },
-	{ '^', 'A', 0302 }, { '^', 'a', 0342 },
-	{ '~', 'A', 0303 }, { '~', 'a', 0343 },
-	{ '"', 'A', 0304 }, { '"', 'a', 0344 },
-	{ 'O', 'A', 0305 }, { 'o', 'a', 0345 },
-	{ '0', 'A', 0305 }, { '0', 'a', 0345 },
-	{ 'A', 'A', 0305 }, { 'a', 'a', 0345 },
-	{ 'A', 'E', 0306 }, { 'a', 'e', 0346 },
-	{ ',', 'C', 0307 }, { ',', 'c', 0347 },
-	{ '`', 'E', 0310 }, { '`', 'e', 0350 },
-	{ '\'', 'E', 0311 }, { '\'', 'e', 0351 },
-	{ '^', 'E', 0312 }, { '^', 'e', 0352 },
-	{ '"', 'E', 0313 }, { '"', 'e', 0353 },
-	{ '`', 'I', 0314 }, { '`', 'i', 0354 },
-	{ '\'', 'I', 0315 }, { '\'', 'i', 0355 },
-	{ '^', 'I', 0316 }, { '^', 'i', 0356 },
-	{ '"', 'I', 0317 }, { '"', 'i', 0357 },
-	{ '-', 'D', 0320 }, { '-', 'd', 0360 },
-	{ '~', 'N', 0321 }, { '~', 'n', 0361 },
-	{ '`', 'O', 0322 }, { '`', 'o', 0362 },
-	{ '\'', 'O', 0323 }, { '\'', 'o', 0363 },
-	{ '^', 'O', 0324 }, { '^', 'o', 0364 },
-	{ '~', 'O', 0325 }, { '~', 'o', 0365 },
-	{ '"', 'O', 0326 }, { '"', 'o', 0366 },
-	{ '/', 'O', 0330 }, { '/', 'o', 0370 },
-	{ '`', 'U', 0331 }, { '`', 'u', 0371 },
-	{ '\'', 'U', 0332 }, { '\'', 'u', 0372 },
-	{ '^', 'U', 0333 }, { '^', 'u', 0373 },
-	{ '"', 'U', 0334 }, { '"', 'u', 0374 },
-	{ '\'', 'Y', 0335 }, { '\'', 'y', 0375 },
-	{ 'T', 'H', 0336 }, { 't', 'h', 0376 },
-	{ 's', 's', 0337 }, { '"', 'y', 0377 },
-	{ 's', 'z', 0337 }, { 'i', 'j', 0377 }
-      };
-      int i;
-
-      for(i=0; i<68; i++)
-	{
-	  struct ccc p = def_latin1_composes[i];
-	  compose(p.c1, p.c2, p.c3);
-	}
-    }
-}
-
-/*
- * mktable.c
- *
- */
-static char *modifiers[8] = {
-  "shift", "altgr", "ctrl", "alt", "shl", "shr", "ctl", "ctr"
-};
-
-static char *mk_mapname(char mod)
-{
-  static char buf[60];
-  int i;
-
-  if (!mod)
-    return "plain";
-  buf[0] = 0;
-  for (i=0; i<8; i++)
-    if (mod & (1<<i))
-      {
-	if (buf[0])
-	  strcat(buf, "_");
-	strcat(buf, modifiers[i]);
-      }
-  return buf;
-}
-
-
-static void outchar (unsigned char c, int comma)
-{
-  printf("'");
-  printf((c == '\'' || c == '\\') ? "\\%c" : isgraph(c) ? "%c"
-	 : "\\%03o", c);
-  printf(comma ? "', " : "'");
-}
-
-static void mktable ()
-{
-  int i, imax, j;
-
-  /*	struct kbsentry kbs;*/
-  u_char *p;
-  int maxfunc;
-  unsigned int keymap_count = 0;
-
-  printf("\n"
-	 "/* Do not edit this file! It was automatically generated by   */\n"
-	 "/*    %s --mktable defkeymap.map > defkeymap.c          */\n\n"
-	 "#include <linux/types.h>\n"
-	 "#include <linux/keyboard.h>\n"
-	 "#include <linux/kd.h>\n\n"
-	 , progname);
-  for (i = 0; i < MAX_NR_KEYMAPS; i++)
-    if (key_map[i])
-      {
-	keymap_count++;
-	if (i)
-	  printf("static ");
-	printf("u_short %s_map[NR_KEYS] = {", mk_mapname(i));
-	for (j = 0; j < NR_KEYS; j++)
-	  {
-	    if (!(j % 8))
-	      printf("\n");
-	    printf("\t0x%04x,", U((key_map[i])[j]));
-	  }
-	printf("\n};\n\n");
-      }
-
-  for (imax = MAX_NR_KEYMAPS-1; imax > 0; imax--)
-    if (key_map[imax])
-      break;
-  printf("ushort *key_maps[MAX_NR_KEYMAPS] = {");
-  for (i = 0; i <= imax; i++)
-    {
-      printf((i%4) ? " " : "\n\t");
-      if (key_map[i])
-	printf("%s_map,", mk_mapname(i));
-      else
-	printf("0,");
-    }
-  if (imax < MAX_NR_KEYMAPS-1)
-    printf("\t0");
-  printf("\n};\n\nunsigned int keymap_count = %d;\n\n", keymap_count);
-	
-  printf("\n"
-	 "/*\n"
-	 " * Philosophy: most people do not define more strings, but they who do\n"
-	 " * often want quite a lot of string space. So, we statically allocate\n"
-	 " * the default and allocate dynamically in chunks of 512 bytes.\n"
-	 " */\n"
-	 "\n");
-  for (maxfunc = MAX_NR_FUNC; maxfunc; maxfunc--)
-    if(func_table[maxfunc-1])
-      break;
-
-  printf("char func_buf[] = {\n");
-  for (i = 0; i < maxfunc; i++)
-    {
-      p = func_table[i];
-      if (p)
-	{
-	  printf("\t");
-	  for ( ; *p; p++)
-	    outchar(*p, 1);
-	  printf("0, \n");
-	}
-    }
-  if (!maxfunc)
-    printf("\t0\n");
-  printf("};\n\n");
-
-  printf("\n"
-	 "char *funcbufptr = func_buf;\n"
-	 "int funcbufsize = sizeof(func_buf);\n"
-	 "int funcbufleft = 0;          /* space left */\n"
-	 "\n");
-
-  printf("char *func_table[MAX_NR_FUNC] = {\n");
-  for (i = 0; i < maxfunc; i++)
-    {
-      if (func_table[i])
-	printf("\tfunc_buf + %d,\n", func_table[i] - func_buf);
-      else
-	printf("\t0,\n");
-    }
-  if (maxfunc < MAX_NR_FUNC)
-    printf("\t0,\n");
-  printf("};\n");
-
-  printf("\nstruct kbdiacr accent_table[MAX_DIACR] = {\n");
-  for (i = 0; i < accent_table_size; i++)
-    {
-      printf("\t{");
-      outchar(accent_table[i].diacr, 1);
-      outchar(accent_table[i].base, 1);
-      outchar(accent_table[i].result, 0);
-      printf("},");
-      if(i%2) printf("\n");
-    }
-  if(i%2) printf("\n");
-  printf("};\n\n");
-  printf("unsigned int accent_table_size = %d;\n",
-	 accent_table_size);
-
-  exit(0);
-}
-
-
-
diff -ruN console-tools-0.2.3-old/kbdtools/loadkeys.y console-tools-0.2.3/kbdtools/loadkeys.y
--- console-tools-0.2.3-old/kbdtools/loadkeys.y	2003-08-12 22:57:39.000000000 +0100
+++ console-tools-0.2.3/kbdtools/loadkeys.y	2003-08-12 22:58:05.000000000 +0100
@@ -307,6 +307,7 @@
   OPT("-m --mktable      ", _("output a \"defkeymap.c\" to stdout"));
   OPT("-s --clearstrings ", _("clear kernel string table"));
   OPT("-q --quiet        ", _("be silent"));
+  OPT("-u --unicode	 ", _("unicode"));
   OPT("-v --verbose      ", _("report the changes"));
   OPT("-v --verbose      ", _("report more changes"));
 
@@ -323,13 +324,14 @@
 
 int main(int argc, char *argv[])
 {
-  const char *short_opts = "cdhmsqvV";
+  const char *short_opts = "cdhmsquvV";
   const struct option long_opts[] = {
     { "clearcompose", no_argument, NULL, 'c' },
     { "default",    no_argument, NULL, 'd' },
     { "help",	no_argument, NULL, 'h' },
     { "mktable",    no_argument, NULL, 'm' },
     { "clearstrings", no_argument, NULL, 's' },
+    { "unicode", no_argument, NULL, 'u' },
     { "quiet",	no_argument, NULL, 'q' },
     { "verbose",    no_argument, NULL, 'v' },
     { "version", no_argument, NULL, 'V' },
@@ -362,6 +364,9 @@
 	case 'q':
 	  quiet = 1;
 	  break;
+	case 'u':
+		set_charset("unicode");
+		break;
 	case 'v':
 	  verbose++;
 	  break;
diff -ruN console-tools-0.2.3-old/kbdtools/loadkeys.y.orig console-tools-0.2.3/kbdtools/loadkeys.y.orig
--- console-tools-0.2.3-old/kbdtools/loadkeys.y.orig	2003-08-12 22:57:39.000000000 +0100
+++ console-tools-0.2.3/kbdtools/loadkeys.y.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,1180 +0,0 @@
-/*
- * loadkeys.y
- *
- * Changes for 0.82:
- * Merged from version 0.81 of loadkeys.y and mktable.c - aeb@cwi.nl
- * Reason for change:
- *   The original version of mktable would use the current kernel
- *   for getting at the entries. However, this does not work if
- *   e.g. NR_FUNC in keyboard.h has changed. So, instead of getting
- *   the information from the current kernel, we must get it out of
- *   defkeymap.map, just like loadkeys. Thus, mktable is now an
- *   option of loadkeys.
- * (Other advantage: we first do the parsing, and then the key binding.
- *  No bindings are changed in case of a syntax error.)
- * Fix: contrary to the documentation in keytables.5 it was assumed
- * by default that the AltGr modifier had no effect. This assumption
- * has been removed.
- *
- * Changes for 0.83:
- * Added the intl_con patch by Eugene G. Crosser:
- * The modifier + in front of a keysym means that it is a letter,
- * and susceptible for change under CapsLock. For ASCII 'a'-'z'
- * and 'A'-'Z' no + is required (when given as a single entry).
- *
- * Changes for 0.84:
- * More compose key support. Default search path. Option -d.
- *
- * Change for 0.85:
- * Do not change compose key table when no definitions given.
- * Option -c to override this.
- *
- * Changes for 0.86:
- * Added a few synonyms. Comment may now contain non-ASCII symbols.
- *
- * Changes for 0.87:
- * Accept the "charset iso-8859-x" directive.
- *
- * Changes for 0.88:
- * Handle sparse keymaps and many strings. Accept "keymaps" directive.
- * Handle 8 modifiers. Handle Unicode.
- *
- * Change for 0.93:
- * Set K_UNICODE during the loading of keymaps requiring that.
- *
- * Change for 0.94:
- * Add alt_is_meta keyword:
- * Whenever some combination is defined as an ASCII symbol, and there
- * is a corresponding Alt keymap, define by default the corresponding
- * Alt combination as Meta_value.
- *
- * Change for 0.96:
- * Compose now accepts letter names.
- * Add strings_as_usual etc.
- * Add include directive.
- */
-
-%token EOL NUMBER LITERAL CHARSET KEYMAPS KEYCODE EQUALS
-%token PLAIN SHIFT CONTROL ALT ALTGR SHIFTL SHIFTR CTRLL CTRLR
-%token COMMA DASH STRING STRLITERAL COMPOSE TO CCHAR ERROR PLUS
-%token UNUMBER ALT_IS_META STRINGS AS USUAL ON FOR
-
-%{
-#include <errno.h>
-#include <stdio.h>
-#include <getopt.h>
-#include <stdlib.h>
-#include <string.h>
-#include <fcntl.h>
-#include <linux/kd.h>
-#include <linux/keyboard.h>
-#include <sys/ioctl.h>
-#include <ctype.h>
-#include <sysexits.h>
-#include <signal.h>
-
-#include <lct/local.h>
-#include <lct/utils.h>
-#include <lct/console.h>
-#include <lct/font.h>		/* findkeymap() */
-#include <lct/ksyms.h>
-#include <lct/modifiers.h>
-
-int verbose;
-void lk_push(void);				  /* in analyze.c */
-int lk_pop(void);				  /* idem */
-extern int infile_stack_ptr;			  /* idem */
-
-#ifndef KT_LETTER
-#define KT_LETTER KT_LATIN
-#endif
-
-#undef yywrap
-int yywrap(void);
-
-/* externs from analyse.l */
-extern int line_nr, rvalct;
-extern struct kbsentry kbs_buf;
-extern FILE* yyin;
-
-/* name to use in error messages */
-char *progname;
-
-/* give error message if using unicode compose strings? */
-int unicode_warning = 0;
-/* What keymaps are we defining? */
-char defining[MAX_NR_KEYMAPS];
-char keymaps_line_seen = 0;
-int max_keymap = 0;		/* from here on, defining[] is false */
-int alt_is_meta = 0;
-
-/* the kernel structures we want to set or print */
-u_short *key_map[MAX_NR_KEYMAPS];
-char *func_table[MAX_NR_FUNC];
-struct kbdiacr accent_table[MAX_DIACR];
-unsigned int accent_table_size = 0;
-
-char key_is_constant[NR_KEYS];
-char *keymap_was_set[MAX_NR_KEYMAPS];
-char func_buf[4096];		/* should be allocated dynamically */
-char *fp = func_buf;
-
-#define U(x) ((x) ^ 0xf000)
-
-#undef ECHO
-
-static void addmap(int map, int explicit);
-static void addkey(int index, int table, int keycode);
-static void addfunc(struct kbsentry kbs_buf);
-static void killkey(int index, int table);
-static void compose(int diacr, int base, int res);
-static void do_constant(void);
-static void do_constant_key (int, u_short);
-static void loadkeys(void);
-static void mktable(void);
-static void strings_as_usual(void);
-static void compose_as_usual(char *charset);
-void lkfatal(char *);
-void lkfatal0(char *, int);
-void lkfatal1(char *, char *);
-extern char *xstrdup(char *);
-int key_buf[MAX_NR_KEYMAPS];
-int mod;
-int unicode_used;
-int private_error_ct = 0;
-%}
-
-%%
-keytable	:
-		| keytable line
-		;
-line		: EOL
-		| charsetline
-		| altismetaline
-		| usualstringsline
-		| usualcomposeline
-		| keymapline
-		| fullline
-		| singleline
-		| strline
-                | compline
-		;
-charsetline	: CHARSET STRLITERAL EOL
-			{
-			    set_charset(kbs_buf.kb_string);
-			}
-		;
-altismetaline	: ALT_IS_META EOL
-			{
-			    alt_is_meta = 1;
-			}
-		;
-usualstringsline: STRINGS AS USUAL EOL
-			{
-			    strings_as_usual();
-			}
-		;
-usualcomposeline: COMPOSE AS USUAL FOR STRLITERAL EOL
-			{
-			    compose_as_usual(kbs_buf.kb_string);
-			}
-		  | COMPOSE AS USUAL EOL
-			{
-			    compose_as_usual(0);
-			}
-		;
-keymapline	: KEYMAPS range EOL
-			{
-			    keymaps_line_seen = 1;
-			}
-		;
-range		: range COMMA range0
-		| range0
-		;
-range0		: NUMBER DASH NUMBER
-			{
-			    int i;
-			    for (i = $1; i<= $3; i++)
-			      addmap(i,1);
-			}
-		| NUMBER
-			{
-			    addmap($1,1);
-			}
-		;
-strline		: STRING LITERAL EQUALS STRLITERAL EOL
-			{
-			    if (KTYP($2) != KT_FN)
-				lkfatal1("'%s' is not a function key symbol",
-					syms[KTYP($2)].table[KVAL($2)]);
-			    kbs_buf.kb_func = KVAL($2);
-			    addfunc(kbs_buf);
-			}
-		;
-compline        : COMPOSE CCHAR CCHAR TO CCHAR EOL
-                        {
-			    compose($2, $3, $5);
-			}
-		 | COMPOSE CCHAR CCHAR TO rvalue EOL
-			{
-			    compose($2, $3, $5);
-			}
-                ;
-singleline	:	{ mod = 0; }
-		  modifiers KEYCODE NUMBER EQUALS rvalue EOL
-			{
-			    addkey($4, mod, $6);
-			}
-		| PLAIN KEYCODE NUMBER EQUALS rvalue EOL
-			{
-			    addkey($4, 0, $6);
-			}
-		;
-modifiers	: modifiers modifier
-		| modifier
-		;
-modifier	: SHIFT		{ mod |= M_SHIFT;	}
-		| CONTROL	{ mod |= M_CTRL;	}
-		| ALT		{ mod |= M_ALT;		}
-		| ALTGR		{ mod |= M_ALTGR;	}
-		| SHIFTL	{ mod |= M_SHIFTL;	}
-		| SHIFTR	{ mod |= M_SHIFTR;	}
-		| CTRLL		{ mod |= M_CTRLL;	}
-		| CTRLR		{ mod |= M_CTRLR;	}
-		;
-fullline	: KEYCODE NUMBER EQUALS rvalue0 EOL
-	{
-	    int i, j;
-
-	    if (rvalct == 1) {
-	        /* Some files do not have a keymaps line, and
-		   we have to wait until all input has been read
-		   before we know which maps to fill. */
-	        key_is_constant[$2] = 1;
-	    
-		/* On the other hand, we now have include files,
-		   and it should be possible to override lines
-		   from an include file. So, kill old defs. */
-		for (j = 0; j < max_keymap; j++)
-		    if (defining[j])
-		        killkey($2, j);
-	    }
-	    if (keymaps_line_seen) {
-		i = 0;
-		for (j = 0; j < max_keymap; j++)
-		  if (defining[j]) {
-		      if (rvalct != 1 || i == 0)
-			addkey($2, j, (i < rvalct) ? key_buf[i] : K_HOLE);
-		      i++;
-		  }
-		if (i < rvalct)
-		    lkfatal0("too many (%d) entries on one line", rvalct);
-	    } else
-	      for (i = 0; i < rvalct; i++)
-		addkey($2, i, key_buf[i]);
-	}
-		;
-
-rvalue0		: 
-		| rvalue1 rvalue0
-		;
-rvalue1		: rvalue
-			{
-			    if (rvalct >= MAX_NR_KEYMAPS)
-				lkfatal(_("too many keydefinitions on one line"));
-			    key_buf[rvalct++] = $1;
-			}
-		;
-rvalue		: NUMBER
-			{$$=$1;}
-		| UNUMBER
-			{$$=($1 ^ 0xf000); unicode_used=1;}
-                | PLUS NUMBER
-                        {$$=K(KT_LETTER, KVAL($2));}
-		| LITERAL
-			{$$=$1;}
-                | PLUS LITERAL
-                        {$$=K(KT_LETTER, KVAL($2));}
-		;
-%%			
-
-void usage()
-{
-  printf(_("Usage: %s [option...] [mapfile...]\n"), progname);
-  OPTIONS_ARE();
-  OPT("-c --clearcompose ", _("clear kernel compose table"));
-  OPT("-d --default      ", _("load default keymap file")); /* FIXME: should print DEFKMAP */
-  OPT("-m --mktable      ", _("output a \"defkeymap.c\" to stdout"));
-  OPT("-s --clearstrings ", _("clear kernel string table"));
-  OPT("-q --quiet        ", _("be silent"));
-  OPT("-v --verbose      ", _("report the changes"));
-  OPT("-v --verbose      ", _("report more changes"));
-
-  OPT("-h --help         ", HELPDESC);
-  OPT("-V --version      ", VERSIONDESC);
-}
-
-char **args;
-int optd = 0;
-int optm = 0;
-int opts = 0;
-int quiet = 0;
-int nocompose = 0;
-
-int main(int argc, char *argv[])
-{
-  const char *short_opts = "cdhmsqvV";
-  const struct option long_opts[] = {
-    { "clearcompose", no_argument, NULL, 'c' },
-    { "default",    no_argument, NULL, 'd' },
-    { "help",	no_argument, NULL, 'h' },
-    { "mktable",    no_argument, NULL, 'm' },
-    { "clearstrings", no_argument, NULL, 's' },
-    { "quiet",	no_argument, NULL, 'q' },
-    { "verbose",    no_argument, NULL, 'v' },
-    { "version", no_argument, NULL, 'V' },
-    { NULL, 0, NULL, 0 }
-  };
-  int c;
-  sigset_t sigset, old_sigset;
-  
-  setuplocale();
-
-  progname = strip_path(argv[0]);
-
-  while ((c = getopt_long(argc, argv,
-			  short_opts, long_opts, NULL)) != EOF)
-    {
-      switch (c)
-	{
-	case 'c':
-	  nocompose = 1;
-	  break;
-	case 'd':
-	  optd = 1;
-	  break;
-	case 'm':
-	  optm = 1;
-	  break;
-	case 's':
-	  opts = 1;
-	  break;
-	case 'q':
-	  quiet = 1;
-	  break;
-	case 'v':
-	  verbose++;
-	  break;
-	case 'V':
-	  version(progname);
-	  exit(0);
-	case 'h':
-	  usage();
-	  exit (0);
-	case '?':
-	  badusage(NULL);
-	}
-    }
-
-  args = argv + optind - 1;
-  unicode_used = 0;
-  /* set up the first input file, if any */
-  yywrap();
-  /* block SIGCHLD or it would break the scanner */
-  sigemptyset (&sigset);
-  sigaddset (&sigset, SIGCHLD);
-  sigprocmask (SIG_BLOCK, &sigset, &old_sigset);
-  if (yyparse() || private_error_ct)
-    {
-      fprintf(stderr, _("syntax error in map file\n"));
-      if(!optm)
-	fprintf(stderr, _("key bindings not changed\n"));
-      exit(1);
-    }
-  /* restore mask */
-  sigprocmask (SIG_SETMASK, &old_sigset, NULL);
-  do_constant();
-  if(optm)
-    mktable();
-  else
-    loadkeys();
-  exit(0);
-}
-
-char pathname[1024];
-char *filename;
-int line_nr = 1;
-
-int yyerror(char *s)
-{
-  fprintf(stderr, "%s:%d: %s\n", pathname, line_nr, s);
-  private_error_ct++;
-  return(0);
-}
-
-/* fatal errors - change to varargs next time */
-void lkfatal(char *s)
-{
-  fprintf(stderr, "%s: %s:%d: %s\n", progname, filename, line_nr, s);
-  exit(1);
-}
-
-void lkfatal0(char *s, int d)
-{
-  fprintf(stderr, "%s: %s:%d: ", progname, filename, line_nr);
-  fprintf(stderr, s, d);
-  fprintf(stderr, "\n");
-  exit(1);
-}
-
-void lkfatal1(char *s, char *s2)
-{
-  fprintf(stderr, "%s: %s:%d: ", progname, filename, line_nr);
-  fprintf(stderr, s, s2);
-  fprintf(stderr, "\n");
-  exit(1);
-}
-
-/* String file handling - flex-specific. */
-int in_string = 0;
-
-void lk_scan_string(char *s)
-{
-  lk_push();
-  in_string = 1;
-  yy_scan_string(s);
-}
-
-void lk_end_string(void)
-{
-  lk_pop();
-  in_string = 0;
-}
-
-#undef yywrap
-int yywrap(void) 
-{
-  FILE *f;
-  static int first_file = 1; /* ugly kludge flag */
-
-  if (in_string)
-    {
-      lk_end_string();
-      return 0;
-    }
-
-  if (infile_stack_ptr > 0)
-    {
-      lk_pop();
-      return 0;
-    }
-
-  line_nr = 1;
-  if (optd) {
-    /* first read default map */
-    optd = 0;
-    if((f = findkeymap(DEFKMAP, pathname, sizeof(pathname), stdin, NULL)) == NULL)
-      {
-	perror("findkeymap");
-	fprintf(stderr, _("Cannot find %s\n"), DEFKMAP);
-	exit(1);
-      }
-    goto gotf;
-  }
-  if (*args)
-    args++;
-  if (!*args)
-    return 1;
-  if (!strcmp(*args, "-"))
-    {
-      f = stdin;
-      strcpy(pathname, "<stdin>");
-    }
-  else if ((f = findkeymap(*args, pathname, sizeof(pathname), stdin, NULL)) == NULL)
-    {
-      perror("findkeymap");
-      fprintf(stderr, _("cannot open file %s\n"), *args);
-      exit(1);
-    }
-  /*
-    Can't use yyrestart if this is called before entering yyparse()
-    I think assigning directly to yyin isn't necessarily safe in
-    other situations, hence the flag.
-    */
-gotf:
-  filename = xstrdup(pathname);
-  if (!quiet)
-    fprintf(stderr, "Loading %s\n", pathname);
-  if (first_file)
-    {
-      yyin = f;
-      first_file = 0;
-    }
-  else
-    yyrestart(f);
-  return 0;
-}
-
-static void addmap(int i, int explicit)
-{
-  if (i < 0 || i >= MAX_NR_KEYMAPS)
-    lkfatal0(_("addmap called with bad index %d"), i);
-  
-  if (!defining[i])
-    {
-      if (keymaps_line_seen && !explicit)
-	lkfatal0(_("adding map %d violates explicit keymaps line)"), i);
-      
-      defining[i] = 1;
-      if (max_keymap <= i)
-	max_keymap = i+1;
-    }
-}
-
-/* unset a key */
-static void killkey(int index, int table)
-{
-  /* roughly: addkey(index, table, K_HOLE); */
-
-  if (index < 0 || index >= NR_KEYS)
-    lkfatal0(_("killkey called with bad index %d"), index);
-  if (table < 0 || table >= MAX_NR_KEYMAPS)
-    lkfatal0(_("killkey called with bad table %d"), table);
-  if (key_map[table])
-    (key_map[table])[index] = K_HOLE;
-  if (keymap_was_set[table])
-    (keymap_was_set[table])[index] = 0;
-}
-
-static void addkey(int index, int table, int keycode)
-{
-  int i;
-
-  if (keycode == -1)
-    return;
-  if (index < 0 || index >= NR_KEYS)
-    lkfatal0(_("addkey called with bad index %d"), index);
-  if (table < 0 || table >= MAX_NR_KEYMAPS)
-    lkfatal0(_("addkey called with bad table %d"), table);
-
-  if (!defining[table])
-    addmap(table, 0);
-  if (!key_map[table])
-    {
-      key_map[table] = (u_short *)xmalloc(NR_KEYS * sizeof(u_short));
-      for (i = 0; i < NR_KEYS; i++)
-	(key_map[table])[i] = K_HOLE;
-    }
-  if (!keymap_was_set[table])
-    {
-      keymap_was_set[table] = (char *) xmalloc(NR_KEYS);
-      for (i = 0; i < NR_KEYS; i++)
-	(keymap_was_set[table])[i] = 0;
-    }
-
-  if (alt_is_meta && keycode == K_HOLE && (keymap_was_set[table])[index])
-    return;
-
-  (key_map[table])[index] = keycode;
-  (keymap_was_set[table])[index] = 1;
-
-  if (alt_is_meta)
-    {
-      int alttable = table | M_ALT;
-      int type = KTYP(keycode);
-      int val = KVAL(keycode);
-
-      if (alttable != table && defining[alttable] &&
-	  (!keymap_was_set[alttable] ||
-	   !(keymap_was_set[alttable])[index]) &&
-	  (type == KT_LATIN || type == KT_LETTER) && val < 128)
-	addkey(index, alttable, K(KT_META, val));
-    }
-}
-
-static void addfunc(struct kbsentry kbs)
-{
-  int sh, i;
-  char *p, *q, *r;
-
-  if (kbs.kb_func >= MAX_NR_FUNC)
-    {
-      fprintf(stderr, _("%s: addfunc called with bad func %d\n"),
-	      progname, kbs.kb_func);
-      exit(1);
-    }
-  if ((q = func_table[kbs.kb_func]))	  /* throw out old previous def */
-    {
-      sh = strlen(q) + 1;
-      p = q + sh;
-      while (p < fp)
-	*q++ = *p++;
-      fp -= sh;
-    }
-  p = func_buf;                        /* find place for new def */
-  for (i = 0; i < kbs.kb_func; i++)
-    if (func_table[i])
-      {
-	p = func_table[i];
-	while(*p++);
-      }
-  func_table[kbs.kb_func] = p;
-  sh = strlen(kbs.kb_string) + 1;
-  if (fp + sh > func_buf + sizeof(func_buf))
-    {
-      fprintf(stderr, _("%s: addfunc: func_buf overflow\n"), progname);
-      exit(1);
-    }
-  q = fp;
-  fp += sh;
-  r = fp;
-  while (q > p)
-    *--r = *--q;
-  strcpy(p, kbs.kb_string);
-  for (i++; i < MAX_NR_FUNC; i++)
-    if (func_table[i])
-      func_table[i] += sh;
-}
-
-static int unicode_problem(void)
-{
-  /* Return TRUE if this kernel cannot handle unicode compose chars
-   *  properly;
-   * (Currently struct kbdiacr has 3 chars: { base, diacr, result},
-   * But result needs to be a string for proper Unicode handling)
-   */
-  return 1;
-}
-     
-static void compose(int diacr, int base, int res)
-{
-  struct kbdiacr *p;
-  if (accent_table_size == MAX_DIACR)
-    {
-      fprintf(stderr, _("compose table overflow\n"));
-      exit(1);
-    }
-  p = &accent_table[accent_table_size++];
-  p->diacr = diacr;
-  p->base = base;
-  p->result = res;
-  if (unicode_problem() && res > 0xFF) {
-    fprintf(stderr,
-	    _("Warning: Compose char %4x ('%c','%c') > 0xFF will be truncated to %2x\n"),
-	    res, p->base, p->diacr, p->result);
-    if (!unicode_warning) {
-      fprintf(stderr,_("  (Linux kernel < 2.3.X can't handle unicode compose chars properly)\n"));
-      unicode_warning = 1;
-    }
-  }
-}
-
-static int defkeys(int fd)
-{
-  struct kbentry ke;
-  int ct = 0;
-  int i,j,fail;
-  int oldm;
-
-  if (unicode_used)
-    {
-      /* Switch keyboard mode for a moment -
-	 do not complain about errors.
-	 Do not attempt a reset if the change failed. */
-      if (ioctl(fd, KDGKBMODE, &oldm)
-	  || (oldm != K_UNICODE && ioctl(fd, KDSKBMODE, K_UNICODE)))
-	oldm = K_UNICODE;
-    }
-
-  for(i=0; i<MAX_NR_KEYMAPS; i++)
-    {
-      if (key_map[i])
-	{
-	  for(j=0; j<NR_KEYS; j++)
-	    {
-	      if ((keymap_was_set[i])[j])
-		{
-		  ke.kb_index = j;
-		  ke.kb_table = i;
-		  ke.kb_value = (key_map[i])[j];
-
-		  fail = ioctl(fd, KDSKBENT, (unsigned long)&ke);
-		  if (fail)
-		    {
-		      if (errno == EPERM)
-			{
-			  fprintf(stderr, _("Keymap %d: Permission denied\n"), i);
-			  j = NR_KEYS;
-			  continue;
-			}
-		      perror("KDSKBENT");
-		    }
-		  else
-		    ct++;
-		  if(verbose)
-		    printf(_("keycode %d, table %d = %d%s\n"), j, i,
-			   (key_map[i])[j], fail ? _("    FAILED") : "");
-		  else if (fail)
-		    fprintf(stderr, _("failed to bind key %d to value %d\n"),
-			    j, (key_map[i])[j]);
-		}
-	    }
-	}
-      else if (keymaps_line_seen && !defining[i])
-	{
-	  /* deallocate keymap */
-	  ke.kb_index = 0;
-	  ke.kb_table = i;
-	  ke.kb_value = K_NOSUCHMAP;
-
-	  if (verbose > 1)
-	    printf(_("deallocate keymap %d\n"), i);
-
-	  if(ioctl(fd, KDSKBENT, (unsigned long)&ke))
-	    {
-	      if (errno != EINVAL)
-		{
-		  perror("KDSKBENT");
-		  fprintf(stderr,
-			  _("%s: could not deallocate keymap %d\n"),
-			  progname, i);
-		  exit(1);
-		}
-	      /* probably an old kernel */
-	      /* clear keymap by hand */
-	      for (j = 0; j < NR_KEYS; j++)
-		{
-		  ke.kb_index = j;
-		  ke.kb_table = i;
-		  ke.kb_value = K_HOLE;
-		  if(ioctl(fd, KDSKBENT, (unsigned long)&ke))
-		    {
-		      if (errno == EINVAL && i >= 16)
-			break; /* old kernel */
-		      perror("KDSKBENT");
-		      fprintf(stderr,
-			      _("%s: cannot deallocate or clear keymap\n"),
-			      progname);
-		      exit(1);
-		    }
-		}
-	    }
-	}
-    }
-
-  if(unicode_used && oldm != K_UNICODE)
-    {
-      if (ioctl(fd, KDSKBMODE, oldm))
-	{
-	  fprintf(stderr, _("%s: failed to restore keyboard mode\n"),
-		  progname);
-	}
-      fprintf(stderr, _("%s: warning: this map uses Unicode symbols\n"
-	      "    (perhaps you want to do `kbd_mode -u'?)\n"),
-	      progname);
-    }
-  return ct;
-}
-
-static char * ostr(char *s)
-{
-  int lth = strlen(s);
-  char *ns0 = (char*)xmalloc(4*lth + 1);
-  char *ns = ns0;
-
-  while(*s)
-    {
-      switch(*s)
-	{
-	case '\n':
-	  *ns++ = '\\';
-	  *ns++ = 'n';
-	  break;
-	case '\033':
-	  *ns++ = '\\';
-	  *ns++ = '0';
-	  *ns++ = '3';
-	  *ns++ = '3';
-	  break;
-	default:
-	  *ns++ = *s;
-	}
-      s++;
-    }
-  *ns = 0;
-  return ns0;
-}
-
-static int deffuncs(int fd)
-{
-  int i, ct = 0;
-  char *p;
-
-  for (i = 0; i < MAX_NR_FUNC; i++)
-    {
-      kbs_buf.kb_func = i;
-      if ((p = func_table[i]))
-	{
-	  strcpy(kbs_buf.kb_string, p);
-	  if (ioctl(fd, KDSKBSENT, (unsigned long)&kbs_buf))
-	    fprintf(stderr, _("failed to bind string '%s' to function %s\n"),
-		    ostr(kbs_buf.kb_string), syms[KT_FN].table[kbs_buf.kb_func]);
-	  else
-	    ct++;
-	}
-      else if (opts)
-	{
-	  kbs_buf.kb_string[0] = 0;
-	  if (ioctl(fd, KDSKBSENT, (unsigned long)&kbs_buf))
-	    fprintf(stderr, _("failed to clear string %s\n"),
-		    syms[KT_FN].table[kbs_buf.kb_func]);
-	  else
-	    ct++;
-	}
-    }
-  return ct;
-}
-
-static int defdiacs(int fd)
-{
-  struct kbdiacrs kd;
-  unsigned i;
-
-  kd.kb_cnt = accent_table_size;
-  if (kd.kb_cnt > MAX_DIACR) 
-    {
-      kd.kb_cnt = MAX_DIACR;
-      fprintf(stderr, _("too many compose definitions\n"));
-    }
-  for (i = 0; i < kd.kb_cnt; i++)
-      kd.kbdiacr[i] = accent_table[i];
-  
-  if(ioctl(fd, KDSKBDIACR, (unsigned long) &kd)) 
-    {
-      fprintf(stderr, _("KDSKBDIACR failed\n"));
-      perror("");
-      exit(1);
-    }
-  return kd.kb_cnt;
-}
-
-void do_constant_key (int i, u_short key)
-{
-  int typ, val, j;
-
-  typ = KTYP(key);
-  val = KVAL(key);
-  if ((typ == KT_LATIN || typ == KT_LETTER) &&
-      ((val >= 'a' && val <= 'z') ||
-       (val >= 'A' && val <= 'Z')))
-    {
-      u_short defs[16];
-      defs[0] = K(KT_LETTER, val);
-      defs[1] = K(KT_LETTER, val ^ 32);
-      defs[2] = defs[0];
-      defs[3] = defs[1];
-      for(j=4; j<8; j++)
-	defs[j] = K(KT_LATIN, val & ~96);
-      for(j=8; j<16; j++)
-	defs[j] = K(KT_META, KVAL(defs[j-8]));
-      for(j=0; j<max_keymap; j++)
-	{
-	  if (!defining[j])
-	    continue;
-	  if (j > 0 &&
-	      keymap_was_set[j] && (keymap_was_set[j])[i])
-	    continue;
-	  addkey(i, j, defs[j%16]);
-	}
-    }
-  else
-    {
-      /* do this also for keys like Escape,
-	 as promised in the man page */
-      for (j=1; j<max_keymap; j++)
-	if(defining[j] &&
-	   (!(keymap_was_set[j]) || !(keymap_was_set[j])[i]))
-	  addkey(i, j, key);
-    }
-}
-
-static void do_constant (void)
-{
-  int i, r0 = 0;
-
-  if (keymaps_line_seen)
-    while (r0 < max_keymap && !defining[r0])
-      r0++;
-
-  for (i=0; i<NR_KEYS; i++)
-    {
-      if (key_is_constant[i])
-	{
-	  u_short key;
-	  if (!key_map[r0])
-	    lkfatal(_("impossible error in do_constant"));
-	  key = (key_map[r0])[i];
-	  do_constant_key (i, key);
-	}
-    }
-}
-
-static void loadkeys (void)
-{
-  int fd;
-  int keyct, funcct, diacct;
-
-  if (-1 == (fd = get_console_fd(NULL)))
-    exit (1);
-		
-  keyct = defkeys(fd);
-  funcct = deffuncs(fd);
-  if (accent_table_size > 0 || nocompose)
-    diacct = defdiacs(fd);
-  if (verbose)
-    {
-      printf(_("\nChanged %d key%s and %d string%s.\n"),
-	     keyct, (keyct == 1) ? "" : "s",
-	     funcct, (funcct == 1) ? "" : "s");
-      if (accent_table_size > 0 || nocompose)
-	printf(_("Loaded %d compose definition%s.\n"),
-	       diacct, (diacct == 1) ? "" : "s");
-      else
-	printf(_("(No change in compose definitions.)\n"));
-    }
-}
-
-static void strings_as_usual(void)
-{
-  /*
-   * 28 strings, mostly inspired by the VT100 family
-   */
-  char *stringvalues[30] = {
-    /* F1 .. F20 */
-    "\033[[A", "\033[[B", "\033[[C", "\033[[D", "\033[[E",
-    "\033[17~", "\033[18~", "\033[19~", "\033[20~", "\033[21~",
-    "\033[23~", "\033[24~", "\033[25~", "\033[26~",
-    "\033[28~", "\033[29~",
-    "\033[31~", "\033[32~", "\033[33~", "\033[34~",
-    /* Find,    Insert,    Remove,    Select,    Prior */
-    "\033[1~", "\033[2~", "\033[3~", "\033[4~", "\033[5~",
-    /* Next,    Macro,  Help, Do,  Pause */
-    "\033[6~", "\033[M",  0,   0, "\033[P"
-  };
-  int i;
-  for (i=0; i<30; i++)
-    if(stringvalues[i])
-      {
-	struct kbsentry ke;
-	ke.kb_func = i;
-	strncpy(ke.kb_string, stringvalues[i], sizeof(ke.kb_string));
-	ke.kb_string[sizeof(ke.kb_string)-1] = 0;
-	addfunc(ke);
-      }
-}
-
-static void compose_as_usual(char *charset)
-{
-  if (charset && strcmp(charset, "iso-8859-1"))
-    {
-      fprintf(stderr, _("loadkeys: don't know how to compose for %s\n"),
-	      charset);
-      exit(1);
-    }
-  else
-    {
-      struct ccc {
-	char c1, c2, c3;
-      } def_latin1_composes[68] = {
-	{ '`', 'A', 0300 }, { '`', 'a', 0340 },
-	{ '\'', 'A', 0301 }, { '\'', 'a', 0341 },
-	{ '^', 'A', 0302 }, { '^', 'a', 0342 },
-	{ '~', 'A', 0303 }, { '~', 'a', 0343 },
-	{ '"', 'A', 0304 }, { '"', 'a', 0344 },
-	{ 'O', 'A', 0305 }, { 'o', 'a', 0345 },
-	{ '0', 'A', 0305 }, { '0', 'a', 0345 },
-	{ 'A', 'A', 0305 }, { 'a', 'a', 0345 },
-	{ 'A', 'E', 0306 }, { 'a', 'e', 0346 },
-	{ ',', 'C', 0307 }, { ',', 'c', 0347 },
-	{ '`', 'E', 0310 }, { '`', 'e', 0350 },
-	{ '\'', 'E', 0311 }, { '\'', 'e', 0351 },
-	{ '^', 'E', 0312 }, { '^', 'e', 0352 },
-	{ '"', 'E', 0313 }, { '"', 'e', 0353 },
-	{ '`', 'I', 0314 }, { '`', 'i', 0354 },
-	{ '\'', 'I', 0315 }, { '\'', 'i', 0355 },
-	{ '^', 'I', 0316 }, { '^', 'i', 0356 },
-	{ '"', 'I', 0317 }, { '"', 'i', 0357 },
-	{ '-', 'D', 0320 }, { '-', 'd', 0360 },
-	{ '~', 'N', 0321 }, { '~', 'n', 0361 },
-	{ '`', 'O', 0322 }, { '`', 'o', 0362 },
-	{ '\'', 'O', 0323 }, { '\'', 'o', 0363 },
-	{ '^', 'O', 0324 }, { '^', 'o', 0364 },
-	{ '~', 'O', 0325 }, { '~', 'o', 0365 },
-	{ '"', 'O', 0326 }, { '"', 'o', 0366 },
-	{ '/', 'O', 0330 }, { '/', 'o', 0370 },
-	{ '`', 'U', 0331 }, { '`', 'u', 0371 },
-	{ '\'', 'U', 0332 }, { '\'', 'u', 0372 },
-	{ '^', 'U', 0333 }, { '^', 'u', 0373 },
-	{ '"', 'U', 0334 }, { '"', 'u', 0374 },
-	{ '\'', 'Y', 0335 }, { '\'', 'y', 0375 },
-	{ 'T', 'H', 0336 }, { 't', 'h', 0376 },
-	{ 's', 's', 0337 }, { '"', 'y', 0377 },
-	{ 's', 'z', 0337 }, { 'i', 'j', 0377 }
-      };
-      int i;
-
-      for(i=0; i<68; i++)
-	{
-	  struct ccc p = def_latin1_composes[i];
-	  compose(p.c1, p.c2, p.c3);
-	}
-    }
-}
-
-/*
- * mktable.c
- *
- */
-static char *modifiers[8] = {
-  "shift", "altgr", "ctrl", "alt", "shl", "shr", "ctl", "ctr"
-};
-
-static char *mk_mapname(char mod)
-{
-  static char buf[60];
-  int i;
-
-  if (!mod)
-    return "plain";
-  buf[0] = 0;
-  for (i=0; i<8; i++)
-    if (mod & (1<<i))
-      {
-	if (buf[0])
-	  strcat(buf, "_");
-	strcat(buf, modifiers[i]);
-      }
-  return buf;
-}
-
-
-static void outchar (unsigned char c, int comma)
-{
-  printf("'");
-  printf((c == '\'' || c == '\\') ? "\\%c" : isgraph(c) ? "%c"
-	 : "\\%03o", c);
-  printf(comma ? "', " : "'");
-}
-
-static void mktable ()
-{
-  int i, imax, j;
-
-  /*	struct kbsentry kbs;*/
-  u_char *p;
-  int maxfunc;
-  unsigned int keymap_count = 0;
-
-  printf("\n"
-	 "/* Do not edit this file! It was automatically generated by   */\n"
-	 "/*    %s --mktable defkeymap.map > defkeymap.c          */\n\n"
-	 "#include <linux/types.h>\n"
-	 "#include <linux/keyboard.h>\n"
-	 "#include <linux/kd.h>\n\n"
-	 , progname);
-  for (i = 0; i < MAX_NR_KEYMAPS; i++)
-    if (key_map[i])
-      {
-	keymap_count++;
-	if (i)
-	  printf("static ");
-	printf("u_short %s_map[NR_KEYS] = {", mk_mapname(i));
-	for (j = 0; j < NR_KEYS; j++)
-	  {
-	    if (!(j % 8))
-	      printf("\n");
-	    printf("\t0x%04x,", U((key_map[i])[j]));
-	  }
-	printf("\n};\n\n");
-      }
-
-  for (imax = MAX_NR_KEYMAPS-1; imax > 0; imax--)
-    if (key_map[imax])
-      break;
-  printf("ushort *key_maps[MAX_NR_KEYMAPS] = {");
-  for (i = 0; i <= imax; i++)
-    {
-      printf((i%4) ? " " : "\n\t");
-      if (key_map[i])
-	printf("%s_map,", mk_mapname(i));
-      else
-	printf("0,");
-    }
-  if (imax < MAX_NR_KEYMAPS-1)
-    printf("\t0");
-  printf("\n};\n\nunsigned int keymap_count = %d;\n\n", keymap_count);
-	
-  printf("\n"
-	 "/*\n"
-	 " * Philosophy: most people do not define more strings, but they who do\n"
-	 " * often want quite a lot of string space. So, we statically allocate\n"
-	 " * the default and allocate dynamically in chunks of 512 bytes.\n"
-	 " */\n"
-	 "\n");
-  for (maxfunc = MAX_NR_FUNC; maxfunc; maxfunc--)
-    if(func_table[maxfunc-1])
-      break;
-
-  printf("char func_buf[] = {\n");
-  for (i = 0; i < maxfunc; i++)
-    {
-      p = func_table[i];
-      if (p)
-	{
-	  printf("\t");
-	  for ( ; *p; p++)
-	    outchar(*p, 1);
-	  printf("0, \n");
-	}
-    }
-  if (!maxfunc)
-    printf("\t0\n");
-  printf("};\n\n");
-
-  printf("\n"
-	 "char *funcbufptr = func_buf;\n"
-	 "int funcbufsize = sizeof(func_buf);\n"
-	 "int funcbufleft = 0;          /* space left */\n"
-	 "\n");
-
-  printf("char *func_table[MAX_NR_FUNC] = {\n");
-  for (i = 0; i < maxfunc; i++)
-    {
-      if (func_table[i])
-	printf("\tfunc_buf + %d,\n", func_table[i] - func_buf);
-      else
-	printf("\t0,\n");
-    }
-  if (maxfunc < MAX_NR_FUNC)
-    printf("\t0,\n");
-  printf("};\n");
-
-  printf("\nstruct kbdiacr accent_table[MAX_DIACR] = {\n");
-  for (i = 0; i < accent_table_size; i++)
-    {
-      printf("\t{");
-      outchar(accent_table[i].diacr, 1);
-      outchar(accent_table[i].base, 1);
-      outchar(accent_table[i].result, 0);
-      printf("},");
-      if(i%2) printf("\n");
-    }
-  if(i%2) printf("\n");
-  printf("};\n\n");
-  printf("unsigned int accent_table_size = %d;\n",
-	 accent_table_size);
-
-  exit(0);
-}
-
-
diff -ruN console-tools-0.2.3-old/lib/ksyms.c console-tools-0.2.3/lib/ksyms.c
--- console-tools-0.2.3-old/lib/ksyms.c	1999-07-19 20:40:38.000000000 +0100
+++ console-tools-0.2.3/lib/ksyms.c	2003-08-12 22:57:40.000000000 +0100
@@ -976,32 +976,55 @@
 }
 
 
-int ksymtocode(char *s)
+static int prefer_unicode = 0;
+
+
+typedef struct {
+	unsigned short uni;
+	const char *name;
+} sym;
+
+int ksymtocode(char *s, int *unicode_used)
 {
   int i;
-  int j;
+  int j,jmax;
   int keycode;
   static int warn = 0;
+  sym *p;
   
   if (!strncmp(s, "Meta_", 5)) 
     {
-      keycode = ksymtocode(s+5);
+      keycode = ksymtocode(s+5,unicode_used);
       if (KTYP(keycode) == KT_LATIN)
 	  return K(KT_META, KVAL(keycode));
       /* fall through to error printf */
     }
 
   /* declared charset */
-  for (i = 0; i < syms_size; i++)
+  for (i = 0; i < syms_size; i++) {
+      jmax = ((i == 0 && prefer_unicode) ? 128 : syms[i].size);
       for (j = 0; j < syms[i].size; j++)
 	  if (!strcmp(s,syms[i].table[j]))
 	      return K(i, j);
-  
+  }
+
   /* synonyms */
   for (i = 0; i < syn_size; i++)
       if (!strcmp(s, synonyms[i].synonym))
-	  return ksymtocode(synonyms[i].official_name);
-  
+	  return ksymtocode(synonyms[i].official_name,unicode_used);
+
+
+   if (prefer_unicode) {
+		for (i = 0; i < sizeof(charsets)/sizeof(charsets[0]); i++) {
+			p = charsets[i].charnames;
+		    for (j = charsets[i].start; j < 256; j++, p++)
+				if (!strcmp(s,p->name)) {
+					*unicode_used = 1;
+					return (p->uni ^ 0xf000); /* % */
+		        }
+         }
+	} else { 
+   
   /* try other charsets */
   
   for (i = 0; i < 256 - 160; i++)
@@ -1028,4 +1051,5 @@
   fprintf(stderr, _("unknown keysym `%s'\n"), s);
   
   return -1;
+	}
 }
diff -ruN console-tools-0.2.3-old/screenfonttools/unicode_start console-tools-0.2.3/screenfonttools/unicode_start
--- console-tools-0.2.3-old/screenfonttools/unicode_start	2003-08-12 22:57:39.000000000 +0100
+++ console-tools-0.2.3/screenfonttools/unicode_start	2003-08-12 22:57:40.000000000 +0100
@@ -8,11 +8,14 @@
     exit 0
 fi
 
+
 if /usr/bin/vt-is-UTF8 --quiet ; then
     echo "unicode_start: Already in UTF8 mode"
     exit 0
 fi
 
+dumpkeys | loadkeys --unicode > /dev/null
+
 kbd_mode -u
 
 case $# in
