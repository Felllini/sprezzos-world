From 57f90a03df614e21369956cd83648c5635944976 Mon Sep 17 00:00:00 2001
From: Andreas Schwab <schwab@linux-m68k.org>
Date: Wed, 11 Jan 2012 14:47:58 +0100
Subject: [PATCH] ENH: Add support for Motorola extended float format

---
 numpy/core/include/numpy/npy_cpu.h        |    2 +
 numpy/core/include/numpy/npy_endian.h     |    3 +-
 numpy/core/scons_support.py               |    1 +
 numpy/core/setup.py                       |    1 +
 numpy/core/setup_common.py                |    4 +++
 numpy/core/src/npymath/npy_math_private.h |   39 +++++++++++++++++++++++++++++
 numpy/core/src/private/npy_fpmath.h       |    1 +
 7 files changed, 50 insertions(+), 1 deletions(-)

diff --git a/numpy/core/include/numpy/npy_cpu.h b/numpy/core/include/numpy/npy_cpu.h
index 8a29788..f094ff4 100644
--- a/numpy/core/include/numpy/npy_cpu.h
+++ b/numpy/core/include/numpy/npy_cpu.h
@@ -66,6 +66,8 @@
     #define NPY_CPU_MIPSEL
 #elif defined(__MIPSEB__)
     #define NPY_CPU_MIPSEB
+#elif defined(__mc68000__)
+    #define NPY_CPU_M68K
 #else
     #error Unknown CPU, please report this to numpy maintainers with \
     information about your platform (OS, CPU and compiler)
diff --git a/numpy/core/include/numpy/npy_endian.h b/numpy/core/include/numpy/npy_endian.h
index aa5ed8b..2bf2177 100644
--- a/numpy/core/include/numpy/npy_endian.h
+++ b/numpy/core/include/numpy/npy_endian.h
@@ -35,7 +35,8 @@
             || defined(NPY_CPU_PPC64)   \
             || defined(NPY_CPU_ARMEB)   \
             || defined(NPY_CPU_SH_BE)   \
-            || defined(NPY_CPU_MIPSEB)
+            || defined(NPY_CPU_MIPSEB)  \
+            || defined(NPY_CPU_M68K)
         #define NPY_BYTE_ORDER NPY_BIG_ENDIAN
     #else
         #error Unknown CPU: can not set endianness
diff --git a/numpy/core/scons_support.py b/numpy/core/scons_support.py
index 048f85d..cf451ca 100644
--- a/numpy/core/scons_support.py
+++ b/numpy/core/scons_support.py
@@ -241,6 +241,7 @@ def CheckLongDoubleRepresentation(context):
     msg = {
         'INTEL_EXTENDED_12_BYTES_LE': "Intel extended, little endian",
         'INTEL_EXTENDED_16_BYTES_LE': "Intel extended, little endian",
+        'MOTOROLA_EXTENDED_12_BYTES_BE': "Motorola extended, big endian",
         'IEEE_QUAD_BE': "IEEE Quad precision, big endian",
         'IEEE_QUAD_LE': "IEEE Quad precision, little endian",
         'IEEE_DOUBLE_LE': "IEEE Double precision, little endian",
diff --git a/numpy/core/setup.py b/numpy/core/setup.py
index e8f40e8..cf6168c 100644
--- a/numpy/core/setup.py
+++ b/numpy/core/setup.py
@@ -442,6 +442,7 @@ def configuration(parent_package='',top_path=None):
                 rep = check_long_double_representation(config_cmd)
                 if rep in ['INTEL_EXTENDED_12_BYTES_LE',
                            'INTEL_EXTENDED_16_BYTES_LE',
+                           'MOTOROLA_EXTENDED_12_BYTES_BE',
                            'IEEE_QUAD_LE', 'IEEE_QUAD_BE',
                            'IEEE_DOUBLE_LE', 'IEEE_DOUBLE_BE',
                            'DOUBLE_DOUBLE_BE']:
diff --git a/numpy/core/setup_common.py b/numpy/core/setup_common.py
index e88be40..af024f3 100644
--- a/numpy/core/setup_common.py
+++ b/numpy/core/setup_common.py
@@ -216,6 +216,8 @@ _INTEL_EXTENDED_12B = ['000', '000', '000', '000', '240', '242', '171', '353',
                        '031', '300', '000', '000']
 _INTEL_EXTENDED_16B = ['000', '000', '000', '000', '240', '242', '171', '353',
                        '031', '300', '000', '000', '000', '000', '000', '000']
+_MOTOROLA_EXTENDED_12B = ['300', '031', '000', '000', '353', '171',
+                          '242', '240', '000', '000', '000', '000']
 _IEEE_QUAD_PREC_BE = ['300', '031', '326', '363', '105', '100', '000', '000',
                       '000', '000', '000', '000', '000', '000', '000', '000']
 _IEEE_QUAD_PREC_LE = _IEEE_QUAD_PREC_BE[::-1]
@@ -249,6 +251,8 @@ def long_double_representation(lines):
                 if read[:12] == _BEFORE_SEQ[4:]:
                     if read[12:-8] == _INTEL_EXTENDED_12B:
                         return 'INTEL_EXTENDED_12_BYTES_LE'
+                    if read[12:-8] == _MOTOROLA_EXTENDED_12B:
+                        return 'MOTOROLA_EXTENDED_12_BYTES_BE'
                 elif read[:8] == _BEFORE_SEQ[8:]:
                     if read[8:-8] == _INTEL_EXTENDED_16B:
                         return 'INTEL_EXTENDED_16_BYTES_LE'
diff --git a/numpy/core/src/npymath/npy_math_private.h b/numpy/core/src/npymath/npy_math_private.h
index 722d03f..c6f11f8 100644
--- a/numpy/core/src/npymath/npy_math_private.h
+++ b/numpy/core/src/npymath/npy_math_private.h
@@ -250,6 +250,45 @@ do {                                                            \
     typedef npy_uint32 ldouble_man_t;
     typedef npy_uint32 ldouble_exp_t;
     typedef npy_uint32 ldouble_sign_t;
+#elif defined(HAVE_LDOUBLE_MOTOROLA_EXTENDED_12_BYTES_BE)
+    /*
+     * Motorola extended 80 bits precision. Bit representation is
+     *          |     s  |eeeeeeeeeeeeeee|  junk  |mmmmmmmm................mmmmmmm|
+     *          |  1 bit |    15 bits    | 16 bits|            64 bits            |
+     *          |             a[0]                |     a[1]     |    a[2]        |
+     *
+     * 16 low bits of a[0] are junk
+     */
+    typedef npy_uint32 IEEEl2bitsrep_part;
+
+/* my machine */
+
+    union IEEEl2bitsrep {
+        npy_longdouble     e;
+        IEEEl2bitsrep_part a[3];
+    };
+
+    #define LDBL_MANL_INDEX     2
+    #define LDBL_MANL_MASK      0xFFFFFFFF
+    #define LDBL_MANL_SHIFT     0
+
+    #define LDBL_MANH_INDEX     1
+    #define LDBL_MANH_MASK      0xFFFFFFFF
+    #define LDBL_MANH_SHIFT     0
+
+    #define LDBL_EXP_INDEX      0
+    #define LDBL_EXP_MASK       0x7FFF0000
+    #define LDBL_EXP_SHIFT      16
+
+    #define LDBL_SIGN_INDEX     0
+    #define LDBL_SIGN_MASK      0x80000000
+    #define LDBL_SIGN_SHIFT     31
+
+    #define LDBL_NBIT           0x80000000
+
+    typedef npy_uint32 ldouble_man_t;
+    typedef npy_uint32 ldouble_exp_t;
+    typedef npy_uint32 ldouble_sign_t;
 #elif defined(HAVE_LDOUBLE_IEEE_DOUBLE_16_BYTES_BE) || \
       defined(HAVE_LDOUBLE_IEEE_DOUBLE_BE)
     /* 64 bits IEEE double precision aligned on 16 bytes: used by ppc arch on
diff --git a/numpy/core/src/private/npy_fpmath.h b/numpy/core/src/private/npy_fpmath.h
index 92338e4..8a120ca 100644
--- a/numpy/core/src/private/npy_fpmath.h
+++ b/numpy/core/src/private/npy_fpmath.h
@@ -40,6 +40,7 @@
       defined(HAVE_LDOUBLE_IEEE_DOUBLE_16_BYTES_BE) || \
       defined(HAVE_LDOUBLE_INTEL_EXTENDED_16_BYTES_LE) || \
       defined(HAVE_LDOUBLE_INTEL_EXTENDED_12_BYTES_LE) || \
+      defined(HAVE_LDOUBLE_MOTOROLA_EXTENDED_12_BYTES_BE) || \
       defined(HAVE_LDOUBLE_DOUBLE_DOUBLE_BE))
     #error No long double representation defined
 #endif
-- 
1.7.8.3

