--- ./plugins/video/H.263-1998/h263-1998.cxx
+++ ./plugins/video/H.263-1998/h263-1998.cxx
@@ -312,6 +312,7 @@
     return;
   }
 
+#if 0
   if (STRCMPI(option, H263_ANNEX_D) == 0) {
     // Annex D: Unrestructed Motion Vectors
     // Level 2+ 
@@ -322,6 +323,7 @@
       m_context->flags &= ~CODEC_FLAG_H263P_UMV; 
     return;
   }
+#endif
 
 #if 0 // DO NOT ENABLE THIS FLAG. FFMPEG IS NOT THREAD_SAFE WHEN THIS FLAG IS SET
   if (STRCMPI(option, H263_ANNEX_F) == 0) {
@@ -356,6 +358,7 @@
     return;
   }
 
+#if 0
   if (STRCMPI(option, H263_ANNEX_K) == 0) {
     // Annex K: Slice Structure
     // does not work with eyeBeam
@@ -375,6 +378,7 @@
       m_context->flags &= ~CODEC_FLAG_H263P_AIV; 
     return;
   }
+#endif
 
   if (STRCMPI(option, PLUGINCODEC_MEDIA_PACKETIZATION) == 0 ||
       STRCMPI(option, PLUGINCODEC_MEDIA_PACKETIZATIONS) == 0) {
@@ -450,14 +454,14 @@
   PTRACE(5, m_prefix, "qmax set to " << m_context->qmax);
   PTRACE(5, m_prefix, "payload size set to " << m_context->rtp_payload_size);
 
-  #define CODEC_TRACER_FLAG(tracer, flag) \
-    PTRACE(4, m_prefix, #flag " is " << ((m_context->flags & flag) ? "enabled" : "disabled"));
-  CODEC_TRACER_FLAG(tracer, CODEC_FLAG_H263P_UMV);
-  CODEC_TRACER_FLAG(tracer, CODEC_FLAG_OBMC);
+  #define CODEC_TRACER_FLAG(tracer, flag) \
+    PTRACE(4, m_prefix, #flag " is " << ((m_context->flags & flag) ? "enabled" : "disabled"));
+  //CODEC_TRACER_FLAG(tracer, CODEC_FLAG_H263P_UMV);
+  //CODEC_TRACER_FLAG(tracer, CODEC_FLAG_OBMC);
   CODEC_TRACER_FLAG(tracer, CODEC_FLAG_AC_PRED);
-  CODEC_TRACER_FLAG(tracer, CODEC_FLAG_H263P_SLICE_STRUCT)
+  //CODEC_TRACER_FLAG(tracer, CODEC_FLAG_H263P_SLICE_STRUCT)
   CODEC_TRACER_FLAG(tracer, CODEC_FLAG_LOOP_FILTER);
-  CODEC_TRACER_FLAG(tracer, CODEC_FLAG_H263P_AIV);
+  //CODEC_TRACER_FLAG(tracer, CODEC_FLAG_H263P_AIV);
 
   return FFMPEGLibraryInstance.AvcodecOpen(m_context, m_codec) == 0;
 }
@@ -603,13 +607,13 @@
   m_context->rtp_callback = &H263_RFC2190_EncoderContext::RTPCallBack;
   m_context->opaque = this; // used to separate out packets from different encode threads
 
-  m_context->flags &= ~CODEC_FLAG_H263P_UMV;
+  //m_context->flags &= ~CODEC_FLAG_H263P_UMV;
   m_context->flags &= ~CODEC_FLAG_4MV;
 #if LIBAVCODEC_RTP_MODE
   m_context->flags &= ~CODEC_FLAG_H263P_AIC;
 #endif
-  m_context->flags &= ~CODEC_FLAG_H263P_AIV;
-  m_context->flags &= ~CODEC_FLAG_H263P_SLICE_STRUCT;
+  // m_context->flags &= ~CODEC_FLAG_H263P_AIV;
+  //m_context->flags &= ~CODEC_FLAG_H263P_SLICE_STRUCT;
 
   return true;
 }
