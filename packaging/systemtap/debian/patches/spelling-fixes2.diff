From 100a540ef9addb97d94dd4fac8513f83ac800bef Mon Sep 17 00:00:00 2001
From: Timo Juhani Lindfors <timo.lindfors@iki.fi>
Date: Mon, 6 Feb 2012 15:34:38 +0200
Subject: [PATCH 2/3] Fix more spelling errors

---
 buildrun.cxx                                       |    2 +-
 install-sh                                         |    4 ++--
 parse.cxx                                          |    2 +-
 runtime/staprun/modverify.c                        |    4 ++--
 runtime/transport/ring_buffer.c                    |    2 +-
 runtime/uprobes-common.c                           |    8 ++++----
 runtime/uprobes/Makefile                           |    2 +-
 tapset/errno.stp                                   |    2 +-
 tapset/nfs_proc.stp                                |    2 +-
 tapset/nfsd.stp                                    |    2 +-
 tapset/speculative.stp                             |    2 +-
 tapset/stap_staticmarkers.stp                      |    2 +-
 tapset/tcpmib.stp                                  |    2 +-
 tapsets.cxx                                        |    2 +-
 testsuite/systemtap.examples/network/tcpipstat.stp |    2 +-
 15 files changed, 20 insertions(+), 20 deletions(-)

Applied-Upstream: http://sources.redhat.com/git/gitweb.cgi?p=systemtap.git;a=commit;h=100a540ef9addb97d94dd4fac8513f83ac800bef

diff --git a/buildrun.cxx b/buildrun.cxx
index d5a2b3c..fd8535a 100644
--- a/buildrun.cxx
+++ b/buildrun.cxx
@@ -314,7 +314,7 @@ compile_pass (systemtap_session& s)
     o << "EXTRA_CFLAGS += -ftime-report -Q" << endl;
 
   // XXX: unfortunately, -save-temps can't work since linux kbuild cwd
-  // is not writeable.
+  // is not writable.
   //
   // if (s.keep_tmpdir)
   // o << "CFLAGS += -fverbose-asm -save-temps" << endl;
diff --git a/install-sh b/install-sh
index 6781b98..81018a0 100755
--- a/install-sh
+++ b/install-sh
@@ -1,7 +1,7 @@
 #!/bin/sh
 # install - install a program, script, or datafile
 
-scriptversion=2009-04-28.21; # UTC
+scriptversion=2012-02-06.13; # UTC
 
 # This originates from X11R5 (mit/util/scripts/install.sh), which was
 # later released in X11R6 (xc/config/util/install.sh) with the
@@ -347,7 +347,7 @@ do
 	      if test -z "$dir_arg" || {
 		   # Check for POSIX incompatibilities with -m.
 		   # HP-UX 11.23 and IRIX 6.5 mkdir -m -p sets group- or
-		   # other-writeable bit of parent directory when it shouldn't.
+		   # other-writable bit of parent directory when it shouldn't.
 		   # FreeBSD 6.1 mkdir -m -p sets mode of existing directory.
 		   ls_ld_tmpdir=`ls -ld "$tmpdir"`
 		   case $ls_ld_tmpdir in
diff --git a/parse.cxx b/parse.cxx
index fe2163f..e8ed3ce 100644
--- a/parse.cxx
+++ b/parse.cxx
@@ -1570,7 +1570,7 @@ parser::parse_functiondecl (std::vector<functiondecl*>& functions)
     {
       t = next ();
 
-      // permit zero-argument fuctions
+      // permit zero-argument functions
       if (t->type == tok_operator && t->content == ")")
         break;
       else if (! (t->type == tok_identifier))
diff --git a/runtime/staprun/modverify.c b/runtime/staprun/modverify.c
index 4df3b0d..830fb9f 100644
--- a/runtime/staprun/modverify.c
+++ b/runtime/staprun/modverify.c
@@ -80,7 +80,7 @@ check_db_file_permissions (const char *cert_db_file) {
   if ((info.st_mode & S_IRUSR) == 0)
     fprintf (stderr, "Certificate database file %s should be readable by the owner.\n", cert_db_file);
   if ((info.st_mode & S_IWUSR) == 0)
-    fprintf (stderr, "Certificate database file %s should be writeable by the owner.\n", cert_db_file);
+    fprintf (stderr, "Certificate database file %s should be writable by the owner.\n", cert_db_file);
   if ((info.st_mode & S_IXUSR) != 0)
     {
       fprintf (stderr, "Certificate database file %s must not be executable by the owner.\n", cert_db_file);
@@ -165,7 +165,7 @@ check_cert_db_permissions (const char *cert_db_path) {
   if ((info.st_mode & S_IRUSR) == 0)
     fprintf (stderr, "Certificate database %s should be readable by the owner.\n", cert_db_path);
   if ((info.st_mode & S_IWUSR) == 0)
-    fprintf (stderr, "Certificate database %s should be writeable by the owner.\n", cert_db_path);
+    fprintf (stderr, "Certificate database %s should be writable by the owner.\n", cert_db_path);
   if ((info.st_mode & S_IXUSR) == 0)
     fprintf (stderr, "Certificate database %s should be searchable by the owner.\n", cert_db_path);
   if ((info.st_mode & S_IRGRP) == 0)
diff --git a/runtime/transport/ring_buffer.c b/runtime/transport/ring_buffer.c
index 119a698..7909263 100644
--- a/runtime/transport/ring_buffer.c
+++ b/runtime/transport/ring_buffer.c
@@ -679,7 +679,7 @@ static int _stp_data_write_commit(void *entry)
 	{
 		struct _stp_data_entry *sde = ring_buffer_event_data(event);
 		char *last = sde->buf + (sde->len - 5);
-		dbug_trans2("commiting %.5s...%.5s\n", sde->buf, last);
+		dbug_trans2("committing %.5s...%.5s\n", sde->buf, last);
 	}
 #endif
 	atomic_inc(&(_stp_get_iterator()->nr_events));
diff --git a/runtime/uprobes-common.c b/runtime/uprobes-common.c
index 2e11c71..f557f71 100644
--- a/runtime/uprobes-common.c
+++ b/runtime/uprobes-common.c
@@ -143,13 +143,13 @@ static int stap_uprobe_change_semaphore_plus (struct task_struct *tsk, unsigned
      semaphore.  If the probe is in a .so, we calculate the 
      address when the initial mmap maps the entire solib, e.g.
      7f089885a000-7f089885b000  rw-p-  libtcl.so
-     A subsequent mmap maps in the writeable segment where the 
+     A subsequent mmap maps in the writable segment where the 
      semaphore control variable lives, e.g.
      7f089850d000-7f0898647000  r-xp-  libtcl.so
      7f0898647000-7f0898846000  ---p   libtcl.so
      7f0898846000-7f089885b000  rw-p-  libtcl.so
      The second pass, stap_uprobe_change_semaphore_plus, sets the semaphore.
-     If the probe is in a .so this will be when the writeable segment of the .so
+     If the probe is in a .so this will be when the writable segment of the .so
      is mapped in.  If the task changes, then recalculate the address.
   */
 
@@ -280,7 +280,7 @@ stap_uprobe_mmap_found (struct stap_task_finder_target *tgt,
    *     so stap_uprobe_change_plus can set a semaphore,
    *     i.e. a static extern, in a shared object
    * 2 - the shared library we're interested in
-   * 3 - mapping should be executable or writeable (for semaphore in .so)
+   * 3 - mapping should be executable or writable (for semaphore in .so)
    *     NB: or both, on kernels that lack noexec mapping
    */
   if (path == NULL || strcmp (path, stf->pathname))
@@ -297,7 +297,7 @@ stap_uprobe_mmap_found (struct stap_task_finder_target *tgt,
     rc = stap_uprobe_change_plus (tsk, addr, length, stf, offset, vm_flags);
   }
 
-  /* Check writeable sections for semaphores.
+  /* Check writable sections for semaphores.
    * NB: They may have also been executable for the check above, if we're
    *     running a kernel that lacks noexec mappings.  So long as there's
    *     no error (rc == 0), we need to look for semaphores too.
diff --git a/runtime/uprobes/Makefile b/runtime/uprobes/Makefile
index 98b72f2..286e62c 100644
--- a/runtime/uprobes/Makefile
+++ b/runtime/uprobes/Makefile
@@ -15,7 +15,7 @@ CERTDB = ../../../../etc/systemtap/staprun
 # Build the module and, if we are root or stap-server, sign it.
 # Make sure that all the required tools and resources are available
 # before attempting to sign the module. 
-# Ensure that the generated files are writeable by the group which
+# Ensure that the generated files are writable by the group which
 # owns this build directory. This is so that the stap-server service
 # can rebuild the module, if necessary.
 default:
diff --git a/tapset/errno.stp b/tapset/errno.stp
index 58689a5..47057c4 100644
--- a/tapset/errno.stp
+++ b/tapset/errno.stp
@@ -346,7 +346,7 @@ static const int Maxerrno = sizeof(errlist)/sizeof(char *);
 /**
  * sfunction errno_str - Symbolic string associated with error code
  *
- * @err: The error number recieved
+ * @err: The error number received
  *
  * Description: This function returns the symbolic string associated
  * with the giver error code, such as ENOENT for the number 2, or
diff --git a/tapset/nfs_proc.stp b/tapset/nfs_proc.stp
index ad14eb6..b5bd2d3 100644
--- a/tapset/nfs_proc.stp
+++ b/tapset/nfs_proc.stp
@@ -1202,7 +1202,7 @@ probe nfs.proc4.commit_setup.return = kernel.function("nfs4_proc_commit_setup")
  * @version: NFS version
  * @status: result of last operation
  * @valid: fattr->valid ,indicates which fields are valid 
- * @count: number of bytes commited
+ * @count: number of bytes committed
  * @timestamp: V4 timestamp, which is used for lease renewal
  *
  * Fires when a reply to a commit RPC task is received
diff --git a/tapset/nfsd.stp b/tapset/nfsd.stp
index 55a4885..791cb443 100644
--- a/tapset/nfsd.stp
+++ b/tapset/nfsd.stp
@@ -1122,7 +1122,7 @@ probe nfsd.write.return = kernel.function("nfsd_write").return !,
 }
 
 /**
- * probe nfsd.commit - NFS server commiting all pending writes to stable storage
+ * probe nfsd.commit - NFS server committing all pending writes to stable storage
  *
  * @client_ip: the ip address of client
  * @fh: file handle (the first part is the length of the file handle)
diff --git a/tapset/speculative.stp b/tapset/speculative.stp
index 4338672..1ec512e 100644
--- a/tapset/speculative.stp
+++ b/tapset/speculative.stp
@@ -17,7 +17,7 @@ global _spec_discard
  * The speculation() function is called when a new speculation buffer is needed.
  * It returns an id for the speculative output.
  * There can be multiple threads being speculated on concurrently.
- * This id is used by other speculation fuctions to keep the threads
+ * This id is used by other speculation functions to keep the threads
  * separate.
  */
 function speculation:long ()
diff --git a/tapset/stap_staticmarkers.stp b/tapset/stap_staticmarkers.stp
index 7555404..1d86373 100644
--- a/tapset/stap_staticmarkers.stp
+++ b/tapset/stap_staticmarkers.stp
@@ -296,7 +296,7 @@ probe staprun.send_control_message = process("staprun").mark("send__ctlmsg") {
 }
 
 /**
- * probe stapio.receive_control_message - Recieved a control message
+ * probe stapio.receive_control_message - Received a control message
  * @type: type of message being send; defined in runtime/transport/transport_msgs.h
  * @data: a ptr to a binary blob of data sent as the control message
  * @len: the length (in bytes) of the data blob
diff --git a/tapset/tcpmib.stp b/tapset/tcpmib.stp
index 7d744e4..f6e0281 100644
--- a/tapset/tcpmib.stp
+++ b/tapset/tcpmib.stp
@@ -191,7 +191,7 @@ tcpmib.EstabResets = kernel.function("tcp_set_state").call ?
 }
 
 /**
- * probe tcpmib.InSegs - Count an incomming tcp segment
+ * probe tcpmib.InSegs - Count an incoming tcp segment
  * @sk: pointer to the struct sock being acted on
  * @op: value to be added to the counter (default value of 1)
  *
diff --git a/tapsets.cxx b/tapsets.cxx
index cb56170..716e23c 100644
--- a/tapsets.cxx
+++ b/tapsets.cxx
@@ -3449,7 +3449,7 @@ dwarf_var_expanding_visitor::visit_target_symbol (target_symbol *e)
       if (lvalue && !q.sess.guru_mode)
         throw semantic_error(_("write to target variable not permitted; need stap -g"), e->tok);
 
-      // XXX: process $context vars should be writeable
+      // XXX: process $context vars should be writable
 
       // See if we need to generate a new probe to save/access function
       // parameters from a return probe.  PR 1382.
diff --git a/testsuite/systemtap.examples/network/tcpipstat.stp b/testsuite/systemtap.examples/network/tcpipstat.stp
index 17781e8..1b70153 100755
--- a/testsuite/systemtap.examples/network/tcpipstat.stp
+++ b/testsuite/systemtap.examples/network/tcpipstat.stp
@@ -550,7 +550,7 @@ probe end {
  * The impact of running this script on your system can
  * be reduced by enabling only the probes corresponding to the
  * statictics you are interested in.  For example, if all you care about
- * is counting the number of incomming connections that are established use:
+ * is counting the number of incoming connections that are established use:
  * "probe tcpmib.PassiveOpens {}"
  */
 
-- 
1.7.2.5

