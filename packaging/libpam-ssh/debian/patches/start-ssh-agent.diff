## The origins of this patch is unknown as of this writing.  If you
## made this patch, please email the maintainer of the Debian package
## so we can give proper credit.
##
## Originally named 01_home_cleanup.dpatch.

Index: libpam-ssh-1.92/pam_ssh.c
===================================================================
--- libpam-ssh-1.92.orig/pam_ssh.c	2008-11-29 20:26:30.000000000 +0100
+++ libpam-ssh-1.92/pam_ssh.c	2008-11-30 12:47:33.000000000 +0100
@@ -301,9 +301,8 @@
  */
 
 static int
-add_keys(pam_handle_t *pamh, char *socket)
+add_keys(pam_handle_t *pamh, AuthenticationConnection *ac)
 {
-	AuthenticationConnection *ac;	/* connection to ssh-agent */
 	char *comment;			/* private key comment */
 	char *data_name;		/* PAM state */
 	int final;			/* final return value */
@@ -311,13 +310,6 @@
 	Key *key;			/* user's private key */
 	int retval;			/* from calls */
 
-	/* connect to the agent */
-
-	if (!(ac = ssh_get_authentication_connection(socket))) {
-		pam_ssh_log(LOG_ERR, "%s: %m", socket);
-		return PAM_SESSION_ERR;
-	}
-
 	/* hand off each private key to the agent */
 
 	final = 0;
@@ -346,11 +338,177 @@
 		if (!final)
 			final = retval;
 	}
-	ssh_close_authentication_connection(ac);
 
 	return final ? PAM_SUCCESS : PAM_SESSION_ERR;
 }
 
+static int
+start_ssh_agent(pam_handle_t *pamh, uid_t uid, FILE **env_read)
+{
+	pid_t child_pid;		/* child process that spawns agent */
+	int child_pipe[2];		/* pipe to child process */
+	int child_status;		/* child process status */
+	char *arg[3], *env[1];		/* to pass to execve() */
+
+	if (pipe(child_pipe) < 0) {
+		pam_ssh_log(LOG_ERR, "pipe: %m");
+		return PAM_SERVICE_ERR;
+	}
+	switch (child_pid = fork()) {
+	case -1:	/* error */
+		pam_ssh_log(LOG_ERR, "fork: %m");
+		close(child_pipe[0]);
+		close(child_pipe[1]);
+		return PAM_SERVICE_ERR;
+		/* NOTREACHED */
+	case 0:		/* child */
+
+		/* Permanently drop privileges using setuid()
+			 before executing ssh-agent so that root
+			 privileges can't possibly be regained (some
+			 ssh-agents insist that euid == ruid
+			 anyway).  System V won't let us use
+			 setuid() unless euid == 0, so we
+			 temporarily regain root privileges first
+			 with openpam_restore_cred() (which calls
+			 seteuid()). */
+
+		switch (openpam_restore_cred(pamh)) {
+		case PAM_SYSTEM_ERR:
+			pam_ssh_log(LOG_ERR,
+			            "can't restore privileges: %m");
+			_exit(EX_OSERR);
+			/* NOTREACHED */
+		case PAM_SUCCESS:
+			if (setuid(uid) == -1) {
+				pam_ssh_log(LOG_ERR,
+				            "can't drop privileges: %m",
+				            uid);
+				_exit(EX_NOPERM);
+			}
+			break;
+		}
+
+		if (close(child_pipe[0]) == -1) {
+			pam_ssh_log(LOG_ERR, "close: %m");
+			_exit(EX_OSERR);
+		}
+		if (child_pipe[1] != STDOUT_FILENO) {
+			if (dup2(child_pipe[1], STDOUT_FILENO) == -1) {
+				pam_ssh_log(LOG_ERR, "dup: %m");
+				_exit(EX_OSERR);
+			}
+			if (close(child_pipe[1]) == -1) {
+				pam_ssh_log(LOG_ERR, "close: %m");
+				_exit(EX_OSERR);
+			}
+		}
+		arg[0] = "ssh-agent";
+		arg[1] = "-s";
+		arg[2] = NULL;
+		env[0] = NULL;
+		execve(PATH_SSH_AGENT, arg, env);
+		pam_ssh_log(LOG_ERR, "%s: %m", PATH_SSH_AGENT);
+		_exit(127);
+		/* NOTREACHED */
+	}
+	if (close(child_pipe[1]) == -1) {
+		pam_ssh_log(LOG_ERR, "close: %m");
+		return PAM_SESSION_ERR;
+	}
+	if (!(*env_read = fdopen(child_pipe[0], "r"))) {
+		pam_ssh_log(LOG_ERR, "%s: %m", PATH_SSH_AGENT);
+		return PAM_SESSION_ERR;
+	}
+
+	child_status = 0;
+	if (waitpid_intr(child_pid, &child_status, 0) == -1 &&
+			errno != ECHILD) {
+		pam_ssh_log(LOG_ERR, "%s: %m", PATH_SSH_AGENT);
+		return PAM_SESSION_ERR;
+	}
+
+	if (child_status != 0) {
+		if (WIFSIGNALED(child_status))
+			pam_ssh_log(LOG_ERR, "%s exited on signal %d",
+									PATH_SSH_AGENT, WTERMSIG(child_status));
+		else
+			if (WEXITSTATUS(child_status) == 127)
+				pam_ssh_log(LOG_ERR,
+				            "cannot execute %s",
+				            PATH_SSH_AGENT);
+			else
+				pam_ssh_log(LOG_ERR,
+				            "%s exited with status %d",
+				            PATH_SSH_AGENT,
+				            WEXITSTATUS(child_status));
+		return PAM_SESSION_ERR;
+	}
+
+	return PAM_SUCCESS;
+}
+
+static int
+read_write_agent_env(pam_handle_t *pamh,
+                     FILE *env_read,
+                     int env_write,
+                     char **agent_socket)
+{
+	char *agent_pid;		/* copy of agent PID */
+	char *env_end;			/* end of env */
+	char env_string[BUFSIZ];	/* environment string */
+	char *env_value;		/* envariable value */
+	int retval;			/* from calls */
+
+	while (fgets(env_string, sizeof env_string, env_read)) {
+
+		/* parse environment definitions */
+
+		if (env_write >= 0)
+			write(env_write, env_string, strlen(env_string));
+		if (!(env_value = strchr(env_string, '=')) ||
+		    !(env_end = strchr(env_value, ';')))
+			continue;
+		*env_end = '\0';
+
+		/* pass to the application */
+
+		if ((retval = pam_putenv(pamh, env_string)) != PAM_SUCCESS)
+			return retval;
+
+		*env_value++ = '\0';
+
+		/* save the agent socket so we can connect to it and add
+		   the keys as well as the PID so we can kill the agent on
+		   session close. */
+
+		agent_pid = NULL;
+		if (strcmp(&env_string[strlen(env_string) -
+		    strlen(ENV_SOCKET_SUFFIX)], ENV_SOCKET_SUFFIX) == 0 &&
+		    !(*agent_socket = strdup(env_value))) {
+			pam_ssh_log(LOG_CRIT, "out of memory");
+			return PAM_SERVICE_ERR;
+		} else if (strcmp(&env_string[strlen(env_string) -
+		    strlen(ENV_PID_SUFFIX)], ENV_PID_SUFFIX) == 0 &&
+		    (!(agent_pid = strdup(env_value)) ||
+		    (retval = pam_set_data(pamh, "ssh_agent_pid",
+		    agent_pid, ssh_cleanup)) != PAM_SUCCESS)) {
+			if (agent_pid)
+				free(agent_pid);
+			else {
+				pam_ssh_log(LOG_CRIT, "out of memory");
+				return PAM_SERVICE_ERR;
+			}
+			if (agent_socket)
+				free(agent_socket);
+			return retval;
+		}
+
+	}
+
+	return PAM_SUCCESS;
+}
+
 
 PAM_EXTERN int
 pam_sm_authenticate(pam_handle_t *pamh, int flags __unused, int argc,
