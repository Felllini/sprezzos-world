Index: python2.6-2.6.8/Lib/bsddb/__init__.py
===================================================================
--- python2.6-2.6.8.orig/Lib/bsddb/__init__.py
+++ python2.6-2.6.8/Lib/bsddb/__init__.py
@@ -33,7 +33,7 @@
 #----------------------------------------------------------------------
 
 
-"""Support for Berkeley DB 4.0 through 4.7 with a simple interface.
+"""Support for Berkeley DB 4.2 through 5.1 with a simple interface.
 
 For the full featured object oriented interface use the bsddb.db module
 instead.  It mirrors the Oracle Berkeley DB C API.
@@ -42,11 +42,14 @@ instead.  It mirrors the Oracle Berkeley
 import sys
 absolute_import = (sys.version_info[0] >= 3)
 
-if sys.py3kwarning:
+if (sys.version_info >= (2, 6)) and (sys.version_info < (3, 0)) :
     import warnings
-    warnings.warnpy3k("in 3.x, the bsddb module has been removed; "
-                      "please use the pybsddb project instead",
-                      DeprecationWarning, 2)
+    if sys.py3kwarning and (__name__ != 'bsddb3') :
+        warnings.warnpy3k("in 3.x, the bsddb module has been removed; "
+                          "please use the pybsddb project instead",
+                          DeprecationWarning, 2)
+    warnings.filterwarnings("ignore", ".*CObject.*", DeprecationWarning,
+                            "bsddb.__init__")
 
 try:
     if __name__ == 'bsddb3':
@@ -81,7 +84,7 @@ import sys, os
 
 from weakref import ref
 
-if sys.version_info[0:2] <= (2, 5) :
+if sys.version_info < (2, 6) :
     import UserDict
     MutableMapping = UserDict.DictMixin
 else :
@@ -256,7 +259,7 @@ class _DBWithCursor(_iter_mixin):
         self._checkOpen()
         return _DeadlockWrap(lambda: len(self.db))  # len(self.db)
 
-    if sys.version_info[0:2] >= (2, 6) :
+    if sys.version_info >= (2, 6) :
         def __repr__(self) :
             if self.isOpen() :
                 return repr(dict(_DeadlockWrap(self.db.items)))
@@ -442,8 +445,10 @@ def _checkflag(flag, file):
 # Berkeley DB was too.
 
 try:
-    import thread
-    del thread
+    # 2to3 automatically changes "import thread" to "import _thread"
+    import thread as T
+    del T
+
 except ImportError:
     db.DB_THREAD = 0
 
Index: python2.6-2.6.8/setup.py
===================================================================
--- python2.6-2.6.8.orig/setup.py
+++ python2.6-2.6.8/setup.py
@@ -786,7 +786,7 @@ class PyBuildExt(build_ext):
         # a release.  Most open source OSes come with one or more
         # versions of BerkeleyDB already installed.
 
-        max_db_ver = (4, 8)
+        max_db_ver = (5, 1)
         min_db_ver = (3, 3)
         db_setup_debug = False   # verbose debug prints from this script?
 
@@ -808,7 +808,11 @@ class PyBuildExt(build_ext):
             return True
 
         def gen_db_minor_ver_nums(major):
-            if major == 4:
+            if major == 5:
+                for x in range(max_db_ver[1]+1):
+                    if allow_db_ver((5, x)):
+                        yield x
+            elif major == 4:
                 for x in range(max_db_ver[1]+1):
                     if allow_db_ver((4, x)):
                         yield x
Index: python2.6-2.6.8/Lib/bsddb/dbobj.py
===================================================================
--- python2.6-2.6.8.orig/Lib/bsddb/dbobj.py
+++ python2.6-2.6.8/Lib/bsddb/dbobj.py
@@ -29,7 +29,7 @@ if absolute_import :
 else :
     import db
 
-if sys.version_info[0:2] <= (2, 5) :
+if sys.version_info < (2, 6) :
     try:
         from UserDict import DictMixin
     except ImportError:
@@ -110,15 +110,17 @@ class DBEnv:
     def log_stat(self, *args, **kwargs):
         return self._cobj.log_stat(*args, **kwargs)
 
-    if db.version() >= (4,1):
-        def dbremove(self, *args, **kwargs):
-            return self._cobj.dbremove(*args, **kwargs)
-        def dbrename(self, *args, **kwargs):
-            return self._cobj.dbrename(*args, **kwargs)
-        def set_encrypt(self, *args, **kwargs):
-            return self._cobj.set_encrypt(*args, **kwargs)
+    def dbremove(self, *args, **kwargs):
+        return self._cobj.dbremove(*args, **kwargs)
+    def dbrename(self, *args, **kwargs):
+        return self._cobj.dbrename(*args, **kwargs)
+    def set_encrypt(self, *args, **kwargs):
+        return self._cobj.set_encrypt(*args, **kwargs)
 
     if db.version() >= (4,4):
+        def fileid_reset(self, *args, **kwargs):
+            return self._cobj.fileid_reset(*args, **kwargs)
+
         def lsn_reset(self, *args, **kwargs):
             return self._cobj.lsn_reset(*args, **kwargs)
 
@@ -138,7 +140,7 @@ class DB(MutableMapping):
     def __delitem__(self, arg):
         del self._cobj[arg]
 
-    if sys.version_info[0:2] >= (2, 6) :
+    if sys.version_info >= (2, 6) :
         def __iter__(self) :
             return self._cobj.__iter__()
 
@@ -229,9 +231,8 @@ class DB(MutableMapping):
     def set_get_returns_none(self, *args, **kwargs):
         return self._cobj.set_get_returns_none(*args, **kwargs)
 
-    if db.version() >= (4,1):
-        def set_encrypt(self, *args, **kwargs):
-            return self._cobj.set_encrypt(*args, **kwargs)
+    def set_encrypt(self, *args, **kwargs):
+        return self._cobj.set_encrypt(*args, **kwargs)
 
 
 class DBSequence:
Index: python2.6-2.6.8/Lib/bsddb/dbshelve.py
===================================================================
--- python2.6-2.6.8.orig/Lib/bsddb/dbshelve.py
+++ python2.6-2.6.8/Lib/bsddb/dbshelve.py
@@ -1,4 +1,4 @@
-#!/bin/env python
+#!/usr/bin/env python
 #------------------------------------------------------------------------
 #           Copyright (c) 1997-2001 by Total Control Software
 #                         All Rights Reserved
@@ -29,9 +29,6 @@ storage.
 
 #------------------------------------------------------------------------
 
-import cPickle
-import sys
-
 import sys
 absolute_import = (sys.version_info[0] >= 3)
 if absolute_import :
@@ -40,13 +37,41 @@ if absolute_import :
 else :
     import db
 
+if sys.version_info[0] >= 3 :
+    import cPickle  # Will be converted to "pickle" by "2to3"
+else :
+    if sys.version_info < (2, 6) :
+        import cPickle
+    else :
+        # When we drop support for python 2.3 and 2.4
+        # we could use: (in 2.5 we need a __future__ statement)
+        #
+        #    with warnings.catch_warnings():
+        #        warnings.filterwarnings(...)
+        #        ...
+        #
+        # We can not use "with" as is, because it would be invalid syntax
+        # in python 2.3, 2.4 and (with no __future__) 2.5.
+        # Here we simulate "with" following PEP 343 :
+        import warnings
+        w = warnings.catch_warnings()
+        w.__enter__()
+        try :
+            warnings.filterwarnings('ignore',
+                message='the cPickle module has been removed in Python 3.0',
+                category=DeprecationWarning)
+            import cPickle
+        finally :
+            w.__exit__()
+        del w
+
 #At version 2.3 cPickle switched to using protocol instead of bin
-if sys.version_info[:3] >= (2, 3, 0):
+if sys.version_info >= (2, 3):
     HIGHEST_PROTOCOL = cPickle.HIGHEST_PROTOCOL
 # In python 2.3.*, "cPickle.dumps" accepts no
 # named parameters. "pickle.dumps" accepts them,
 # so this seems a bug.
-    if sys.version_info[:3] < (2, 4, 0):
+    if sys.version_info < (2, 4):
         def _dumps(object, protocol):
             return cPickle.dumps(object, protocol)
     else :
@@ -59,11 +84,16 @@ else:
         return cPickle.dumps(object, bin=protocol)
 
 
-try:
-    from UserDict import DictMixin
-except ImportError:
-    # DictMixin is new in Python 2.3
-    class DictMixin: pass
+if sys.version_info < (2, 6) :
+    try:
+        from UserDict import DictMixin
+    except ImportError:
+        # DictMixin is new in Python 2.3
+        class DictMixin: pass
+    MutableMapping = DictMixin
+else :
+    import collections
+    MutableMapping = collections.MutableMapping
 
 #------------------------------------------------------------------------
 
@@ -106,7 +136,7 @@ def open(filename, flags=db.DB_CREATE, m
 class DBShelveError(db.DBError): pass
 
 
-class DBShelf(DictMixin):
+class DBShelf(MutableMapping):
     """A shelf to hold pickled objects, built upon a bsddb DB object.  It
     automatically pickles/unpickles data objects going to/from the DB.
     """
@@ -157,6 +187,17 @@ class DBShelf(DictMixin):
         else:
             return self.db.keys()
 
+    if sys.version_info >= (2, 6) :
+        def __iter__(self) :  # XXX: Load all keys in memory :-(
+            for k in self.db.keys() :
+                yield k
+
+        # Do this when "DB"  support iteration
+        # Or is it enough to pass thru "getattr"?
+        #
+        # def __iter__(self) :
+        #    return self.db.__iter__()
+
 
     def open(self, *args, **kwargs):
         self.db.open(*args, **kwargs)
Index: python2.6-2.6.8/Lib/bsddb/dbtables.py
===================================================================
--- python2.6-2.6.8.orig/Lib/bsddb/dbtables.py
+++ python2.6-2.6.8/Lib/bsddb/dbtables.py
@@ -22,7 +22,35 @@ import sys
 import copy
 import random
 import struct
-import cPickle as pickle
+
+
+if sys.version_info[0] >= 3 :
+    import pickle
+else :
+    if sys.version_info < (2, 6) :
+        import cPickle as pickle
+    else :
+        # When we drop support for python 2.3 and 2.4
+        # we could use: (in 2.5 we need a __future__ statement)
+        #
+        #    with warnings.catch_warnings():
+        #        warnings.filterwarnings(...)
+        #        ...
+        #
+        # We can not use "with" as is, because it would be invalid syntax
+        # in python 2.3, 2.4 and (with no __future__) 2.5.
+        # Here we simulate "with" following PEP 343 :
+        import warnings
+        w = warnings.catch_warnings()
+        w.__enter__()
+        try :
+            warnings.filterwarnings('ignore',
+                message='the cPickle module has been removed in Python 3.0',
+                category=DeprecationWarning)
+            import cPickle as pickle
+        finally :
+            w.__exit__()
+        del w
 
 try:
     # For Pythons w/distutils pybsddb
@@ -31,12 +59,6 @@ except ImportError:
     # For Python 2.3
     from bsddb import db
 
-# XXX(nnorwitz): is this correct? DBIncompleteError is conditional in _bsddb.c
-if not hasattr(db,"DBIncompleteError") :
-    class DBIncompleteError(Exception):
-        pass
-    db.DBIncompleteError = DBIncompleteError
-
 class TableDBError(StandardError):
     pass
 class TableAlreadyExists(TableDBError):
@@ -261,16 +283,10 @@ class bsdTableDB :
             self.env = None
 
     def checkpoint(self, mins=0):
-        try:
-            self.env.txn_checkpoint(mins)
-        except db.DBIncompleteError:
-            pass
+        self.env.txn_checkpoint(mins)
 
     def sync(self):
-        try:
-            self.db.sync()
-        except db.DBIncompleteError:
-            pass
+        self.db.sync()
 
     def _db_print(self) :
         """Print the database to stdout for debugging"""
@@ -398,7 +414,7 @@ class bsdTableDB :
                 # column names
                 newcolumnlist = copy.copy(oldcolumnlist)
                 for c in columns:
-                    if c not in oldcolumnhash:
+                    if not c in oldcolumnhash:
                         newcolumnlist.append(c)
 
                 # store the table's new extended column list
@@ -615,7 +631,7 @@ class bsdTableDB :
           argument and returning a boolean.
         """
         try:
-            if table not in self.__tablecolumns:
+            if not table in self.__tablecolumns:
                 self.__load_column_info(table)
             if columns is None:
                 columns = self.__tablecolumns[table]
@@ -659,6 +675,13 @@ class bsdTableDB :
             a = atuple[1]
             b = btuple[1]
             if type(a) is type(b):
+
+                # Needed for python 3. "cmp" vanished in 3.0.1
+                def cmp(a, b) :
+                    if a==b : return 0
+                    if a<b : return -1
+                    return 1
+
                 if isinstance(a, PrefixCond) and isinstance(b, PrefixCond):
                     # longest prefix first
                     return cmp(len(b.prefix), len(a.prefix))
Index: python2.6-2.6.8/Lib/bsddb/test/test_all.py
===================================================================
--- python2.6-2.6.8.orig/Lib/bsddb/test/test_all.py
+++ python2.6-2.6.8/Lib/bsddb/test/test_all.py
@@ -15,6 +15,51 @@ except ImportError:
 if sys.version_info[0] >= 3 :
     charset = "iso8859-1"  # Full 8 bit
 
+    class logcursor_py3k(object) :
+        def __init__(self, env) :
+            self._logcursor = env.log_cursor()
+
+        def __getattr__(self, v) :
+            return getattr(self._logcursor, v)
+
+        def __next__(self) :
+            v = getattr(self._logcursor, "next")()
+            if v is not None :
+                v = (v[0], v[1].decode(charset))
+            return v
+
+        next = __next__
+
+        def first(self) :
+            v = self._logcursor.first()
+            if v is not None :
+                v = (v[0], v[1].decode(charset))
+            return v
+
+        def last(self) :
+            v = self._logcursor.last()
+            if v is not None :
+                v = (v[0], v[1].decode(charset))
+            return v
+
+        def prev(self) :
+            v = self._logcursor.prev()
+            if v is not None :
+                v = (v[0], v[1].decode(charset))
+            return v
+
+        def current(self) :
+            v = self._logcursor.current()
+            if v is not None :
+                v = (v[0], v[1].decode(charset))
+            return v
+
+        def set(self, lsn) :
+            v = self._logcursor.set(lsn)
+            if v is not None :
+                v = (v[0], v[1].decode(charset))
+            return v
+
     class cursor_py3k(object) :
         def __init__(self, db, *args, **kwargs) :
             self._dbcursor = db.cursor(*args, **kwargs)
@@ -71,12 +116,12 @@ if sys.version_info[0] >= 3 :
             v = self._dbcursor.next_nodup()
             return self._fix(v)
 
-        def put(self, key, value, flags=0, dlen=-1, doff=-1) :
+        def put(self, key, data, flags=0, dlen=-1, doff=-1) :
             if isinstance(key, str) :
                 key = bytes(key, charset)
-            if isinstance(value, str) :
-                value = bytes(value, charset)
-            return self._dbcursor.put(key, value, flags=flags, dlen=dlen,
+            if isinstance(data, str) :
+                value = bytes(data, charset)
+            return self._dbcursor.put(key, data, flags=flags, dlen=dlen,
                     doff=doff)
 
         def current(self, flags=0, dlen=-1, doff=-1) :
@@ -203,12 +248,26 @@ if sys.version_info[0] >= 3 :
                 k = bytes(k, charset)
             return self._db.has_key(k, txn=txn)
 
-        def put(self, key, value, txn=None, flags=0, dlen=-1, doff=-1) :
+        def set_re_delim(self, c) :
+            if isinstance(c, str) :  # We can use a numeric value byte too
+                c = bytes(c, charset)
+            return self._db.set_re_delim(c)
+
+        def set_re_pad(self, c) :
+            if isinstance(c, str) :  # We can use a numeric value byte too
+                c = bytes(c, charset)
+            return self._db.set_re_pad(c)
+
+        def get_re_source(self) :
+            source = self._db.get_re_source()
+            return source.decode(charset)
+
+        def put(self, key, data, txn=None, flags=0, dlen=-1, doff=-1) :
             if isinstance(key, str) :
                 key = bytes(key, charset)
-            if isinstance(value, str) :
-                value = bytes(value, charset)
-            return self._db.put(key, value, flags=flags, txn=txn, dlen=dlen,
+            if isinstance(data, str) :
+                value = bytes(data, charset)
+            return self._db.put(key, data, flags=flags, txn=txn, dlen=dlen,
                     doff=doff)
 
         def append(self, value, txn=None) :
@@ -221,6 +280,11 @@ if sys.version_info[0] >= 3 :
                 key = bytes(key, charset)
             return self._db.get_size(key)
 
+        def exists(self, key, *args, **kwargs) :
+            if isinstance(key, str) :
+                key = bytes(key, charset)
+            return self._db.exists(key, *args, **kwargs)
+
         def get(self, key, default="MagicCookie", txn=None, flags=0, dlen=-1, doff=-1) :
             if isinstance(key, str) :
                 key = bytes(key, charset)
@@ -288,13 +352,21 @@ if sys.version_info[0] >= 3 :
                         key = key.decode(charset)
                     data = data.decode(charset)
                     key = self._callback(key, data)
-                    if (key != bsddb._db.DB_DONOTINDEX) and isinstance(key,
-                            str) :
-                        key = bytes(key, charset)
+                    if (key != bsddb._db.DB_DONOTINDEX) :
+                        if isinstance(key, str) :
+                            key = bytes(key, charset)
+                        elif isinstance(key, list) :
+                            key2 = []
+                            for i in key :
+                                if isinstance(i, str) :
+                                    i = bytes(i, charset)
+                                key2.append(i)
+                            key = key2
                     return key
 
             return self._db.associate(secondarydb._db,
-                    associate_callback(callback).callback, flags=flags, txn=txn)
+                    associate_callback(callback).callback, flags=flags,
+                    txn=txn)
 
         def cursor(self, txn=None, flags=0) :
             return cursor_py3k(self._db, txn=txn, flags=flags)
@@ -310,6 +382,21 @@ if sys.version_info[0] >= 3 :
         def __getattr__(self, v) :
             return getattr(self._dbenv, v)
 
+        def log_cursor(self, flags=0) :
+            return logcursor_py3k(self._dbenv)
+
+        def get_lg_dir(self) :
+            return self._dbenv.get_lg_dir().decode(charset)
+
+        def get_tmp_dir(self) :
+            return self._dbenv.get_tmp_dir().decode(charset)
+
+        def get_data_dirs(self) :
+            # Have to use a list comprehension and not
+            # generators, because we are supporting Python 2.3.
+            return tuple(
+                [i.decode(charset) for i in self._dbenv.get_data_dirs()])
+
     class DBSequence_py3k(object) :
         def __init__(self, db, *args, **kwargs) :
             self._db=db
@@ -332,7 +419,10 @@ if sys.version_info[0] >= 3 :
 
     bsddb._db.DBEnv_orig = bsddb._db.DBEnv
     bsddb._db.DB_orig = bsddb._db.DB
-    bsddb._db.DBSequence_orig = bsddb._db.DBSequence
+    if bsddb.db.version() <= (4, 3) :
+        bsddb._db.DBSequence_orig = None
+    else :
+        bsddb._db.DBSequence_orig = bsddb._db.DBSequence
 
     def do_proxy_db_py3k(flag) :
         flag2 = do_proxy_db_py3k.flag
@@ -394,10 +484,16 @@ def print_versions():
     print '-=' * 38
     print db.DB_VERSION_STRING
     print 'bsddb.db.version():   %s' % (db.version(), )
+    if db.version() >= (5, 0) :
+        print 'bsddb.db.full_version(): %s' %repr(db.full_version())
     print 'bsddb.db.__version__: %s' % db.__version__
     print 'bsddb.db.cvsid:       %s' % db.cvsid
-    print 'py module:            %s' % bsddb.__file__
-    print 'extension module:     %s' % bsddb._bsddb.__file__
+
+    # Workaround for allowing generating an EGGs as a ZIP files.
+    suffix="__"
+    print 'py module:            %s' % getattr(bsddb, "__file"+suffix)
+    print 'extension module:     %s' % getattr(bsddb, "__file"+suffix)
+
     print 'python version:       %s' % sys.version
     print 'My pid:               %s' % os.getpid()
     print '-=' * 38
@@ -434,7 +530,8 @@ def get_new_database_path() :
 
 # This path can be overriden via "set_test_path_prefix()".
 import os, os.path
-get_new_path.prefix=os.path.join(os.sep,"tmp","z-Berkeley_DB")
+get_new_path.prefix=os.path.join(os.environ.get("TMPDIR",
+    os.path.join(os.sep,"tmp")), "z-Berkeley_DB")
 get_new_path.num=0
 
 def get_test_path_prefix() :
@@ -481,6 +578,8 @@ def suite(module_prefix='', timing_check
     test_modules = [
         'test_associate',
         'test_basics',
+        'test_dbenv',
+        'test_db',
         'test_compare',
         'test_compat',
         'test_cursor_pget_bug',
@@ -489,6 +588,7 @@ def suite(module_prefix='', timing_check
         'test_dbtables',
         'test_distributed_transactions',
         'test_early_close',
+        'test_fileid',
         'test_get_none',
         'test_join',
         'test_lock',
Index: python2.6-2.6.8/Lib/bsddb/test/test_associate.py
===================================================================
--- python2.6-2.6.8.orig/Lib/bsddb/test/test_associate.py
+++ python2.6-2.6.8/Lib/bsddb/test/test_associate.py
@@ -76,6 +76,11 @@ musicdata = {
 #----------------------------------------------------------------------
 
 class AssociateErrorTestCase(unittest.TestCase):
+    import sys
+    if sys.version_info < (2, 4) :
+        def assertTrue(self, expr, msg=None):
+            self.failUnless(expr,msg=msg)
+
     def setUp(self):
         self.filename = self.__class__.__name__ + '.db'
         self.homeDir = get_new_environment_path()
@@ -120,6 +125,11 @@ class AssociateErrorTestCase(unittest.Te
 
 
 class AssociateTestCase(unittest.TestCase):
+    import sys
+    if sys.version_info < (2, 4) :
+        def assertTrue(self, expr, msg=None):
+            self.failUnless(expr,msg=msg)
+
     keytype = ''
     envFlags = 0
     dbFlags = 0
@@ -148,12 +158,8 @@ class AssociateTestCase(unittest.TestCas
         self.secDB = None
         self.primary = db.DB(self.env)
         self.primary.set_get_returns_none(2)
-        if db.version() >= (4, 1):
-            self.primary.open(self.filename, "primary", self.dbtype,
-                          db.DB_CREATE | db.DB_THREAD | self.dbFlags, txn=txn)
-        else:
-            self.primary.open(self.filename, "primary", self.dbtype,
-                          db.DB_CREATE | db.DB_THREAD | self.dbFlags)
+        self.primary.open(self.filename, "primary", self.dbtype,
+                      db.DB_CREATE | db.DB_THREAD | self.dbFlags, txn=txn)
 
     def closeDB(self):
         if self.cur:
@@ -169,12 +175,7 @@ class AssociateTestCase(unittest.TestCas
         return self.primary
 
 
-    def test01_associateWithDB(self):
-        if verbose:
-            print '\n', '-=' * 30
-            print "Running %s.test01_associateWithDB..." % \
-                  self.__class__.__name__
-
+    def _associateWithDB(self, getGenre):
         self.createDB()
 
         self.secDB = db.DB(self.env)
@@ -182,19 +183,21 @@ class AssociateTestCase(unittest.TestCas
         self.secDB.set_get_returns_none(2)
         self.secDB.open(self.filename, "secondary", db.DB_BTREE,
                    db.DB_CREATE | db.DB_THREAD | self.dbFlags)
-        self.getDB().associate(self.secDB, self.getGenre)
+        self.getDB().associate(self.secDB, getGenre)
 
         self.addDataToDB(self.getDB())
 
         self.finish_test(self.secDB)
 
-
-    def test02_associateAfterDB(self):
+    def test01_associateWithDB(self):
         if verbose:
             print '\n', '-=' * 30
-            print "Running %s.test02_associateAfterDB..." % \
+            print "Running %s.test01_associateWithDB..." % \
                   self.__class__.__name__
 
+        return self._associateWithDB(self.getGenre)
+
+    def _associateAfterDB(self, getGenre) :
         self.createDB()
         self.addDataToDB(self.getDB())
 
@@ -204,10 +207,35 @@ class AssociateTestCase(unittest.TestCas
                    db.DB_CREATE | db.DB_THREAD | self.dbFlags)
 
         # adding the DB_CREATE flag will cause it to index existing records
-        self.getDB().associate(self.secDB, self.getGenre, db.DB_CREATE)
+        self.getDB().associate(self.secDB, getGenre, db.DB_CREATE)
 
         self.finish_test(self.secDB)
 
+    def test02_associateAfterDB(self):
+        if verbose:
+            print '\n', '-=' * 30
+            print "Running %s.test02_associateAfterDB..." % \
+                  self.__class__.__name__
+
+        return self._associateAfterDB(self.getGenre)
+
+    if db.version() >= (4, 6):
+        def test03_associateWithDB(self):
+            if verbose:
+                print '\n', '-=' * 30
+                print "Running %s.test03_associateWithDB..." % \
+                      self.__class__.__name__
+
+            return self._associateWithDB(self.getGenreList)
+
+        def test04_associateAfterDB(self):
+            if verbose:
+                print '\n', '-=' * 30
+                print "Running %s.test04_associateAfterDB..." % \
+                      self.__class__.__name__
+
+            return self._associateAfterDB(self.getGenreList)
+
 
     def finish_test(self, secDB, txn=None):
         # 'Blues' should not be in the secondary database
@@ -215,7 +243,7 @@ class AssociateTestCase(unittest.TestCas
         self.assertEqual(vals, None, vals)
 
         vals = secDB.pget('Unknown', txn=txn)
-        self.assert_(vals[0] == 99 or vals[0] == '99', vals)
+        self.assertTrue(vals[0] == 99 or vals[0] == '99', vals)
         vals[1].index('Unknown')
         vals[1].index('Unnamed')
         vals[1].index('unknown')
@@ -227,9 +255,9 @@ class AssociateTestCase(unittest.TestCas
         rec = self.cur.first()
         while rec is not None:
             if type(self.keytype) == type(''):
-                self.assert_(int(rec[0]))  # for primary db, key is a number
+                self.assertTrue(int(rec[0]))  # for primary db, key is a number
             else:
-                self.assert_(rec[0] and type(rec[0]) == type(0))
+                self.assertTrue(rec[0] and type(rec[0]) == type(0))
             count = count + 1
             if verbose:
                 print rec
@@ -244,7 +272,7 @@ class AssociateTestCase(unittest.TestCas
 
         # test cursor pget
         vals = self.cur.pget('Unknown', flags=db.DB_LAST)
-        self.assert_(vals[1] == 99 or vals[1] == '99', vals)
+        self.assertTrue(vals[1] == 99 or vals[1] == '99', vals)
         self.assertEqual(vals[0], 'Unknown')
         vals[2].index('Unknown')
         vals[2].index('Unnamed')
@@ -277,6 +305,12 @@ class AssociateTestCase(unittest.TestCas
         else:
             return genre
 
+    def getGenreList(self, priKey, PriData) :
+        v = self.getGenre(priKey, PriData)
+        if type(v) == type("") :
+            v = [v]
+        return v
+
 
 #----------------------------------------------------------------------
 
@@ -322,10 +356,7 @@ class AssociateBTreeTxnTestCase(Associat
             self.secDB.set_get_returns_none(2)
             self.secDB.open(self.filename, "secondary", db.DB_BTREE,
                        db.DB_CREATE | db.DB_THREAD, txn=txn)
-            if db.version() >= (4,1):
-                self.getDB().associate(self.secDB, self.getGenre, txn=txn)
-            else:
-                self.getDB().associate(self.secDB, self.getGenre)
+            self.getDB().associate(self.secDB, self.getGenre, txn=txn)
 
             self.addDataToDB(self.getDB(), txn=txn)
         except:
@@ -426,8 +457,7 @@ def test_suite():
     suite.addTest(unittest.makeSuite(AssociateBTreeTestCase))
     suite.addTest(unittest.makeSuite(AssociateRecnoTestCase))
 
-    if db.version() >= (4, 1):
-        suite.addTest(unittest.makeSuite(AssociateBTreeTxnTestCase))
+    suite.addTest(unittest.makeSuite(AssociateBTreeTxnTestCase))
 
     suite.addTest(unittest.makeSuite(ShelveAssociateHashTestCase))
     suite.addTest(unittest.makeSuite(ShelveAssociateBTreeTestCase))
Index: python2.6-2.6.8/Lib/bsddb/test/test_basics.py
===================================================================
--- python2.6-2.6.8.orig/Lib/bsddb/test/test_basics.py
+++ python2.6-2.6.8/Lib/bsddb/test/test_basics.py
@@ -33,6 +33,7 @@ class VersionTestCase(unittest.TestCase)
 
 class BasicTestCase(unittest.TestCase):
     dbtype       = db.DB_UNKNOWN  # must be set in derived class
+    cachesize    = (0, 1024*1024, 1)
     dbopenflags  = 0
     dbsetflags   = 0
     dbmode       = 0660
@@ -43,6 +44,13 @@ class BasicTestCase(unittest.TestCase):
 
     _numKeys      = 1002    # PRIVATE.  NOTE: must be an even value
 
+    import sys
+    if sys.version_info < (2, 4):
+        def assertTrue(self, expr, msg=None):
+            self.failUnless(expr,msg=msg)
+        def assertFalse(self, expr, msg=None):
+            self.failIf(expr,msg=msg)
+
     def setUp(self):
         if self.useEnv:
             self.homeDir=get_new_environment_path()
@@ -50,7 +58,8 @@ class BasicTestCase(unittest.TestCase):
                 self.env = db.DBEnv()
                 self.env.set_lg_max(1024*1024)
                 self.env.set_tx_max(30)
-                self.env.set_tx_timestamp(int(time.time()))
+                self._t = int(time.time())
+                self.env.set_tx_timestamp(self._t)
                 self.env.set_flags(self.envsetflags, 1)
                 self.env.open(self.homeDir, self.envflags | db.DB_CREATE)
                 self.filename = "test"
@@ -64,6 +73,14 @@ class BasicTestCase(unittest.TestCase):
 
         # create and open the DB
         self.d = db.DB(self.env)
+        if not self.useEnv :
+                self.d.set_cachesize(*self.cachesize)
+                cachesize = self.d.get_cachesize()
+                self.assertEqual(cachesize[0], self.cachesize[0])
+                self.assertEqual(cachesize[2], self.cachesize[2])
+                # Berkeley DB expands the cache 25% accounting overhead,
+                # if the cache is small.
+                self.assertEqual(125, int(100.0*cachesize[1]/self.cachesize[1]))
         self.d.set_flags(self.dbsetflags)
         if self.dbname:
             self.d.open(self.filename, self.dbname, self.dbtype,
@@ -74,6 +91,10 @@ class BasicTestCase(unittest.TestCase):
                         dbtype = self.dbtype,
                         flags = self.dbopenflags|db.DB_CREATE)
 
+        if not self.useEnv:
+            self.assertRaises(db.DBInvalidArgError,
+                    self.d.set_cachesize, *self.cachesize)
+
         self.populateDB()
 
 
@@ -139,7 +160,11 @@ class BasicTestCase(unittest.TestCase):
         try:
             d.delete('abcd')
         except db.DBNotFoundError, val:
-            self.assertEqual(val.args[0], db.DB_NOTFOUND)
+            import sys
+            if sys.version_info < (2, 6) :
+                self.assertEqual(val[0], db.DB_NOTFOUND)
+            else :
+                self.assertEqual(val.args[0], db.DB_NOTFOUND)
             if verbose: print val
         else:
             self.fail("expected exception")
@@ -158,7 +183,11 @@ class BasicTestCase(unittest.TestCase):
         try:
             d.put('abcd', 'this should fail', flags=db.DB_NOOVERWRITE)
         except db.DBKeyExistError, val:
-            self.assertEqual(val.args[0], db.DB_KEYEXIST)
+            import sys
+            if sys.version_info < (2, 6) :
+                self.assertEqual(val[0], db.DB_KEYEXIST)
+            else :
+                self.assertEqual(val.args[0], db.DB_KEYEXIST)
             if verbose: print val
         else:
             self.fail("expected exception")
@@ -268,6 +297,21 @@ class BasicTestCase(unittest.TestCase):
             pprint(values[:10])
 
 
+    #----------------------------------------
+
+    def test02b_SequenceMethods(self):
+        d = self.d
+
+        for key in ['0002', '0101', '0401', '0701', '0998']:
+            data = d[key]
+            self.assertEqual(data, self.makeData(key))
+            if verbose:
+                print data
+
+        self.assertTrue(hasattr(d, "__contains__"))
+        self.assertTrue("0401" in d)
+        self.assertFalse("1234" in d)
+
 
     #----------------------------------------
 
@@ -293,7 +337,11 @@ class BasicTestCase(unittest.TestCase):
                 rec = c.next()
             except db.DBNotFoundError, val:
                 if get_raises_error:
-                    self.assertEqual(val.args[0], db.DB_NOTFOUND)
+                    import sys
+                    if sys.version_info < (2, 6) :
+                        self.assertEqual(val[0], db.DB_NOTFOUND)
+                    else :
+                        self.assertEqual(val.args[0], db.DB_NOTFOUND)
                     if verbose: print val
                     rec = None
                 else:
@@ -314,7 +362,11 @@ class BasicTestCase(unittest.TestCase):
                 rec = c.prev()
             except db.DBNotFoundError, val:
                 if get_raises_error:
-                    self.assertEqual(val.args[0], db.DB_NOTFOUND)
+                    import sys
+                    if sys.version_info < (2, 6) :
+                        self.assertEqual(val[0], db.DB_NOTFOUND)
+                    else :
+                        self.assertEqual(val.args[0], db.DB_NOTFOUND)
                     if verbose: print val
                     rec = None
                 else:
@@ -337,7 +389,11 @@ class BasicTestCase(unittest.TestCase):
         try:
             n = c.set('bad key')
         except db.DBNotFoundError, val:
-            self.assertEqual(val.args[0], db.DB_NOTFOUND)
+            import sys
+            if sys.version_info < (2, 6) :
+                self.assertEqual(val[0], db.DB_NOTFOUND)
+            else :
+                self.assertEqual(val.args[0], db.DB_NOTFOUND)
             if verbose: print val
         else:
             if set_raises_error:
@@ -351,7 +407,11 @@ class BasicTestCase(unittest.TestCase):
         try:
             n = c.get_both('0404', 'bad data')
         except db.DBNotFoundError, val:
-            self.assertEqual(val.args[0], db.DB_NOTFOUND)
+            import sys
+            if sys.version_info < (2, 6) :
+                self.assertEqual(val[0], db.DB_NOTFOUND)
+            else :
+                self.assertEqual(val.args[0], db.DB_NOTFOUND)
             if verbose: print val
         else:
             if get_raises_error:
@@ -380,7 +440,11 @@ class BasicTestCase(unittest.TestCase):
             rec = c.current()
         except db.DBKeyEmptyError, val:
             if get_raises_error:
-                self.assertEqual(val.args[0], db.DB_KEYEMPTY)
+                import sys
+                if sys.version_info < (2, 6) :
+                    self.assertEqual(val[0], db.DB_KEYEMPTY)
+                else :
+                    self.assertEqual(val.args[0], db.DB_KEYEMPTY)
                 if verbose: print val
             else:
                 self.fail("unexpected DBKeyEmptyError")
@@ -425,7 +489,11 @@ class BasicTestCase(unittest.TestCase):
                 # a bug may cause a NULL pointer dereference...
                 getattr(c, method)(*args)
             except db.DBError, val:
-                self.assertEqual(val.args[0], 0)
+                import sys
+                if sys.version_info < (2, 6) :
+                    self.assertEqual(val[0], 0)
+                else :
+                    self.assertEqual(val.args[0], 0)
                 if verbose: print val
             else:
                 self.fail("no exception raised when using a buggy cursor's"
@@ -477,6 +545,15 @@ class BasicTestCase(unittest.TestCase):
         self.assertEqual(old, 1)
         self.test03_SimpleCursorStuff(get_raises_error=0, set_raises_error=0)
 
+    if db.version() >= (4, 6):
+        def test03d_SimpleCursorPriority(self) :
+            c = self.d.cursor()
+            c.set_priority(db.DB_PRIORITY_VERY_LOW)  # Positional
+            self.assertEqual(db.DB_PRIORITY_VERY_LOW, c.get_priority())
+            c.set_priority(priority=db.DB_PRIORITY_HIGH)  # Keyword
+            self.assertEqual(db.DB_PRIORITY_HIGH, c.get_priority())
+            c.close()
+
     #----------------------------------------
 
     def test04_PartialGetAndPut(self):
@@ -530,11 +607,11 @@ class BasicTestCase(unittest.TestCase):
         d = self.d
         if verbose:
             print '\n', '-=' * 30
-            print "Running %s.test99_Truncate..." % self.__class__.__name__
+            print "Running %s.test06_Truncate..." % self.__class__.__name__
 
         d.put("abcde", "ABCDE");
         num = d.truncate()
-        self.assert_(num >= 1, "truncate returned <= 0 on non-empty database")
+        self.assertTrue(num >= 1, "truncate returned <= 0 on non-empty database")
         num = d.truncate()
         self.assertEqual(num, 0,
                 "truncate on empty DB returned nonzero (%r)" % (num,))
@@ -550,6 +627,33 @@ class BasicTestCase(unittest.TestCase):
 
     #----------------------------------------
 
+    if db.version() >= (4, 6):
+        def test08_exists(self) :
+            self.d.put("abcde", "ABCDE")
+            self.assertTrue(self.d.exists("abcde") == True,
+                    "DB->exists() returns wrong value")
+            self.assertTrue(self.d.exists("x") == False,
+                    "DB->exists() returns wrong value")
+
+    #----------------------------------------
+
+    if db.version() >= (4, 7):
+        def test_compact(self) :
+            d = self.d
+            self.assertEqual(0, d.compact(flags=db.DB_FREELIST_ONLY))
+            self.assertEqual(0, d.compact(flags=db.DB_FREELIST_ONLY))
+            d.put("abcde", "ABCDE");
+            d.put("bcde", "BCDE");
+            d.put("abc", "ABC");
+            d.put("monty", "python");
+            d.delete("abc")
+            d.delete("bcde")
+            d.compact(start='abcde', stop='monty', txn=None,
+                    compact_fillpercent=42, compact_pages=1,
+                    compact_timeout=50000000,
+                    flags=db.DB_FREELIST_ONLY|db.DB_FREE_SPACE)
+
+    #----------------------------------------
 
 #----------------------------------------------------------------------
 
@@ -579,13 +683,13 @@ class BasicWithEnvTestCase(BasicTestCase
 
     #----------------------------------------
 
-    def test08_EnvRemoveAndRename(self):
+    def test09_EnvRemoveAndRename(self):
         if not self.env:
             return
 
         if verbose:
             print '\n', '-=' * 30
-            print "Running %s.test08_EnvRemoveAndRename..." % self.__class__.__name__
+            print "Running %s.test09_EnvRemoveAndRename..." % self.__class__.__name__
 
         # can't rename or remove an open DB
         self.d.close()
@@ -594,10 +698,6 @@ class BasicWithEnvTestCase(BasicTestCase
         self.env.dbrename(self.filename, None, newname)
         self.env.dbremove(newname)
 
-    # dbremove and dbrename are in 4.1 and later
-    if db.version() < (4,1):
-        del test08_EnvRemoveAndRename
-
     #----------------------------------------
 
 class BasicBTreeWithEnvTestCase(BasicWithEnvTestCase):
@@ -612,9 +712,14 @@ class BasicHashWithEnvTestCase(BasicWith
 
 class BasicTransactionTestCase(BasicTestCase):
     import sys
-    if sys.version_info[:3] < (2, 4, 0):
+    if sys.version_info < (2, 4):
         def assertTrue(self, expr, msg=None):
-            self.failUnless(expr,msg=msg)
+            return self.failUnless(expr,msg=msg)
+
+    if (sys.version_info < (2, 7)) or ((sys.version_info >= (3, 0)) and
+            (sys.version_info < (3, 2))) :
+        def assertIn(self, a, b, msg=None) :
+            return self.assertTrue(a in b, msg=msg)
 
     dbopenflags = db.DB_THREAD | db.DB_AUTO_COMMIT
     useEnv = 1
@@ -672,16 +777,13 @@ class BasicTransactionTestCase(BasicTest
         self.txn.commit()
 
         # flush pending updates
-        try:
-            self.env.txn_checkpoint (0, 0, 0)
-        except db.DBIncompleteError:
-            pass
+        self.env.txn_checkpoint (0, 0, 0)
 
         statDict = self.env.log_stat(0);
-        self.assertTrue('magic' in statDict)
-        self.assertTrue('version' in statDict)
-        self.assertTrue('cur_file' in statDict)
-        self.assertTrue('region_nowait' in statDict)
+        self.assertIn('magic', statDict)
+        self.assertIn('version', statDict)
+        self.assertIn('cur_file', statDict)
+        self.assertIn('region_nowait', statDict)
 
         # must have at least one log file present:
         logs = self.env.log_archive(db.DB_ARCH_ABS | db.DB_ARCH_LOG)
@@ -689,7 +791,6 @@ class BasicTransactionTestCase(BasicTest
         for log in logs:
             if verbose:
                 print 'log file: ' + log
-        if db.version() >= (4,2):
             logs = self.env.log_archive(db.DB_ARCH_REMOVE)
             self.assertTrue(not logs)
 
@@ -697,16 +798,30 @@ class BasicTransactionTestCase(BasicTest
 
     #----------------------------------------
 
-    def test08_TxnTruncate(self):
+    if db.version() >= (4, 6):
+        def test08_exists(self) :
+            txn = self.env.txn_begin()
+            self.d.put("abcde", "ABCDE", txn=txn)
+            txn.commit()
+            txn = self.env.txn_begin()
+            self.assertTrue(self.d.exists("abcde", txn=txn) == True,
+                    "DB->exists() returns wrong value")
+            self.assertTrue(self.d.exists("x", txn=txn) == False,
+                    "DB->exists() returns wrong value")
+            txn.abort()
+
+    #----------------------------------------
+
+    def test09_TxnTruncate(self):
         d = self.d
         if verbose:
             print '\n', '-=' * 30
-            print "Running %s.test08_TxnTruncate..." % self.__class__.__name__
+            print "Running %s.test09_TxnTruncate..." % self.__class__.__name__
 
         d.put("abcde", "ABCDE");
         txn = self.env.txn_begin()
         num = d.truncate(txn)
-        self.assert_(num >= 1, "truncate returned <= 0 on non-empty database")
+        self.assertTrue(num >= 1, "truncate returned <= 0 on non-empty database")
         num = d.truncate(txn)
         self.assertEqual(num, 0,
                 "truncate on empty DB returned nonzero (%r)" % (num,))
@@ -714,7 +829,7 @@ class BasicTransactionTestCase(BasicTest
 
     #----------------------------------------
 
-    def test09_TxnLateUse(self):
+    def test10_TxnLateUse(self):
         txn = self.env.txn_begin()
         txn.abort()
         try:
@@ -734,6 +849,38 @@ class BasicTransactionTestCase(BasicTest
             raise RuntimeError, "DBTxn.commit() called after DB_TXN no longer valid w/o an exception"
 
 
+    #----------------------------------------
+
+
+    if db.version() >= (4, 4):
+        def test_txn_name(self) :
+            txn=self.env.txn_begin()
+            self.assertEqual(txn.get_name(), "")
+            txn.set_name("XXYY")
+            self.assertEqual(txn.get_name(), "XXYY")
+            txn.set_name("")
+            self.assertEqual(txn.get_name(), "")
+            txn.abort()
+
+    #----------------------------------------
+
+
+        def test_txn_set_timeout(self) :
+            txn=self.env.txn_begin()
+            txn.set_timeout(1234567, db.DB_SET_LOCK_TIMEOUT)
+            txn.set_timeout(2345678, flags=db.DB_SET_TXN_TIMEOUT)
+            txn.abort()
+
+    #----------------------------------------
+
+        def test_get_tx_max(self) :
+            self.assertEqual(self.env.get_tx_max(), 30)
+
+        def test_get_tx_timestamp(self) :
+            self.assertEqual(self.env.get_tx_timestamp(), self._t)
+
+
+
 class BTreeTransactionTestCase(BasicTransactionTestCase):
     dbtype = db.DB_BTREE
 
@@ -748,11 +895,11 @@ class BTreeRecnoTestCase(BasicTestCase):
     dbtype     = db.DB_BTREE
     dbsetflags = db.DB_RECNUM
 
-    def test08_RecnoInBTree(self):
+    def test09_RecnoInBTree(self):
         d = self.d
         if verbose:
             print '\n', '-=' * 30
-            print "Running %s.test08_RecnoInBTree..." % self.__class__.__name__
+            print "Running %s.test09_RecnoInBTree..." % self.__class__.__name__
 
         rec = d.get(200)
         self.assertEqual(type(rec), type(()))
@@ -782,11 +929,11 @@ class BTreeRecnoWithThreadFlagTestCase(B
 class BasicDUPTestCase(BasicTestCase):
     dbsetflags = db.DB_DUP
 
-    def test09_DuplicateKeys(self):
+    def test10_DuplicateKeys(self):
         d = self.d
         if verbose:
             print '\n', '-=' * 30
-            print "Running %s.test09_DuplicateKeys..." % \
+            print "Running %s.test10_DuplicateKeys..." % \
                   self.__class__.__name__
 
         d.put("dup0", "before")
@@ -855,11 +1002,11 @@ class BasicMultiDBTestCase(BasicTestCase
         else:
             return db.DB_BTREE
 
-    def test10_MultiDB(self):
+    def test11_MultiDB(self):
         d1 = self.d
         if verbose:
             print '\n', '-=' * 30
-            print "Running %s.test10_MultiDB..." % self.__class__.__name__
+            print "Running %s.test11_MultiDB..." % self.__class__.__name__
 
         d2 = db.DB(self.env)
         d2.open(self.filename, "second", self.dbtype,
@@ -949,7 +1096,7 @@ class HashMultiDBTestCase(BasicMultiDBTe
 
 class PrivateObject(unittest.TestCase) :
     import sys
-    if sys.version_info[:3] < (2, 4, 0):
+    if sys.version_info < (2, 4):
         def assertTrue(self, expr, msg=None):
             self.failUnless(expr,msg=msg)
 
@@ -992,7 +1139,7 @@ class DBPrivateObject(PrivateObject) :
 
 class CrashAndBurn(unittest.TestCase) :
     import sys
-    if sys.version_info[:3] < (2, 4, 0):
+    if sys.version_info < (2, 4):
         def assertTrue(self, expr, msg=None):
             self.failUnless(expr,msg=msg)
 
Index: python2.6-2.6.8/Lib/bsddb/test/test_compare.py
===================================================================
--- python2.6-2.6.8.orig/Lib/bsddb/test/test_compare.py
+++ python2.6-2.6.8/Lib/bsddb/test/test_compare.py
@@ -12,6 +12,12 @@ from test_all import db, dbshelve, test_
         get_new_environment_path, get_new_database_path
 
 
+# Needed for python 3. "cmp" vanished in 3.0.1
+def cmp(a, b) :
+    if a==b : return 0
+    if a<b : return -1
+    return 1
+
 lexical_cmp = cmp
 
 def lowercase_cmp(left, right):
@@ -26,12 +32,16 @@ _expected_lexical_test_data = ['', 'CCCP
 _expected_lowercase_test_data = ['', 'a', 'aaa', 'b', 'c', 'CC', 'cccce', 'ccccf', 'CCCP']
 
 class ComparatorTests (unittest.TestCase):
+    if sys.version_info < (2, 4) :
+        def assertTrue(self, expr, msg=None) :
+            return self.failUnless(expr,msg=msg)
+
     def comparator_test_helper (self, comparator, expected_data):
         data = expected_data[:]
 
         import sys
-        if sys.version_info[:3] < (2, 6, 0):
-            if sys.version_info[:3] < (2, 4, 0):
+        if sys.version_info < (2, 6) :
+            if sys.version_info < (2, 4) :
                 data.sort(comparator)
             else :
                 data.sort(cmp=comparator)
@@ -47,7 +57,7 @@ class ComparatorTests (unittest.TestCase
                     data2.append(i)
             data = data2
 
-        self.assertEqual (data, expected_data,
+        self.assertEqual(data, expected_data,
                          "comparator `%s' is not right: %s vs. %s"
                          % (comparator, expected_data, data))
     def test_lexical_comparator (self):
@@ -65,6 +75,15 @@ class AbstractBtreeKeyCompareTestCase (u
     env = None
     db = None
 
+    if sys.version_info < (2, 4) :
+        def assertTrue(self, expr, msg=None):
+            self.failUnless(expr,msg=msg)
+
+    if (sys.version_info < (2, 7)) or ((sys.version_info >= (3,0)) and
+            (sys.version_info < (3, 2))) :
+        def assertLess(self, a, b, msg=None) :
+            return self.assertTrue(a<b, msg=msg)
+
     def setUp (self):
         self.filename = self.__class__.__name__ + '.db'
         self.homeDir = get_new_environment_path()
@@ -115,14 +134,14 @@ class AbstractBtreeKeyCompareTestCase (u
             rec = curs.first ()
             while rec:
                 key, ignore = rec
-                self.assertTrue (index < len (expected),
+                self.assertLess(index, len (expected),
                                  "to many values returned from cursor")
-                self.assertEqual (expected[index], key,
+                self.assertEqual(expected[index], key,
                                  "expected value `%s' at %d but got `%s'"
                                  % (expected[index], index, key))
                 index = index + 1
                 rec = curs.next ()
-            self.assertEqual (index, len (expected),
+            self.assertEqual(index, len (expected),
                              "not enough values returned from cursor")
         finally:
             curs.close ()
@@ -193,7 +212,8 @@ class BtreeExceptionsTestCase (AbstractB
             errorOut = temp.getvalue()
             if not successRe.search(errorOut):
                 self.fail("unexpected stderr output:\n"+errorOut)
-        sys.exc_traceback = sys.last_traceback = None
+        if sys.version_info < (3, 0) :  # XXX: How to do this in Py3k ???
+            sys.exc_traceback = sys.last_traceback = None
 
     def _test_compare_function_exception (self):
         self.startTest ()
@@ -237,8 +257,8 @@ class BtreeExceptionsTestCase (AbstractB
         def my_compare (a, b):
             return 0
 
-        self.startTest ()
-        self.createDB (my_compare)
+        self.startTest()
+        self.createDB(my_compare)
         self.assertRaises (RuntimeError, self.db.set_bt_compare, my_compare)
 
 def test_suite ():
Index: python2.6-2.6.8/Lib/bsddb/test/test_compat.py
===================================================================
--- python2.6-2.6.8.orig/Lib/bsddb/test/test_compat.py
+++ python2.6-2.6.8/Lib/bsddb/test/test_compat.py
@@ -11,6 +11,11 @@ from test_all import db, hashopen, btope
 
 
 class CompatibilityTestCase(unittest.TestCase):
+    import sys
+    if sys.version_info < (2, 4) :
+        def assertTrue(self, expr, msg=None):
+            self.failUnless(expr,msg=msg)
+
     def setUp(self):
         self.filename = get_new_database_path()
 
@@ -119,7 +124,7 @@ class CompatibilityTestCase(unittest.Tes
             if verbose:
                 print rec
 
-        self.assert_(f.has_key('f'), 'Error, missing key!')
+        self.assertTrue(f.has_key('f'), 'Error, missing key!')
 
         # test that set_location() returns the next nearest key, value
         # on btree databases and raises KeyError on others.
Index: python2.6-2.6.8/Lib/bsddb/test/test_cursor_pget_bug.py
===================================================================
--- python2.6-2.6.8.orig/Lib/bsddb/test/test_cursor_pget_bug.py
+++ python2.6-2.6.8/Lib/bsddb/test/test_cursor_pget_bug.py
@@ -37,12 +37,12 @@ class pget_bugTestCase(unittest.TestCase
     def test_pget(self):
         cursor = self.secondary_db.cursor()
 
-        self.assertEquals(('eggs', 'salad', 'eggs'), cursor.pget(key='eggs', flags=db.DB_SET))
-        self.assertEquals(('eggs', 'omelet', 'eggs'), cursor.pget(db.DB_NEXT_DUP))
-        self.assertEquals(None, cursor.pget(db.DB_NEXT_DUP))
+        self.assertEqual(('eggs', 'salad', 'eggs'), cursor.pget(key='eggs', flags=db.DB_SET))
+        self.assertEqual(('eggs', 'omelet', 'eggs'), cursor.pget(db.DB_NEXT_DUP))
+        self.assertEqual(None, cursor.pget(db.DB_NEXT_DUP))
 
-        self.assertEquals(('ham', 'spam', 'ham'), cursor.pget('ham', 'spam', flags=db.DB_SET))
-        self.assertEquals(None, cursor.pget(db.DB_NEXT_DUP))
+        self.assertEqual(('ham', 'spam', 'ham'), cursor.pget('ham', 'spam', flags=db.DB_SET))
+        self.assertEqual(None, cursor.pget(db.DB_NEXT_DUP))
 
         cursor.close()
 
Index: python2.6-2.6.8/Lib/bsddb/test/test_dbshelve.py
===================================================================
--- python2.6-2.6.8.orig/Lib/bsddb/test/test_dbshelve.py
+++ python2.6-2.6.8/Lib/bsddb/test/test_dbshelve.py
@@ -2,10 +2,9 @@
 TestCases for checking dbShelve objects.
 """
 
-import os, string
+import os, string, sys
 import random
 import unittest
-import warnings
 
 
 from test_all import db, dbshelve, test_support, verbose, \
@@ -13,6 +12,11 @@ from test_all import db, dbshelve, test_
 
 
 
+if sys.version_info < (2, 4) :
+    from sets import Set as set
+
+
+
 #----------------------------------------------------------------------
 
 # We want the objects to be comparable so we can test dbshelve.values
@@ -29,8 +33,17 @@ class DataClass:
 
 
 class DBShelveTestCase(unittest.TestCase):
+    if sys.version_info < (2, 4):
+        def assertTrue(self, expr, msg=None):
+            return self.failUnless(expr,msg=msg)
+
+    if (sys.version_info < (2, 7)) or ((sys.version_info >= (3, 0)) and
+            (sys.version_info < (3, 2))) :
+        def assertIn(self, a, b, msg=None) :
+            return self.assertTrue(a in b, msg=msg)
+
+
     def setUp(self):
-        import sys
         if sys.version_info[0] >= 3 :
             from test_all import do_proxy_db_py3k
             self._flag_proxy_db_py3k = do_proxy_db_py3k(False)
@@ -38,7 +51,6 @@ class DBShelveTestCase(unittest.TestCase
         self.do_open()
 
     def tearDown(self):
-        import sys
         if sys.version_info[0] >= 3 :
             from test_all import do_proxy_db_py3k
             do_proxy_db_py3k(self._flag_proxy_db_py3k)
@@ -48,7 +60,6 @@ class DBShelveTestCase(unittest.TestCase
     def mk(self, key):
         """Turn key into an appropriate key type for this db"""
         # override in child class for RECNO
-        import sys
         if sys.version_info[0] < 3 :
             return key
         else :
@@ -118,11 +129,14 @@ class DBShelveTestCase(unittest.TestCase
 
         dbvalues = d.values()
         self.assertEqual(len(dbvalues), len(d.keys()))
-        with warnings.catch_warnings():
-            warnings.filterwarnings('ignore',
-                                    'comparing unequal types not supported',
-                                    DeprecationWarning)
-            self.assertEqual(sorted(values), sorted(dbvalues))
+        if sys.version_info < (2, 6) :
+            values.sort()
+            dbvalues.sort()
+            self.assertEqual(values, dbvalues)
+        else :  # XXX: Convert all to strings. Please, improve
+            values.sort(key=lambda x : str(x))
+            dbvalues.sort(key=lambda x : str(x))
+            self.assertEqual(repr(values), repr(dbvalues))
 
         items = d.items()
         self.assertEqual(len(items), len(values))
@@ -197,10 +211,21 @@ class DBShelveTestCase(unittest.TestCase
                           self.d.append, 'unit test was here')
 
 
+    def test04_iterable(self) :
+        self.populateDB(self.d)
+        d = self.d
+        keys = d.keys()
+        keyset = set(keys)
+        self.assertEqual(len(keyset), len(keys))
+
+        for key in d :
+            self.assertIn(key, keyset)
+            keyset.remove(key)
+        self.assertEqual(len(keyset), 0)
+
     def checkrec(self, key, value):
         # override this in a subclass if the key type is different
 
-        import sys
         if sys.version_info[0] >= 3 :
             if isinstance(key, bytes) :
                 key = key.decode("iso8859-1")  # 8 bits
@@ -219,7 +244,6 @@ class DBShelveTestCase(unittest.TestCase
             self.assertEqual(value, [x] * 10)
 
         elif key[0] == 'O':
-            import sys
             if sys.version_info[0] < 3 :
                 from types import InstanceType
                 self.assertEqual(type(value), InstanceType)
@@ -231,7 +255,7 @@ class DBShelveTestCase(unittest.TestCase
             self.assertEqual(value.L, [x] * 10)
 
         else:
-            self.assert_(0, 'Unknown key type, fix the test')
+            self.assertTrue(0, 'Unknown key type, fix the test')
 
 #----------------------------------------------------------------------
 
@@ -287,7 +311,6 @@ class BasicEnvShelveTestCase(DBShelveTes
         DBShelveTestCase.setUp(self)
 
     def tearDown(self):
-        import sys
         if sys.version_info[0] >= 3 :
             from test_all import do_proxy_db_py3k
             do_proxy_db_py3k(self._flag_proxy_db_py3k)
Index: python2.6-2.6.8/Lib/bsddb/test/test_dbtables.py
===================================================================
--- python2.6-2.6.8.orig/Lib/bsddb/test/test_dbtables.py
+++ python2.6-2.6.8/Lib/bsddb/test/test_dbtables.py
@@ -20,11 +20,15 @@
 #
 # $Id$
 
-import os, re
-try:
-    import cPickle
-    pickle = cPickle
-except ImportError:
+import os, re, sys
+
+if sys.version_info[0] < 3 :
+    try:
+        import cPickle
+        pickle = cPickle
+    except ImportError:
+        import pickle
+else :
     import pickle
 
 import unittest
@@ -34,6 +38,11 @@ from test_all import db, dbtables, test_
 #----------------------------------------------------------------------
 
 class TableDBTestCase(unittest.TestCase):
+    import sys
+    if sys.version_info < (2, 4) :
+        def assertTrue(self, expr, msg=None):
+            self.failUnless(expr,msg=msg)
+
     db_name = 'test-table.db'
 
     def setUp(self):
@@ -80,8 +89,8 @@ class TableDBTestCase(unittest.TestCase)
             colval = pickle.loads(values[0][colname])
         else :
             colval = pickle.loads(bytes(values[0][colname], "iso8859-1"))
-        self.assert_(colval > 3.141)
-        self.assert_(colval < 3.142)
+        self.assertTrue(colval > 3.141)
+        self.assertTrue(colval < 3.142)
 
 
     def test02(self):
Index: python2.6-2.6.8/Lib/bsddb/test/test_distributed_transactions.py
===================================================================
--- python2.6-2.6.8.orig/Lib/bsddb/test/test_distributed_transactions.py
+++ python2.6-2.6.8/Lib/bsddb/test/test_distributed_transactions.py
@@ -19,6 +19,11 @@ from test_all import verbose
 #----------------------------------------------------------------------
 
 class DBTxn_distributed(unittest.TestCase):
+    import sys
+    if sys.version_info < (2, 4) :
+        def assertTrue(self, expr, msg=None):
+            self.failUnless(expr,msg=msg)
+
     num_txns=1234
     nosync=True
     must_open_db=False
@@ -37,15 +42,11 @@ class DBTxn_distributed(unittest.TestCas
         self.db = db.DB(self.dbenv)
         self.db.set_re_len(db.DB_GID_SIZE)
         if must_open_db :
-            if db.version() > (4,1) :
                 txn=self.dbenv.txn_begin()
                 self.db.open(self.filename,
                         db.DB_QUEUE, db.DB_CREATE | db.DB_THREAD, 0666,
                         txn=txn)
                 txn.commit()
-            else :
-                self.db.open(self.filename,
-                        db.DB_QUEUE, db.DB_CREATE | db.DB_THREAD, 0666)
 
     def setUp(self) :
         self.homeDir = get_new_environment_path()
@@ -88,9 +89,9 @@ class DBTxn_distributed(unittest.TestCas
     # Get "to be recovered" transactions but
     # let them be garbage collected.
         recovered_txns=self.dbenv.txn_recover()
-        self.assertEquals(self.num_txns,len(recovered_txns))
+        self.assertEqual(self.num_txns,len(recovered_txns))
         for gid,txn in recovered_txns :
-            self.assert_(gid in txns)
+            self.assertTrue(gid in txns)
         del txn
         del recovered_txns
 
@@ -99,7 +100,7 @@ class DBTxn_distributed(unittest.TestCas
     # Get "to be recovered" transactions. Commit, abort and
     # discard them.
         recovered_txns=self.dbenv.txn_recover()
-        self.assertEquals(self.num_txns,len(recovered_txns))
+        self.assertEqual(self.num_txns,len(recovered_txns))
         discard_txns=set()
         committed_txns=set()
         state=0
@@ -122,7 +123,7 @@ class DBTxn_distributed(unittest.TestCas
     # Verify the discarded transactions are still
     # around, and dispose them.
         recovered_txns=self.dbenv.txn_recover()
-        self.assertEquals(len(discard_txns),len(recovered_txns))
+        self.assertEqual(len(discard_txns),len(recovered_txns))
         for gid,txn in recovered_txns :
             txn.abort()
         del txn
@@ -133,8 +134,8 @@ class DBTxn_distributed(unittest.TestCas
     # Be sure there are not pending transactions.
     # Check also database size.
         recovered_txns=self.dbenv.txn_recover()
-        self.assert_(len(recovered_txns)==0)
-        self.assertEquals(len(committed_txns),self.db.stat()["nkeys"])
+        self.assertTrue(len(recovered_txns)==0)
+        self.assertEqual(len(committed_txns),self.db.stat()["nkeys"])
 
 class DBTxn_distributedSYNC(DBTxn_distributed):
     nosync=False
Index: python2.6-2.6.8/Lib/bsddb/test/test_early_close.py
===================================================================
--- python2.6-2.6.8.orig/Lib/bsddb/test/test_early_close.py
+++ python2.6-2.6.8/Lib/bsddb/test/test_early_close.py
@@ -2,7 +2,7 @@
 is closed before its DB objects.
 """
 
-import os
+import os, sys
 import unittest
 
 from test_all import db, test_support, verbose, get_new_environment_path, get_new_database_path
@@ -155,22 +155,43 @@ class DBEnvClosedEarlyCrash(unittest.Tes
                 db.DB_INIT_LOG | db.DB_CREATE)
         d = db.DB(dbenv)
         txn = dbenv.txn_begin()
-        if db.version() < (4,1) :
-            d.open(self.filename, dbtype = db.DB_HASH, flags = db.DB_CREATE)
-        else :
-            d.open(self.filename, dbtype = db.DB_HASH, flags = db.DB_CREATE,
-                    txn=txn)
+        d.open(self.filename, dbtype = db.DB_HASH, flags = db.DB_CREATE,
+                txn=txn)
         d.put("XXX", "yyy", txn=txn)
         txn.commit()
         txn = dbenv.txn_begin()
         c1 = d.cursor(txn)
         c2 = c1.dup()
-        self.assertEquals(("XXX", "yyy"), c1.first())
-        import warnings
+        self.assertEqual(("XXX", "yyy"), c1.first())
+
         # Not interested in warnings about implicit close.
-        with warnings.catch_warnings():
+        import warnings
+        if sys.version_info < (2, 6) :
+            # Completely resetting the warning state is
+            # problematic with python >=2.6 with -3 (py3k warning),
+            # because some stdlib modules selectively ignores warnings.
             warnings.simplefilter("ignore")
             txn.commit()
+            warnings.resetwarnings()
+        else :
+            # When we drop support for python 2.3 and 2.4
+            # we could use: (in 2.5 we need a __future__ statement)
+            #
+            #    with warnings.catch_warnings():
+            #        warnings.simplefilter("ignore")
+            #        txn.commit()
+            #
+            # We can not use "with" as is, because it would be invalid syntax
+            # in python 2.3, 2.4 and (with no __future__) 2.5.
+            # Here we simulate "with" following PEP 343 :
+            w = warnings.catch_warnings()
+            w.__enter__()
+            try :
+                warnings.simplefilter("ignore")
+                txn.commit()
+            finally :
+                w.__exit__()
+
         self.assertRaises(db.DBCursorClosedError, c2.first)
 
     if db.version() > (4,3,0) :
Index: python2.6-2.6.8/Lib/bsddb/test/test_get_none.py
===================================================================
--- python2.6-2.6.8.orig/Lib/bsddb/test/test_get_none.py
+++ python2.6-2.6.8/Lib/bsddb/test/test_get_none.py
@@ -11,6 +11,11 @@ from test_all import db, verbose, get_ne
 #----------------------------------------------------------------------
 
 class GetReturnsNoneTestCase(unittest.TestCase):
+    import sys
+    if sys.version_info < (2, 4) :
+        def assertTrue(self, expr, msg=None):
+            self.failUnless(expr,msg=msg)
+
     def setUp(self):
         self.filename = get_new_database_path()
 
@@ -76,7 +81,7 @@ class GetReturnsNoneTestCase(unittest.Te
                 break
 
         self.assertNotEqual(rec, None)
-        self.assert_(exceptionHappened)
+        self.assertTrue(exceptionHappened)
         self.assertEqual(count, len(string.letters))
 
         c.close()
Index: python2.6-2.6.8/Lib/bsddb/test/test_join.py
===================================================================
--- python2.6-2.6.8.orig/Lib/bsddb/test/test_join.py
+++ python2.6-2.6.8/Lib/bsddb/test/test_join.py
@@ -30,6 +30,11 @@ ColorIndex = [
 ]
 
 class JoinTestCase(unittest.TestCase):
+    import sys
+    if sys.version_info < (2, 4) :
+        def assertTrue(self, expr, msg=None):
+            self.failUnless(expr,msg=msg)
+
     keytype = ''
 
     def setUp(self):
@@ -67,7 +72,7 @@ class JoinTestCase(unittest.TestCase):
             # Don't do the .set() in an assert, or you can get a bogus failure
             # when running python -O
             tmp = sCursor.set('red')
-            self.assert_(tmp)
+            self.assertTrue(tmp)
 
             # FIXME: jCursor doesn't properly hold a reference to its
             # cursors, if they are closed before jcursor is used it
Index: python2.6-2.6.8/Lib/bsddb/test/test_lock.py
===================================================================
--- python2.6-2.6.8.orig/Lib/bsddb/test/test_lock.py
+++ python2.6-2.6.8/Lib/bsddb/test/test_lock.py
@@ -20,7 +20,7 @@ if have_threads :
 
 class LockingTestCase(unittest.TestCase):
     import sys
-    if sys.version_info[:3] < (2, 4, 0):
+    if sys.version_info < (2, 4) :
         def assertTrue(self, expr, msg=None):
             self.failUnless(expr,msg=msg)
 
@@ -89,7 +89,17 @@ class LockingTestCase(unittest.TestCase)
         for t in threads:
             t.join()
 
-    def test03_lock_timeout(self):
+        def test03_lock_timeout(self):
+            self.env.set_timeout(0, db.DB_SET_LOCK_TIMEOUT)
+            self.assertEqual(self.env.get_timeout(db.DB_SET_LOCK_TIMEOUT), 0)
+            self.env.set_timeout(0, db.DB_SET_TXN_TIMEOUT)
+            self.assertEqual(self.env.get_timeout(db.DB_SET_TXN_TIMEOUT), 0)
+            self.env.set_timeout(123456, db.DB_SET_LOCK_TIMEOUT)
+            self.assertEqual(self.env.get_timeout(db.DB_SET_LOCK_TIMEOUT), 123456)
+            self.env.set_timeout(7890123, db.DB_SET_TXN_TIMEOUT)
+            self.assertEqual(self.env.get_timeout(db.DB_SET_TXN_TIMEOUT), 7890123)
+
+    def test04_lock_timeout2(self):
         self.env.set_timeout(0, db.DB_SET_LOCK_TIMEOUT)
         self.env.set_timeout(0, db.DB_SET_TXN_TIMEOUT)
         self.env.set_timeout(123456, db.DB_SET_LOCK_TIMEOUT)
@@ -124,6 +134,7 @@ class LockingTestCase(unittest.TestCase)
                 self.env.lock_get,anID2, "shared lock", db.DB_LOCK_READ)
         end_time=time.time()
         deadlock_detection.end=True
+        # Floating point rounding
         self.assertTrue((end_time-start_time) >= 0.0999)
         self.env.lock_put(lock)
         t.join()
Index: python2.6-2.6.8/Lib/bsddb/test/test_misc.py
===================================================================
--- python2.6-2.6.8.orig/Lib/bsddb/test/test_misc.py
+++ python2.6-2.6.8/Lib/bsddb/test/test_misc.py
@@ -1,7 +1,7 @@
 """Miscellaneous bsddb module test cases
 """
 
-import os
+import os, sys
 import unittest
 
 from test_all import db, dbshelve, hashopen, test_support, get_new_environment_path, get_new_database_path
@@ -9,6 +9,13 @@ from test_all import db, dbshelve, hasho
 #----------------------------------------------------------------------
 
 class MiscTestCase(unittest.TestCase):
+    if sys.version_info < (2, 4) :
+        def assertTrue(self, expr, msg=None):
+            self.failUnless(expr, msg=msg)
+
+        def assertFalse(self, expr, msg=None):
+            self.failIf(expr, msg=msg)
+
     def setUp(self):
         self.filename = get_new_database_path()
         self.homeDir = get_new_environment_path()
@@ -25,9 +32,8 @@ class MiscTestCase(unittest.TestCase):
     def test02_db_home(self):
         env = db.DBEnv()
         # check for crash fixed when db_home is used before open()
-        self.assert_(env.db_home is None)
+        self.assertTrue(env.db_home is None)
         env.open(self.homeDir, db.DB_CREATE)
-        import sys
         if sys.version_info[0] < 3 :
             self.assertEqual(self.homeDir, env.db_home)
         else :
@@ -37,7 +43,7 @@ class MiscTestCase(unittest.TestCase):
         db = hashopen(self.filename)
         db.close()
         rp = repr(db)
-        self.assertEquals(rp, "{}")
+        self.assertEqual(rp, "{}")
 
     def test04_repr_db(self) :
         db = hashopen(self.filename)
@@ -48,7 +54,7 @@ class MiscTestCase(unittest.TestCase):
         db.close()
         db = hashopen(self.filename)
         rp = repr(db)
-        self.assertEquals(rp, repr(d))
+        self.assertEqual(rp, repr(d))
         db.close()
 
     # http://sourceforge.net/tracker/index.php?func=detail&aid=1708868&group_id=13900&atid=313900
@@ -91,10 +97,6 @@ class MiscTestCase(unittest.TestCase):
             test_support.unlink(self.filename)
 
     def test07_DB_set_flags_persists(self):
-        if db.version() < (4,2):
-            # The get_flags API required for this to work is only available
-            # in Berkeley DB >= 4.2
-            return
         try:
             db1 = db.DB()
             db1.set_flags(db.DB_DUPSORT)
@@ -119,6 +121,19 @@ class MiscTestCase(unittest.TestCase):
             test_support.unlink(self.filename)
 
 
+    def test08_ExceptionTypes(self) :
+        self.assertTrue(issubclass(db.DBError, Exception))
+        for i, j in db.__dict__.items() :
+            if i.startswith("DB") and i.endswith("Error") :
+                self.assertTrue(issubclass(j, db.DBError), msg=i)
+                if i not in ("DBKeyEmptyError", "DBNotFoundError") :
+                    self.assertFalse(issubclass(j, KeyError), msg=i)
+
+        # This two exceptions have two bases
+        self.assertTrue(issubclass(db.DBKeyEmptyError, KeyError))
+        self.assertTrue(issubclass(db.DBNotFoundError, KeyError))
+
+
 #----------------------------------------------------------------------
 
 
Index: python2.6-2.6.8/Lib/bsddb/test/test_pickle.py
===================================================================
--- python2.6-2.6.8.orig/Lib/bsddb/test/test_pickle.py
+++ python2.6-2.6.8/Lib/bsddb/test/test_pickle.py
@@ -1,10 +1,16 @@
 
 import os
 import pickle
-try:
-    import cPickle
-except ImportError:
+import sys
+
+if sys.version_info[0] < 3 :
+    try:
+        import cPickle
+    except ImportError:
+        cPickle = None
+else :
     cPickle = None
+
 import unittest
 
 from test_all import db, test_support, get_new_environment_path, get_new_database_path
Index: python2.6-2.6.8/Lib/bsddb/test/test_recno.py
===================================================================
--- python2.6-2.6.8.orig/Lib/bsddb/test/test_recno.py
+++ python2.6-2.6.8/Lib/bsddb/test/test_recno.py
@@ -1,7 +1,7 @@
 """TestCases for exercising a Recno DB.
 """
 
-import os
+import os, sys
 import errno
 from pprint import pprint
 import unittest
@@ -14,10 +14,19 @@ letters = 'abcdefghijklmnopqrstuvwxyzABC
 #----------------------------------------------------------------------
 
 class SimpleRecnoTestCase(unittest.TestCase):
-    import sys
-    if sys.version_info[:3] < (2, 4, 0):
-        def assertFalse(self, expr, msg=None):
-            self.failIf(expr,msg=msg)
+    if sys.version_info < (2, 4) :
+        def assertFalse(self, expr, msg=None) :
+            return self.failIf(expr,msg=msg)
+        def assertTrue(self, expr, msg=None) :
+            return self.assertTrue(expr, msg=msg)
+
+    if (sys.version_info < (2, 7)) or ((sys.version_info >= (3, 0)) and
+            (sys.version_info < (3, 2))) :
+        def assertIsInstance(self, obj, datatype, msg=None) :
+            return self.assertEqual(type(obj), datatype, msg=msg)
+        def assertGreaterEqual(self, a, b, msg=None) :
+            return self.assertTrue(a>=b, msg=msg)
+
 
     def setUp(self):
         self.filename = get_new_database_path()
@@ -38,8 +47,8 @@ class SimpleRecnoTestCase(unittest.TestC
 
         for x in letters:
             recno = d.append(x * 60)
-            self.assertTrue(isinstance(recno, int))
-            self.assertTrue(recno >= 1)
+            self.assertIsInstance(recno, int)
+            self.assertGreaterEqual(recno, 1)
             if verbose:
                 print recno,
 
@@ -54,13 +63,16 @@ class SimpleRecnoTestCase(unittest.TestC
             if verbose:
                 print data
 
-            self.assertTrue(isinstance(data, str))
+            self.assertIsInstance(data, str)
             self.assertEqual(data, d.get(recno))
 
         try:
             data = d[0]  # This should raise a KeyError!?!?!
         except db.DBInvalidArgError, val:
-            self.assertEqual(val.args[0], db.EINVAL)
+            if sys.version_info < (2, 6) :
+                self.assertEqual(val[0], db.EINVAL)
+            else :
+                self.assertEqual(val.args[0], db.EINVAL)
             if verbose: print val
         else:
             self.fail("expected exception")
@@ -91,18 +103,18 @@ class SimpleRecnoTestCase(unittest.TestC
         keys = d.keys()
         if verbose:
             print keys
-        self.assertTrue(isinstance(keys, list))
-        self.assertTrue(isinstance(keys[0], int))
+        self.assertIsInstance(keys, list)
+        self.assertIsInstance(keys[0], int)
         self.assertEqual(len(keys), len(d))
 
         items = d.items()
         if verbose:
             pprint(items)
-        self.assertTrue(isinstance(items, list))
-        self.assertTrue(isinstance(items[0], tuple))
+        self.assertIsInstance(items, list)
+        self.assertIsInstance(items[0], tuple)
         self.assertEqual(len(items[0]), 2)
-        self.assertTrue(isinstance(items[0][0], int))
-        self.assertTrue(isinstance(items[0][1], str))
+        self.assertIsInstance(items[0][0], int)
+        self.assertIsInstance(items[0][1], str)
         self.assertEqual(len(items), len(d))
 
         self.assertTrue(d.has_key(25))
@@ -177,7 +189,10 @@ class SimpleRecnoTestCase(unittest.TestC
             if get_returns_none:
                 self.fail("unexpected DBKeyEmptyError exception")
             else:
-                self.assertEqual(val.args[0], db.DB_KEYEMPTY)
+                if sys.version_info < (2, 6) :
+                    self.assertEqual(val[0], db.DB_KEYEMPTY)
+                else :
+                    self.assertEqual(val.args[0], db.DB_KEYEMPTY)
                 if verbose: print val
         else:
             if not get_returns_none:
@@ -221,7 +236,9 @@ class SimpleRecnoTestCase(unittest.TestC
         d.close()
 
         # get the text from the backing source
-        text = open(source, 'r').read()
+        f = open(source, 'r')
+        text = f.read()
+        f.close()
         text = text.strip()
         if verbose:
             print text
@@ -241,7 +258,9 @@ class SimpleRecnoTestCase(unittest.TestC
         d.sync()
         d.close()
 
-        text = open(source, 'r').read()
+        f = open(source, 'r')
+        text = f.read()
+        f.close()
         text = text.strip()
         if verbose:
             print text
@@ -265,7 +284,10 @@ class SimpleRecnoTestCase(unittest.TestC
         try:                    # this one will fail
             d.append('bad' * 20)
         except db.DBInvalidArgError, val:
-            self.assertEqual(val.args[0], db.EINVAL)
+            if sys.version_info < (2, 6) :
+                self.assertEqual(val[0], db.EINVAL)
+            else :
+                self.assertEqual(val.args[0], db.EINVAL)
             if verbose: print val
         else:
             self.fail("expected exception")
@@ -280,6 +302,18 @@ class SimpleRecnoTestCase(unittest.TestC
         c.close()
         d.close()
 
+    def test04_get_size_empty(self) :
+        d = db.DB()
+        d.open(self.filename, dbtype=db.DB_RECNO, flags=db.DB_CREATE)
+
+        row_id = d.append(' ')
+        self.assertEqual(1, d.get_size(key=row_id))
+        row_id = d.append('')
+        self.assertEqual(0, d.get_size(key=row_id))
+
+
+
+
 
 #----------------------------------------------------------------------
 
Index: python2.6-2.6.8/Lib/bsddb/test/test_replication.py
===================================================================
--- python2.6-2.6.8.orig/Lib/bsddb/test/test_replication.py
+++ python2.6-2.6.8/Lib/bsddb/test/test_replication.py
@@ -4,7 +4,6 @@
 import os
 import time
 import unittest
-import weakref
 
 from test_all import db, test_support, have_threads, verbose, \
         get_new_environment_path, get_new_database_path
@@ -12,9 +11,9 @@ from test_all import db, test_support, h
 
 #----------------------------------------------------------------------
 
-class DBReplicationManager(unittest.TestCase):
+class DBReplication(unittest.TestCase) :
     import sys
-    if sys.version_info[:3] < (2, 4, 0):
+    if sys.version_info < (2, 4) :
         def assertTrue(self, expr, msg=None):
             self.failUnless(expr,msg=msg)
 
@@ -35,16 +34,13 @@ class DBReplicationManager(unittest.Test
                 | db.DB_INIT_LOG | db.DB_INIT_MPOOL | db.DB_INIT_LOCK |
                 db.DB_INIT_REP | db.DB_RECOVER | db.DB_THREAD, 0666)
 
-        wr = weakref.ref(self)
         self.confirmed_master=self.client_startupdone=False
         def confirmed_master(a,b,c) :
             if b==db.DB_EVENT_REP_MASTER :
-                self = wr()
                 self.confirmed_master=True
 
         def client_startupdone(a,b,c) :
             if b==db.DB_EVENT_REP_STARTUPDONE :
-                self = wr()
                 self.client_startupdone=True
 
         self.dbenvMaster.set_event_notify(confirmed_master)
@@ -63,11 +59,21 @@ class DBReplicationManager(unittest.Test
             self.dbClient.close()
         if self.dbMaster :
             self.dbMaster.close()
+
+        # Here we assign dummy event handlers to allow GC of the test object.
+        # Since the dummy handler doesn't use any outer scope variable, it
+        # doesn't keep any reference to the test object.
+        def dummy(*args) :
+            pass
+        self.dbenvMaster.set_event_notify(dummy)
+        self.dbenvClient.set_event_notify(dummy)
+
         self.dbenvClient.close()
         self.dbenvMaster.close()
         test_support.rmtree(self.homeDirClient)
         test_support.rmtree(self.homeDirMaster)
 
+class DBReplicationManager(DBReplication) :
     def test01_basic_replication(self) :
         master_port = test_support.find_unused_port()
         self.dbenvMaster.repmgr_set_local_site("127.0.0.1", master_port)
@@ -82,23 +88,23 @@ class DBReplicationManager(unittest.Test
 
         self.dbenvMaster.rep_set_timeout(db.DB_REP_CONNECTION_RETRY,100123)
         self.dbenvClient.rep_set_timeout(db.DB_REP_CONNECTION_RETRY,100321)
-        self.assertEquals(self.dbenvMaster.rep_get_timeout(
+        self.assertEqual(self.dbenvMaster.rep_get_timeout(
             db.DB_REP_CONNECTION_RETRY), 100123)
-        self.assertEquals(self.dbenvClient.rep_get_timeout(
+        self.assertEqual(self.dbenvClient.rep_get_timeout(
             db.DB_REP_CONNECTION_RETRY), 100321)
 
         self.dbenvMaster.rep_set_timeout(db.DB_REP_ELECTION_TIMEOUT, 100234)
         self.dbenvClient.rep_set_timeout(db.DB_REP_ELECTION_TIMEOUT, 100432)
-        self.assertEquals(self.dbenvMaster.rep_get_timeout(
+        self.assertEqual(self.dbenvMaster.rep_get_timeout(
             db.DB_REP_ELECTION_TIMEOUT), 100234)
-        self.assertEquals(self.dbenvClient.rep_get_timeout(
+        self.assertEqual(self.dbenvClient.rep_get_timeout(
             db.DB_REP_ELECTION_TIMEOUT), 100432)
 
         self.dbenvMaster.rep_set_timeout(db.DB_REP_ELECTION_RETRY, 100345)
         self.dbenvClient.rep_set_timeout(db.DB_REP_ELECTION_RETRY, 100543)
-        self.assertEquals(self.dbenvMaster.rep_get_timeout(
+        self.assertEqual(self.dbenvMaster.rep_get_timeout(
             db.DB_REP_ELECTION_RETRY), 100345)
-        self.assertEquals(self.dbenvClient.rep_get_timeout(
+        self.assertEqual(self.dbenvClient.rep_get_timeout(
             db.DB_REP_ELECTION_RETRY), 100543)
 
         self.dbenvMaster.repmgr_set_ack_policy(db.DB_REPMGR_ACKS_ALL)
@@ -107,13 +113,13 @@ class DBReplicationManager(unittest.Test
         self.dbenvMaster.repmgr_start(1, db.DB_REP_MASTER);
         self.dbenvClient.repmgr_start(1, db.DB_REP_CLIENT);
 
-        self.assertEquals(self.dbenvMaster.rep_get_nsites(),2)
-        self.assertEquals(self.dbenvClient.rep_get_nsites(),2)
-        self.assertEquals(self.dbenvMaster.rep_get_priority(),10)
-        self.assertEquals(self.dbenvClient.rep_get_priority(),0)
-        self.assertEquals(self.dbenvMaster.repmgr_get_ack_policy(),
+        self.assertEqual(self.dbenvMaster.rep_get_nsites(),2)
+        self.assertEqual(self.dbenvClient.rep_get_nsites(),2)
+        self.assertEqual(self.dbenvMaster.rep_get_priority(),10)
+        self.assertEqual(self.dbenvClient.rep_get_priority(),0)
+        self.assertEqual(self.dbenvMaster.repmgr_get_ack_policy(),
                 db.DB_REPMGR_ACKS_ALL)
-        self.assertEquals(self.dbenvClient.repmgr_get_ack_policy(),
+        self.assertEqual(self.dbenvClient.repmgr_get_ack_policy(),
                 db.DB_REPMGR_ACKS_ALL)
 
         # The timeout is necessary in BDB 4.5, since DB_EVENT_REP_STARTUPDONE
@@ -137,16 +143,16 @@ class DBReplicationManager(unittest.Test
             startup_timeout = True
 
         d = self.dbenvMaster.repmgr_site_list()
-        self.assertEquals(len(d), 1)
-        self.assertEquals(d[0][0], "127.0.0.1")
-        self.assertEquals(d[0][1], client_port)
+        self.assertEqual(len(d), 1)
+        self.assertEqual(d[0][0], "127.0.0.1")
+        self.assertEqual(d[0][1], client_port)
         self.assertTrue((d[0][2]==db.DB_REPMGR_CONNECTED) or \
                 (d[0][2]==db.DB_REPMGR_DISCONNECTED))
 
         d = self.dbenvClient.repmgr_site_list()
-        self.assertEquals(len(d), 1)
-        self.assertEquals(d[0][0], "127.0.0.1")
-        self.assertEquals(d[0][1], master_port)
+        self.assertEqual(len(d), 1)
+        self.assertEqual(d[0][0], "127.0.0.1")
+        self.assertEqual(d[0][1], master_port)
         self.assertTrue((d[0][2]==db.DB_REPMGR_CONNECTED) or \
                 (d[0][2]==db.DB_REPMGR_DISCONNECTED))
 
@@ -201,7 +207,7 @@ class DBReplicationManager(unittest.Test
             self.skipTest("replication test skipped due to random failure, "
                 "see issue 3892")
         self.assertTrue(time.time()<timeout)
-        self.assertEquals("123", v)
+        self.assertEqual("123", v)
 
         txn=self.dbenvMaster.txn_begin()
         self.dbMaster.delete("ABC", txn=txn)
@@ -214,20 +220,17 @@ class DBReplicationManager(unittest.Test
             if v is None :
                 time.sleep(0.02)
         self.assertTrue(time.time()<timeout)
-        self.assertEquals(None, v)
+        self.assertEqual(None, v)
 
-class DBBaseReplication(DBReplicationManager):
+class DBBaseReplication(DBReplication) :
     def setUp(self) :
-        DBReplicationManager.setUp(self)
-        wr = weakref.ref(self)
+        DBReplication.setUp(self)
         def confirmed_master(a,b,c) :
             if (b == db.DB_EVENT_REP_MASTER) or (b == db.DB_EVENT_REP_ELECTED) :
-                self = wr()
                 self.confirmed_master = True
 
         def client_startupdone(a,b,c) :
             if b == db.DB_EVENT_REP_STARTUPDONE :
-                self = wr()
                 self.client_startupdone = True
 
         self.dbenvMaster.set_event_notify(confirmed_master)
@@ -240,11 +243,9 @@ class DBBaseReplication(DBReplicationMan
         # There are only two nodes, so we don't need to
         # do any routing decision
         def m2c(dbenv, control, rec, lsnp, envid, flags) :
-            self = wr()
             self.m2c.put((control, rec))
 
         def c2m(dbenv, control, rec, lsnp, envid, flags) :
-            self = wr()
             self.c2m.put((control, rec))
 
         self.dbenvMaster.rep_set_transport(13,m2c)
@@ -252,8 +253,8 @@ class DBBaseReplication(DBReplicationMan
         self.dbenvClient.rep_set_transport(3,c2m)
         self.dbenvClient.rep_set_priority(0)
 
-        self.assertEquals(self.dbenvMaster.rep_get_priority(),10)
-        self.assertEquals(self.dbenvClient.rep_get_priority(),0)
+        self.assertEqual(self.dbenvMaster.rep_get_priority(),10)
+        self.assertEqual(self.dbenvClient.rep_get_priority(),0)
 
         #self.dbenvMaster.set_verbose(db.DB_VERB_REPLICATION, True)
         #self.dbenvMaster.set_verbose(db.DB_VERB_FILEOPS_ALL, True)
@@ -261,12 +262,10 @@ class DBBaseReplication(DBReplicationMan
         #self.dbenvClient.set_verbose(db.DB_VERB_FILEOPS_ALL, True)
 
         def thread_master() :
-            self = wr()
             return self.thread_do(self.dbenvMaster, self.c2m, 3,
                     self.master_doing_election, True)
 
         def thread_client() :
-            self = wr()
             return self.thread_do(self.dbenvClient, self.m2c, 13,
                     self.client_doing_election, False)
 
@@ -299,6 +298,17 @@ class DBBaseReplication(DBReplicationMan
         self.c2m.put(None)
         self.t_m.join()
         self.t_c.join()
+
+        # Here we assign dummy event handlers to allow GC of the test object.
+        # Since the dummy handler doesn't use any outer scope variable, it
+        # doesn't keep any reference to the test object.
+        def dummy(*args) :
+            pass
+        self.dbenvMaster.set_event_notify(dummy)
+        self.dbenvClient.set_event_notify(dummy)
+        self.dbenvMaster.rep_set_transport(13,dummy)
+        self.dbenvClient.rep_set_transport(3,dummy)
+
         self.dbenvClient.close()
         self.dbenvMaster.close()
         test_support.rmtree(self.homeDirClient)
@@ -358,6 +368,9 @@ class DBBaseReplication(DBReplicationMan
             txn.commit()
             break
 
+        d = self.dbenvMaster.rep_stat(flags=db.DB_STAT_CLEAR);
+        self.assertTrue("master_changes" in d)
+
         txn=self.dbenvMaster.txn_begin()
         self.dbMaster.put("ABC", "123", txn=txn)
         txn.commit()
@@ -371,7 +384,7 @@ class DBBaseReplication(DBReplicationMan
             if v is None :
                 time.sleep(0.02)
         self.assertTrue(time.time()<timeout)
-        self.assertEquals("123", v)
+        self.assertEqual("123", v)
 
         txn=self.dbenvMaster.txn_begin()
         self.dbMaster.delete("ABC", txn=txn)
@@ -384,7 +397,7 @@ class DBBaseReplication(DBReplicationMan
             if v is None :
                 time.sleep(0.02)
         self.assertTrue(time.time()<timeout)
-        self.assertEquals(None, v)
+        self.assertEqual(None, v)
 
     if db.version() >= (4,7) :
         def test02_test_request(self) :
@@ -419,7 +432,6 @@ class DBBaseReplication(DBReplicationMan
                                     break
                                 except db.DBRepUnavailError :
                                     pass
-
                         if not election_status[0] and not self.confirmed_master :
                             from threading import Thread
                             election_status[0] = True
@@ -449,6 +461,14 @@ class DBBaseReplication(DBReplicationMan
 
             self.assertTrue(self.confirmed_master)
 
+    if db.version() >= (4,7) :
+        def test04_test_clockskew(self) :
+            fast, slow = 1234, 1230
+            self.dbenvMaster.rep_set_clockskew(fast, slow)
+            self.assertEqual((fast, slow),
+                    self.dbenvMaster.rep_get_clockskew())
+            self.basic_rep_threading()
+
 #----------------------------------------------------------------------
 
 def test_suite():
Index: python2.6-2.6.8/Lib/bsddb/test/test_sequence.py
===================================================================
--- python2.6-2.6.8.orig/Lib/bsddb/test/test_sequence.py
+++ python2.6-2.6.8/Lib/bsddb/test/test_sequence.py
@@ -6,7 +6,7 @@ from test_all import db, test_support, g
 
 class DBSequenceTest(unittest.TestCase):
     import sys
-    if sys.version_info[:3] < (2, 4, 0):
+    if sys.version_info < (2, 4) :
         def assertTrue(self, expr, msg=None):
             self.failUnless(expr,msg=msg)
 
@@ -37,53 +37,53 @@ class DBSequenceTest(unittest.TestCase):
         self.seq = db.DBSequence(self.d, flags=0)
         start_value = 10 * self.int_32_max
         self.assertEqual(0xA00000000, start_value)
-        self.assertEquals(None, self.seq.init_value(start_value))
-        self.assertEquals(None, self.seq.open(key='id', txn=None, flags=db.DB_CREATE))
-        self.assertEquals(start_value, self.seq.get(5))
-        self.assertEquals(start_value + 5, self.seq.get())
+        self.assertEqual(None, self.seq.initial_value(start_value))
+        self.assertEqual(None, self.seq.open(key='id', txn=None, flags=db.DB_CREATE))
+        self.assertEqual(start_value, self.seq.get(5))
+        self.assertEqual(start_value + 5, self.seq.get())
 
     def test_remove(self):
         self.seq = db.DBSequence(self.d, flags=0)
-        self.assertEquals(None, self.seq.open(key='foo', txn=None, flags=db.DB_CREATE))
-        self.assertEquals(None, self.seq.remove(txn=None, flags=0))
+        self.assertEqual(None, self.seq.open(key='foo', txn=None, flags=db.DB_CREATE))
+        self.assertEqual(None, self.seq.remove(txn=None, flags=0))
         del self.seq
 
     def test_get_key(self):
         self.seq = db.DBSequence(self.d, flags=0)
         key = 'foo'
-        self.assertEquals(None, self.seq.open(key=key, txn=None, flags=db.DB_CREATE))
-        self.assertEquals(key, self.seq.get_key())
+        self.assertEqual(None, self.seq.open(key=key, txn=None, flags=db.DB_CREATE))
+        self.assertEqual(key, self.seq.get_key())
 
     def test_get_dbp(self):
         self.seq = db.DBSequence(self.d, flags=0)
-        self.assertEquals(None, self.seq.open(key='foo', txn=None, flags=db.DB_CREATE))
-        self.assertEquals(self.d, self.seq.get_dbp())
+        self.assertEqual(None, self.seq.open(key='foo', txn=None, flags=db.DB_CREATE))
+        self.assertEqual(self.d, self.seq.get_dbp())
 
     def test_cachesize(self):
         self.seq = db.DBSequence(self.d, flags=0)
         cashe_size = 10
-        self.assertEquals(None, self.seq.set_cachesize(cashe_size))
-        self.assertEquals(None, self.seq.open(key='foo', txn=None, flags=db.DB_CREATE))
-        self.assertEquals(cashe_size, self.seq.get_cachesize())
+        self.assertEqual(None, self.seq.set_cachesize(cashe_size))
+        self.assertEqual(None, self.seq.open(key='foo', txn=None, flags=db.DB_CREATE))
+        self.assertEqual(cashe_size, self.seq.get_cachesize())
 
     def test_flags(self):
         self.seq = db.DBSequence(self.d, flags=0)
         flag = db.DB_SEQ_WRAP;
-        self.assertEquals(None, self.seq.set_flags(flag))
-        self.assertEquals(None, self.seq.open(key='foo', txn=None, flags=db.DB_CREATE))
-        self.assertEquals(flag, self.seq.get_flags() & flag)
+        self.assertEqual(None, self.seq.set_flags(flag))
+        self.assertEqual(None, self.seq.open(key='foo', txn=None, flags=db.DB_CREATE))
+        self.assertEqual(flag, self.seq.get_flags() & flag)
 
     def test_range(self):
         self.seq = db.DBSequence(self.d, flags=0)
         seq_range = (10 * self.int_32_max, 11 * self.int_32_max - 1)
-        self.assertEquals(None, self.seq.set_range(seq_range))
-        self.seq.init_value(seq_range[0])
-        self.assertEquals(None, self.seq.open(key='foo', txn=None, flags=db.DB_CREATE))
-        self.assertEquals(seq_range, self.seq.get_range())
+        self.assertEqual(None, self.seq.set_range(seq_range))
+        self.seq.initial_value(seq_range[0])
+        self.assertEqual(None, self.seq.open(key='foo', txn=None, flags=db.DB_CREATE))
+        self.assertEqual(seq_range, self.seq.get_range())
 
     def test_stat(self):
         self.seq = db.DBSequence(self.d, flags=0)
-        self.assertEquals(None, self.seq.open(key='foo', txn=None, flags=db.DB_CREATE))
+        self.assertEqual(None, self.seq.open(key='foo', txn=None, flags=db.DB_CREATE))
         stat = self.seq.stat()
         for param in ('nowait', 'min', 'max', 'value', 'current',
                       'flags', 'cache_size', 'last_value', 'wait'):
@@ -106,24 +106,24 @@ class DBSequenceTest(unittest.TestCase):
     def test_64bits(self) :
         # We don't use both extremes because they are problematic
         value_plus=(1L<<63)-2
-        self.assertEquals(9223372036854775806L,value_plus)
+        self.assertEqual(9223372036854775806L,value_plus)
         value_minus=(-1L<<63)+1  # Two complement
-        self.assertEquals(-9223372036854775807L,value_minus)
+        self.assertEqual(-9223372036854775807L,value_minus)
         self.seq = db.DBSequence(self.d, flags=0)
-        self.assertEquals(None, self.seq.init_value(value_plus-1))
-        self.assertEquals(None, self.seq.open(key='id', txn=None,
+        self.assertEqual(None, self.seq.initial_value(value_plus-1))
+        self.assertEqual(None, self.seq.open(key='id', txn=None,
             flags=db.DB_CREATE))
-        self.assertEquals(value_plus-1, self.seq.get(1))
-        self.assertEquals(value_plus, self.seq.get(1))
+        self.assertEqual(value_plus-1, self.seq.get(1))
+        self.assertEqual(value_plus, self.seq.get(1))
 
         self.seq.remove(txn=None, flags=0)
 
         self.seq = db.DBSequence(self.d, flags=0)
-        self.assertEquals(None, self.seq.init_value(value_minus))
-        self.assertEquals(None, self.seq.open(key='id', txn=None,
+        self.assertEqual(None, self.seq.initial_value(value_minus))
+        self.assertEqual(None, self.seq.open(key='id', txn=None,
             flags=db.DB_CREATE))
-        self.assertEquals(value_minus, self.seq.get(1))
-        self.assertEquals(value_minus+1, self.seq.get(1))
+        self.assertEqual(value_minus, self.seq.get(1))
+        self.assertEqual(value_minus+1, self.seq.get(1))
 
     def test_multiple_close(self):
         self.seq = db.DBSequence(self.d)
Index: python2.6-2.6.8/Lib/bsddb/test/test_thread.py
===================================================================
--- python2.6-2.6.8.orig/Lib/bsddb/test/test_thread.py
+++ python2.6-2.6.8/Lib/bsddb/test/test_thread.py
@@ -21,7 +21,6 @@ from test_all import db, dbutils, test_s
 
 if have_threads :
     from threading import Thread
-    import sys
     if sys.version_info[0] < 3 :
         from threading import currentThread
     else :
@@ -36,8 +35,7 @@ class BaseThreadedTestCase(unittest.Test
     dbsetflags   = 0
     envflags     = 0
 
-    import sys
-    if sys.version_info[:3] < (2, 4, 0):
+    if sys.version_info < (2, 4) :
         def assertTrue(self, expr, msg=None):
             self.failUnless(expr,msg=msg)
 
@@ -99,7 +97,6 @@ class ConcurrentDataStoreBase(BaseThread
                         args = (self.d, x),
                         name = 'reader %d' % x,
                         )#verbose = verbose)
-            import sys
             if sys.version_info[0] < 3 :
                 rt.setDaemon(True)
             else :
@@ -118,7 +115,6 @@ class ConcurrentDataStoreBase(BaseThread
             writers.append(wt)
 
         for t in writers:
-            import sys
             if sys.version_info[0] < 3 :
                 t.setDaemon(True)
             else :
@@ -131,7 +127,6 @@ class ConcurrentDataStoreBase(BaseThread
             t.join()
 
     def writerThread(self, d, keys, readers):
-        import sys
         if sys.version_info[0] < 3 :
             name = currentThread().getName()
         else :
@@ -161,7 +156,6 @@ class ConcurrentDataStoreBase(BaseThread
             print "%s: thread finished" % name
 
     def readerThread(self, d, readerNum):
-        import sys
         if sys.version_info[0] < 3 :
             name = currentThread().getName()
         else :
@@ -231,7 +225,6 @@ class SimpleThreadedBase(BaseThreadedTes
                         args = (self.d, x),
                         name = 'reader %d' % x,
                         )#verbose = verbose)
-            import sys
             if sys.version_info[0] < 3 :
                 rt.setDaemon(True)
             else :
@@ -250,7 +243,6 @@ class SimpleThreadedBase(BaseThreadedTes
             writers.append(wt)
 
         for t in writers:
-            import sys
             if sys.version_info[0] < 3 :
                 t.setDaemon(True)
             else :
@@ -263,7 +255,6 @@ class SimpleThreadedBase(BaseThreadedTes
             t.join()
 
     def writerThread(self, d, keys, readers):
-        import sys
         if sys.version_info[0] < 3 :
             name = currentThread().getName()
         else :
@@ -290,7 +281,6 @@ class SimpleThreadedBase(BaseThreadedTes
             print "%s: thread finished" % name
 
     def readerThread(self, d, readerNum):
-        import sys
         if sys.version_info[0] < 3 :
             name = currentThread().getName()
         else :
@@ -361,7 +351,6 @@ class ThreadedTransactionsBase(BaseThrea
                         args = (self.d, x),
                         name = 'reader %d' % x,
                         )#verbose = verbose)
-            import sys
             if sys.version_info[0] < 3 :
                 rt.setDaemon(True)
             else :
@@ -379,7 +368,6 @@ class ThreadedTransactionsBase(BaseThrea
             writers.append(wt)
 
         dt = Thread(target = self.deadlockThread)
-        import sys
         if sys.version_info[0] < 3 :
             dt.setDaemon(True)
         else :
@@ -387,7 +375,6 @@ class ThreadedTransactionsBase(BaseThrea
         dt.start()
 
         for t in writers:
-            import sys
             if sys.version_info[0] < 3 :
                 t.setDaemon(True)
             else :
@@ -403,7 +390,6 @@ class ThreadedTransactionsBase(BaseThrea
         dt.join()
 
     def writerThread(self, d, keys, readers):
-        import sys
         if sys.version_info[0] < 3 :
             name = currentThread().getName()
         else :
@@ -424,14 +410,17 @@ class ThreadedTransactionsBase(BaseThrea
                 readers.pop().start()
             except (db.DBLockDeadlockError, db.DBLockNotGrantedError), val:
                 if verbose:
-                    print "%s: Aborting transaction (%s)" % (name, val.args[1])
+                    if sys.version_info < (2, 6) :
+                        print "%s: Aborting transaction (%s)" % (name, val[1])
+                    else :
+                        print "%s: Aborting transaction (%s)" % (name,
+                                val.args[1])
                 txn.abort()
 
         if verbose:
             print "%s: thread finished" % name
 
     def readerThread(self, d, readerNum):
-        import sys
         if sys.version_info[0] < 3 :
             name = currentThread().getName()
         else :
@@ -455,7 +444,11 @@ class ThreadedTransactionsBase(BaseThrea
                 finished = True
             except (db.DBLockDeadlockError, db.DBLockNotGrantedError), val:
                 if verbose:
-                    print "%s: Aborting transaction (%s)" % (name, val.args[1])
+                    if sys.version_info < (2, 6) :
+                        print "%s: Aborting transaction (%s)" % (name, val[1])
+                    else :
+                        print "%s: Aborting transaction (%s)" % (name,
+                                val.args[1])
                 c.close()
                 txn.abort()
 
Index: python2.6-2.6.8/Modules/_bsddb.c
===================================================================
--- python2.6-2.6.8.orig/Modules/_bsddb.c
+++ python2.6-2.6.8/Modules/_bsddb.c
@@ -73,6 +73,10 @@
  * DBLock       (A lock handle)
  * DBSequence   (Sequence)
  *
+ * More datatypes added:
+ *
+ * DBLogCursor  (Log Cursor)
+ *
  */
 
 /* --------------------------------------------------------------------- */
@@ -169,9 +173,6 @@ static PyInterpreterState* _db_interpret
 
 #endif
 
-/* Should DB_INCOMPLETE be turned into a warning or an exception? */
-#define INCOMPLETE_IS_WARNING 1
-
 /* --------------------------------------------------------------------- */
 /* Exceptions */
 
@@ -191,10 +192,6 @@ static PyObject* DBNoServerIDError;
 static PyObject* DBPageNotFoundError;   /* DB_PAGE_NOTFOUND */
 static PyObject* DBSecondaryBadError;   /* DB_SECONDARY_BAD */
 
-#if !INCOMPLETE_IS_WARNING
-static PyObject* DBIncompleteError;     /* DB_INCOMPLETE */
-#endif
-
 static PyObject* DBInvalidArgError;     /* EINVAL */
 static PyObject* DBAccessError;         /* EACCES */
 static PyObject* DBNoSpaceError;        /* ENOSPC */
@@ -205,10 +202,20 @@ static PyObject* DBFileExistsError;
 static PyObject* DBNoSuchFileError;     /* ENOENT */
 static PyObject* DBPermissionsError;    /* EPERM  */
 
-#if (DBVER >= 42)
 static PyObject* DBRepHandleDeadError;  /* DB_REP_HANDLE_DEAD */
+#if (DBVER >= 44)
+static PyObject* DBRepLockoutError;     /* DB_REP_LOCKOUT */
+#endif
+
+#if (DBVER >= 46)
+static PyObject* DBRepLeaseExpiredError; /* DB_REP_LEASE_EXPIRED */
+#endif
+
+#if (DBVER >= 47)
+static PyObject* DBForeignConflictError; /* DB_FOREIGN_CONFLICT */
 #endif
 
+
 static PyObject* DBRepUnavailError;     /* DB_REP_UNAVAIL */
 
 #if (DBVER < 43)
@@ -242,7 +249,7 @@ static PyObject* DBRepUnavailError;
 #endif
 
 staticforward PyTypeObject DB_Type, DBCursor_Type, DBEnv_Type, DBTxn_Type,
-              DBLock_Type;
+              DBLock_Type, DBLogCursor_Type;
 #if (DBVER >= 43)
 staticforward PyTypeObject DBSequence_Type;
 #endif
@@ -254,6 +261,7 @@ staticforward PyTypeObject DBSequence_Ty
 
 #define DBObject_Check(v)           (Py_TYPE(v) == &DB_Type)
 #define DBCursorObject_Check(v)     (Py_TYPE(v) == &DBCursor_Type)
+#define DBLogCursorObject_Check(v)  (Py_TYPE(v) == &DBLogCursor_Type)
 #define DBEnvObject_Check(v)        (Py_TYPE(v) == &DBEnv_Type)
 #define DBTxnObject_Check(v)        (Py_TYPE(v) == &DBTxn_Type)
 #define DBLockObject_Check(v)       (Py_TYPE(v) == &DBLock_Type)
@@ -359,6 +367,9 @@ staticforward PyTypeObject DBSequence_Ty
 #define CHECK_CURSOR_NOT_CLOSED(curs) \
         _CHECK_OBJECT_NOT_CLOSED(curs->dbc, DBCursorClosedError, DBCursor)
 
+#define CHECK_LOGCURSOR_NOT_CLOSED(logcurs) \
+        _CHECK_OBJECT_NOT_CLOSED(logcurs->logc, DBCursorClosedError, DBLogCursor)
+
 #if (DBVER >= 43)
 #define CHECK_SEQUENCE_NOT_CLOSED(curs) \
         _CHECK_OBJECT_NOT_CLOSED(curs->sequence, DBError, DBSequence)
@@ -671,27 +682,8 @@ static int makeDBError(int err)
     unsigned int bytes_left;
 
     switch (err) {
-        case 0:                     /* successful, no error */      break;
-
-#if (DBVER < 41)
-        case DB_INCOMPLETE:
-#if INCOMPLETE_IS_WARNING
-            bytes_left = our_strlcpy(errTxt, db_strerror(err), sizeof(errTxt));
-            /* Ensure that bytes_left never goes negative */
-            if (_db_errmsg[0] && bytes_left < (sizeof(errTxt) - 4)) {
-                bytes_left = sizeof(errTxt) - bytes_left - 4 - 1;
-                assert(bytes_left >= 0);
-                strcat(errTxt, " -- ");
-                strncat(errTxt, _db_errmsg, bytes_left);
-            }
-            _db_errmsg[0] = 0;
-            exceptionRaised = PyErr_Warn(PyExc_RuntimeWarning, errTxt);
-
-#else  /* do an exception instead */
-        errObj = DBIncompleteError;
-#endif
-        break;
-#endif /* DBVER < 41 */
+        case 0:                     /* successful, no error */
+            return 0;
 
         case DB_KEYEMPTY:           errObj = DBKeyEmptyError;       break;
         case DB_KEYEXIST:           errObj = DBKeyExistError;       break;
@@ -721,8 +713,17 @@ static int makeDBError(int err)
         case ENOENT:  errObj = DBNoSuchFileError;   break;
         case EPERM :  errObj = DBPermissionsError;  break;
 
-#if (DBVER >= 42)
         case DB_REP_HANDLE_DEAD : errObj = DBRepHandleDeadError; break;
+#if (DBVER >= 44)
+        case DB_REP_LOCKOUT : errObj = DBRepLockoutError; break;
+#endif
+
+#if (DBVER >= 46)
+        case DB_REP_LEASE_EXPIRED : errObj = DBRepLeaseExpiredError; break;
+#endif
+
+#if (DBVER >= 47)
+        case DB_FOREIGN_CONFLICT : errObj = DBForeignConflictError; break;
 #endif
 
         case DB_REP_UNAVAIL : errObj = DBRepUnavailError; break;
@@ -792,7 +793,6 @@ static int _DB_delete(DBObject* self, DB
     if (makeDBError(err)) {
         return -1;
     }
-    self->haveStat = 0;
     return 0;
 }
 
@@ -809,7 +809,6 @@ static int _DB_put(DBObject* self, DB_TX
     if (makeDBError(err)) {
         return -1;
     }
-    self->haveStat = 0;
     return 0;
 }
 
@@ -934,7 +933,6 @@ newDBObject(DBEnvObject* arg, int flags)
     if (self == NULL)
         return NULL;
 
-    self->haveStat = 0;
     self->flags = 0;
     self->setflags = 0;
     self->myenvobj = NULL;
@@ -1081,6 +1079,54 @@ DBCursor_dealloc(DBCursorObject* self)
 }
 
 
+static DBLogCursorObject*
+newDBLogCursorObject(DB_LOGC* dblogc, DBEnvObject* env)
+{
+    DBLogCursorObject* self;
+
+    self = PyObject_New(DBLogCursorObject, &DBLogCursor_Type);
+
+    if (self == NULL)
+        return NULL;
+
+    self->logc = dblogc;
+    self->env = env;
+
+    INSERT_IN_DOUBLE_LINKED_LIST(self->env->children_logcursors, self);
+
+    self->in_weakreflist = NULL;
+    Py_INCREF(self->env);
+    return self;
+}
+
+
+/* Forward declaration */
+static PyObject *DBLogCursor_close_internal(DBLogCursorObject* self);
+
+static void
+DBLogCursor_dealloc(DBLogCursorObject* self)
+{
+    PyObject *dummy;
+
+    if (self->logc != NULL) {
+        dummy = DBLogCursor_close_internal(self);
+        /*
+        ** Raising exceptions while doing
+        ** garbage collection is a fatal error.
+        */
+        if (dummy)
+            Py_DECREF(dummy);
+        else
+            PyErr_Clear();
+    }
+    if (self->in_weakreflist != NULL) {
+        PyObject_ClearWeakRefs((PyObject *) self);
+    }
+    Py_DECREF(self->env);
+    PyObject_Del(self);
+}
+
+
 static DBEnvObject*
 newDBEnvObject(int flags)
 {
@@ -1096,6 +1142,7 @@ newDBEnvObject(int flags)
     self->moduleFlags.cursorSetReturnsNone = DEFAULT_CURSOR_SET_RETURNS_NONE;
     self->children_dbs = NULL;
     self->children_txns = NULL;
+    self->children_logcursors = NULL ;
     Py_INCREF(Py_None);
     self->private_obj = Py_None;
     Py_INCREF(Py_None);
@@ -1167,6 +1214,8 @@ newDBTxnObject(DBEnvObject* myenv, DBTxn
     self->flag_prepare = 0;
     self->parent_txn = NULL;
     self->env = NULL;
+    /* We initialize just in case "txn_begin" fails */
+    self->txn = NULL;
 
     if (parent && ((PyObject *)parent!=Py_None)) {
         parent_txn = parent->txn;
@@ -1180,6 +1229,7 @@ newDBTxnObject(DBEnvObject* myenv, DBTxn
         MYDB_END_ALLOW_THREADS;
 
         if (makeDBError(err)) {
+            /* Free object half initialized */
             Py_DECREF(self);
             return NULL;
         }
@@ -1213,7 +1263,7 @@ DBTxn_dealloc(DBTxnObject* self)
     if (self->txn) {
         int flag_prepare = self->flag_prepare;
 
-        dummy=DBTxn_abort_discard_internal(self,0);
+        dummy=DBTxn_abort_discard_internal(self, 0);
         /*
         ** Raising exceptions while doing
         ** garbage collection is a fatal error.
@@ -1236,7 +1286,12 @@ DBTxn_dealloc(DBTxnObject* self)
     if (self->env) {
         Py_DECREF(self->env);
     } else {
-        Py_DECREF(self->parent_txn);
+        /*
+        ** We can have "self->env==NULL" and "self->parent_txn==NULL"
+        ** if something happens when creating the transaction object
+        ** and we abort the object while half done.
+        */
+        Py_XDECREF(self->parent_txn);
     }
     PyObject_Del(self);
 }
@@ -1251,6 +1306,7 @@ newDBLockObject(DBEnvObject* myenv, u_in
     if (self == NULL)
         return NULL;
     self->in_weakreflist = NULL;
+    self->lock_initialized = 0;  /* Just in case the call fails */
 
     MYDB_BEGIN_ALLOW_THREADS;
     err = myenv->db_env->lock_get(myenv->db_env, locker, flags, obj, lock_mode,
@@ -1259,6 +1315,8 @@ newDBLockObject(DBEnvObject* myenv, u_in
     if (makeDBError(err)) {
         Py_DECREF(self);
         self = NULL;
+    } else {
+        self->lock_initialized = 1;
     }
 
     return self;
@@ -1272,6 +1330,7 @@ DBLock_dealloc(DBLockObject* self)
         PyObject_ClearWeakRefs((PyObject *) self);
     }
     /* TODO: is this lock held? should we release it? */
+    /* CAUTION: The lock can be not initialized if the creation has failed */
 
     PyObject_Del(self);
 }
@@ -1292,6 +1351,7 @@ newDBSequenceObject(DBObject* mydb,  int
     self->txn = NULL;
 
     self->in_weakreflist = NULL;
+    self->sequence = NULL;  /* Just in case the call fails */
 
     MYDB_BEGIN_ALLOW_THREADS;
     err = db_sequence_create(&self->sequence, self->mydb->db, flags);
@@ -1421,10 +1481,70 @@ _db_associateCallback(DB* db, const DBT*
                 PyErr_Print();
             }
         }
+#if (DBVER >= 46)
+        else if (PyList_Check(result))
+        {
+            char* data;
+            Py_ssize_t size;
+            int i, listlen;
+            DBT* dbts;
+
+            listlen = PyList_Size(result);
+
+            dbts = (DBT *)malloc(sizeof(DBT) * listlen);
+
+            for (i=0; i<listlen; i++)
+            {
+                if (!PyBytes_Check(PyList_GetItem(result, i)))
+                {
+                    PyErr_SetString(
+                       PyExc_TypeError,
+#if (PY_VERSION_HEX < 0x03000000)
+"The list returned by DB->associate callback should be a list of strings.");
+#else
+"The list returned by DB->associate callback should be a list of bytes.");
+#endif
+                    PyErr_Print();
+                }
+
+                PyBytes_AsStringAndSize(
+                    PyList_GetItem(result, i),
+                    &data, &size);
+
+                CLEAR_DBT(dbts[i]);
+                dbts[i].data = malloc(size);          /* TODO, check this */
+
+                if (dbts[i].data)
+                {
+                    memcpy(dbts[i].data, data, size);
+                    dbts[i].size = size;
+                    dbts[i].ulen = dbts[i].size;
+                    dbts[i].flags = DB_DBT_APPMALLOC;  /* DB will free */
+                }
+                else
+                {
+                    PyErr_SetString(PyExc_MemoryError,
+                        "malloc failed in _db_associateCallback (list)");
+                    PyErr_Print();
+                }
+            }
+
+            CLEAR_DBT(*secKey);
+
+            secKey->data = dbts;
+            secKey->size = listlen;
+            secKey->flags = DB_DBT_APPMALLOC | DB_DBT_MULTIPLE;
+            retval = 0;
+        }
+#endif
         else {
             PyErr_SetString(
                PyExc_TypeError,
-               "DB associate callback should return DB_DONOTINDEX or string.");
+#if (PY_VERSION_HEX < 0x03000000)
+"DB associate callback should return DB_DONOTINDEX/string/list of strings.");
+#else
+"DB associate callback should return DB_DONOTINDEX/bytes/list of bytes.");
+#endif
             PyErr_Print();
         }
 
@@ -1443,29 +1563,18 @@ DB_associate(DBObject* self, PyObject* a
     int err, flags=0;
     DBObject* secondaryDB;
     PyObject* callback;
-#if (DBVER >= 41)
     PyObject *txnobj = NULL;
     DB_TXN *txn = NULL;
     static char* kwnames[] = {"secondaryDB", "callback", "flags", "txn",
                                     NULL};
-#else
-    static char* kwnames[] = {"secondaryDB", "callback", "flags", NULL};
-#endif
 
-#if (DBVER >= 41)
     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO|iO:associate", kwnames,
                                      &secondaryDB, &callback, &flags,
                                      &txnobj)) {
-#else
-    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO|i:associate", kwnames,
-                                     &secondaryDB, &callback, &flags)) {
-#endif
         return NULL;
     }
 
-#if (DBVER >= 41)
     if (!checkTxnObj(txnobj, &txn)) return NULL;
-#endif
 
     CHECK_DB_NOT_CLOSED(self);
     if (!DBObject_Check(secondaryDB)) {
@@ -1501,18 +1610,11 @@ DB_associate(DBObject* self, PyObject* a
     PyEval_InitThreads();
 #endif
     MYDB_BEGIN_ALLOW_THREADS;
-#if (DBVER >= 41)
     err = self->db->associate(self->db,
                               txn,
                               secondaryDB->db,
                               _db_associateCallback,
                               flags);
-#else
-    err = self->db->associate(self->db,
-                              secondaryDB->db,
-                              _db_associateCallback,
-                              flags);
-#endif
     MYDB_END_ALLOW_THREADS;
 
     if (err) {
@@ -1705,6 +1807,64 @@ DB_delete(DBObject* self, PyObject* args
 }
 
 
+#if (DBVER >= 47)
+/*
+** This function is available since Berkeley DB 4.4,
+** but 4.6 version is so buggy that we only support
+** it from BDB 4.7 and newer.
+*/
+static PyObject*
+DB_compact(DBObject* self, PyObject* args, PyObject* kwargs)
+{
+    PyObject* txnobj = NULL;
+    PyObject *startobj = NULL, *stopobj = NULL;
+    int flags = 0;
+    DB_TXN *txn = NULL;
+    DBT *start_p = NULL, *stop_p = NULL;
+    DBT start, stop;
+    int err;
+    DB_COMPACT c_data = { 0 };
+    static char* kwnames[] = { "txn", "start", "stop", "flags",
+                               "compact_fillpercent", "compact_pages",
+                               "compact_timeout", NULL };
+
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OOOiiiI:compact", kwnames,
+                                     &txnobj, &startobj, &stopobj, &flags,
+                                     &c_data.compact_fillpercent,
+                                     &c_data.compact_pages,
+                                     &c_data.compact_timeout))
+        return NULL;
+
+    CHECK_DB_NOT_CLOSED(self);
+    if (!checkTxnObj(txnobj, &txn)) {
+        return NULL;
+    }
+
+    if (startobj && make_key_dbt(self, startobj, &start, NULL)) {
+        start_p = &start;
+    }
+    if (stopobj && make_key_dbt(self, stopobj, &stop, NULL)) {
+        stop_p = &stop;
+    }
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->compact(self->db, txn, start_p, stop_p, &c_data,
+                            flags, NULL);
+    MYDB_END_ALLOW_THREADS;
+
+    if (startobj)
+        FREE_DBT(start);
+    if (stopobj)
+        FREE_DBT(stop);
+
+    RETURN_IF_ERR();
+
+    return PyLong_FromUnsignedLong(c_data.compact_pages_truncated);
+}
+#endif
+
+
 static PyObject*
 DB_fd(DBObject* self)
 {
@@ -1720,6 +1880,55 @@ DB_fd(DBObject* self)
 }
 
 
+#if (DBVER >= 46)
+static PyObject*
+DB_exists(DBObject* self, PyObject* args, PyObject* kwargs)
+{
+    int err, flags=0;
+    PyObject* txnobj = NULL;
+    PyObject* keyobj;
+    DBT key;
+    DB_TXN *txn;
+
+    static char* kwnames[] = {"key", "txn", "flags", NULL};
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|Oi:exists", kwnames,
+                &keyobj, &txnobj, &flags))
+        return NULL;
+
+    CHECK_DB_NOT_CLOSED(self);
+    if (!make_key_dbt(self, keyobj, &key, NULL))
+        return NULL;
+    if (!checkTxnObj(txnobj, &txn)) {
+        FREE_DBT(key);
+        return NULL;
+    }
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->exists(self->db, txn, &key, flags);
+    MYDB_END_ALLOW_THREADS;
+
+    FREE_DBT(key);
+
+    if (!err) {
+        Py_INCREF(Py_True);
+        return Py_True;
+    }
+    if ((err == DB_NOTFOUND || err == DB_KEYEMPTY)) {
+        Py_INCREF(Py_False);
+        return Py_False;
+    }
+
+    /*
+    ** If we reach there, there was an error. The
+    ** "return" should be unreachable.
+    */
+    RETURN_IF_ERR();
+    assert(0);  /* This coude SHOULD be unreachable */
+    return NULL;
+}
+#endif
+
 static PyObject*
 DB_get(DBObject* self, PyObject* args, PyObject* kwargs)
 {
@@ -1919,7 +2128,7 @@ DB_get_size(DBObject* self, PyObject* ar
     MYDB_BEGIN_ALLOW_THREADS;
     err = self->db->get(self->db, txn, &key, &data, flags);
     MYDB_END_ALLOW_THREADS;
-    if (err == DB_BUFFER_SMALL) {
+    if ((err == DB_BUFFER_SMALL) || (err == 0)) {
         retval = NUMBER_FromLong((long)data.size);
         err = 0;
     }
@@ -2118,7 +2327,6 @@ DB_open(DBObject* self, PyObject* args,
     int err, type = DB_UNKNOWN, flags=0, mode=0660;
     char* filename = NULL;
     char* dbname = NULL;
-#if (DBVER >= 41)
     PyObject *txnobj = NULL;
     DB_TXN *txn = NULL;
     /* with dbname */
@@ -2127,45 +2335,22 @@ DB_open(DBObject* self, PyObject* args,
     /* without dbname */
     static char* kwnames_basic[] = {
         "filename", "dbtype", "flags", "mode", "txn", NULL};
-#else
-    /* with dbname */
-    static char* kwnames[] = {
-        "filename", "dbname", "dbtype", "flags", "mode", NULL};
-    /* without dbname */
-    static char* kwnames_basic[] = {
-        "filename", "dbtype", "flags", "mode", NULL};
-#endif
 
-#if (DBVER >= 41)
     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "z|ziiiO:open", kwnames,
                                      &filename, &dbname, &type, &flags, &mode,
                                      &txnobj))
-#else
-    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "z|ziii:open", kwnames,
-                                     &filename, &dbname, &type, &flags,
-                                     &mode))
-#endif
     {
         PyErr_Clear();
         type = DB_UNKNOWN; flags = 0; mode = 0660;
         filename = NULL; dbname = NULL;
-#if (DBVER >= 41)
         if (!PyArg_ParseTupleAndKeywords(args, kwargs,"z|iiiO:open",
                                          kwnames_basic,
                                          &filename, &type, &flags, &mode,
                                          &txnobj))
             return NULL;
-#else
-        if (!PyArg_ParseTupleAndKeywords(args, kwargs,"z|iii:open",
-                                         kwnames_basic,
-                                         &filename, &type, &flags, &mode))
-            return NULL;
-#endif
     }
 
-#if (DBVER >= 41)
     if (!checkTxnObj(txnobj, &txn)) return NULL;
-#endif
 
     if (NULL == self->db) {
         PyObject *t = Py_BuildValue("(is)", 0,
@@ -2177,24 +2362,17 @@ DB_open(DBObject* self, PyObject* args,
         return NULL;
     }
 
-#if (DBVER >= 41)
     if (txn) {  /* Can't use 'txnobj' because could be 'txnobj==Py_None' */
         INSERT_IN_DOUBLE_LINKED_LIST_TXN(((DBTxnObject *)txnobj)->children_dbs,self);
         self->txn=(DBTxnObject *)txnobj;
     } else {
         self->txn=NULL;
     }
-#else
-    self->txn=NULL;
-#endif
 
     MYDB_BEGIN_ALLOW_THREADS;
-#if (DBVER >= 41)
     err = self->db->open(self->db, txn, filename, dbname, type, flags, mode);
-#else
-    err = self->db->open(self->db, filename, dbname, type, flags, mode);
-#endif
     MYDB_END_ALLOW_THREADS;
+
     if (makeDBError(err)) {
         PyObject *dummy;
 
@@ -2203,9 +2381,7 @@ DB_open(DBObject* self, PyObject* args,
         return NULL;
     }
 
-#if (DBVER >= 42)
     self->db->get_flags(self->db, &self->setflags);
-#endif
 
     self->flags = flags;
 
@@ -2323,84 +2499,194 @@ DB_set_private(DBObject* self, PyObject*
     RETURN_NONE();
 }
 
-
+#if (DBVER >= 46)
 static PyObject*
-DB_set_bt_minkey(DBObject* self, PyObject* args)
+DB_set_priority(DBObject* self, PyObject* args)
 {
-    int err, minkey;
+    int err, priority;
 
-    if (!PyArg_ParseTuple(args,"i:set_bt_minkey", &minkey ))
+    if (!PyArg_ParseTuple(args,"i:set_priority", &priority))
         return NULL;
     CHECK_DB_NOT_CLOSED(self);
 
     MYDB_BEGIN_ALLOW_THREADS;
-    err = self->db->set_bt_minkey(self->db, minkey);
+    err = self->db->set_priority(self->db, priority);
     MYDB_END_ALLOW_THREADS;
     RETURN_IF_ERR();
     RETURN_NONE();
 }
 
-static int
-_default_cmp(const DBT *leftKey,
-             const DBT *rightKey)
+static PyObject*
+DB_get_priority(DBObject* self)
 {
-  int res;
-  int lsize = leftKey->size, rsize = rightKey->size;
+    int err = 0;
+    DB_CACHE_PRIORITY priority;
 
-  res = memcmp(leftKey->data, rightKey->data,
-               lsize < rsize ? lsize : rsize);
+    CHECK_DB_NOT_CLOSED(self);
 
-  if (res == 0) {
-      if (lsize < rsize) {
-          res = -1;
-      }
-      else if (lsize > rsize) {
-          res = 1;
-      }
-  }
-  return res;
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->get_priority(self->db, &priority);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(priority);
 }
+#endif
 
-static int
-_db_compareCallback(DB* db,
-                    const DBT *leftKey,
-                    const DBT *rightKey)
+static PyObject*
+DB_get_dbname(DBObject* self)
 {
-    int res = 0;
-    PyObject *args;
-    PyObject *result = NULL;
-    DBObject *self = (DBObject *)db->app_private;
-
-    if (self == NULL || self->btCompareCallback == NULL) {
-        MYDB_BEGIN_BLOCK_THREADS;
-        PyErr_SetString(PyExc_TypeError,
-                        (self == 0
-                         ? "DB_bt_compare db is NULL."
-                         : "DB_bt_compare callback is NULL."));
-        /* we're in a callback within the DB code, we can't raise */
-        PyErr_Print();
-        res = _default_cmp(leftKey, rightKey);
-        MYDB_END_BLOCK_THREADS;
-    } else {
-        MYDB_BEGIN_BLOCK_THREADS;
+    int err;
+    const char *filename, *dbname;
 
-        args = BuildValue_SS(leftKey->data, leftKey->size, rightKey->data, rightKey->size);
-        if (args != NULL) {
-                result = PyEval_CallObject(self->btCompareCallback, args);
-        }
-        if (args == NULL || result == NULL) {
-            /* we're in a callback within the DB code, we can't raise */
-            PyErr_Print();
-            res = _default_cmp(leftKey, rightKey);
-        } else if (NUMBER_Check(result)) {
-            res = NUMBER_AsLong(result);
-        } else {
-            PyErr_SetString(PyExc_TypeError,
-                            "DB_bt_compare callback MUST return an int.");
-            /* we're in a callback within the DB code, we can't raise */
-            PyErr_Print();
-            res = _default_cmp(leftKey, rightKey);
-        }
+    CHECK_DB_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->get_dbname(self->db, &filename, &dbname);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    /* If "dbname==NULL", it is correctly converted to "None" */
+    return Py_BuildValue("(ss)", filename, dbname);
+}
+
+static PyObject*
+DB_get_open_flags(DBObject* self)
+{
+    int err;
+    unsigned int flags;
+
+    CHECK_DB_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->get_open_flags(self->db, &flags);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(flags);
+}
+
+static PyObject*
+DB_set_q_extentsize(DBObject* self, PyObject* args)
+{
+    int err;
+    u_int32_t extentsize;
+
+    if (!PyArg_ParseTuple(args,"i:set_q_extentsize", &extentsize))
+        return NULL;
+    CHECK_DB_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->set_q_extentsize(self->db, extentsize);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DB_get_q_extentsize(DBObject* self)
+{
+    int err = 0;
+    u_int32_t extentsize;
+
+    CHECK_DB_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->get_q_extentsize(self->db, &extentsize);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(extentsize);
+}
+
+static PyObject*
+DB_set_bt_minkey(DBObject* self, PyObject* args)
+{
+    int err, minkey;
+
+    if (!PyArg_ParseTuple(args,"i:set_bt_minkey", &minkey))
+        return NULL;
+    CHECK_DB_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->set_bt_minkey(self->db, minkey);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DB_get_bt_minkey(DBObject* self)
+{
+    int err;
+    u_int32_t bt_minkey;
+
+    CHECK_DB_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->get_bt_minkey(self->db, &bt_minkey);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(bt_minkey);
+}
+
+static int
+_default_cmp(const DBT *leftKey,
+             const DBT *rightKey)
+{
+  int res;
+  int lsize = leftKey->size, rsize = rightKey->size;
+
+  res = memcmp(leftKey->data, rightKey->data,
+               lsize < rsize ? lsize : rsize);
+
+  if (res == 0) {
+      if (lsize < rsize) {
+          res = -1;
+      }
+      else if (lsize > rsize) {
+          res = 1;
+      }
+  }
+  return res;
+}
+
+static int
+_db_compareCallback(DB* db,
+                    const DBT *leftKey,
+                    const DBT *rightKey)
+{
+    int res = 0;
+    PyObject *args;
+    PyObject *result = NULL;
+    DBObject *self = (DBObject *)db->app_private;
+
+    if (self == NULL || self->btCompareCallback == NULL) {
+        MYDB_BEGIN_BLOCK_THREADS;
+        PyErr_SetString(PyExc_TypeError,
+                        (self == 0
+                         ? "DB_bt_compare db is NULL."
+                         : "DB_bt_compare callback is NULL."));
+        /* we're in a callback within the DB code, we can't raise */
+        PyErr_Print();
+        res = _default_cmp(leftKey, rightKey);
+        MYDB_END_BLOCK_THREADS;
+    } else {
+        MYDB_BEGIN_BLOCK_THREADS;
+
+        args = BuildValue_SS(leftKey->data, leftKey->size, rightKey->data, rightKey->size);
+        if (args != NULL) {
+                result = PyEval_CallObject(self->btCompareCallback, args);
+        }
+        if (args == NULL || result == NULL) {
+            /* we're in a callback within the DB code, we can't raise */
+            PyErr_Print();
+            res = _default_cmp(leftKey, rightKey);
+        } else if (NUMBER_Check(result)) {
+            res = NUMBER_AsLong(result);
+        } else {
+            PyErr_SetString(PyExc_TypeError,
+                            "DB_bt_compare callback MUST return an int.");
+            /* we're in a callback within the DB code, we can't raise */
+            PyErr_Print();
+            res = _default_cmp(leftKey, rightKey);
+        }
 
         Py_XDECREF(args);
         Py_XDECREF(result);
@@ -2494,6 +2780,23 @@ DB_set_cachesize(DBObject* self, PyObjec
     RETURN_NONE();
 }
 
+static PyObject*
+DB_get_cachesize(DBObject* self)
+{
+    int err;
+    u_int32_t gbytes, bytes;
+    int ncache;
+
+    CHECK_DB_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->get_cachesize(self->db, &gbytes, &bytes, &ncache);
+    MYDB_END_ALLOW_THREADS;
+
+    RETURN_IF_ERR();
+
+    return Py_BuildValue("(iii)", gbytes, bytes, ncache);
+}
 
 static PyObject*
 DB_set_flags(DBObject* self, PyObject* args)
@@ -2513,6 +2816,50 @@ DB_set_flags(DBObject* self, PyObject* a
     RETURN_NONE();
 }
 
+static PyObject*
+DB_get_flags(DBObject* self)
+{
+    int err;
+    u_int32_t flags;
+
+    CHECK_DB_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->get_flags(self->db, &flags);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(flags);
+}
+
+#if (DBVER >= 43)
+static PyObject*
+DB_get_transactional(DBObject* self)
+{
+    int err;
+
+    CHECK_DB_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->get_transactional(self->db);
+    MYDB_END_ALLOW_THREADS;
+
+    if(err == 0) {
+        Py_INCREF(Py_False);
+        return Py_False;
+    } else if(err == 1) {
+        Py_INCREF(Py_True);
+        return Py_True;
+    }
+
+    /*
+    ** If we reach there, there was an error. The
+    ** "return" should be unreachable.
+    */
+    RETURN_IF_ERR();
+    assert(0);  /* This coude SHOULD be unreachable */
+    return NULL;
+}
+#endif
 
 static PyObject*
 DB_set_h_ffactor(DBObject* self, PyObject* args)
@@ -2530,6 +2877,20 @@ DB_set_h_ffactor(DBObject* self, PyObjec
     RETURN_NONE();
 }
 
+static PyObject*
+DB_get_h_ffactor(DBObject* self)
+{
+    int err;
+    u_int32_t ffactor;
+
+    CHECK_DB_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->get_h_ffactor(self->db, &ffactor);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(ffactor);
+}
 
 static PyObject*
 DB_set_h_nelem(DBObject* self, PyObject* args)
@@ -2547,6 +2908,20 @@ DB_set_h_nelem(DBObject* self, PyObject*
     RETURN_NONE();
 }
 
+static PyObject*
+DB_get_h_nelem(DBObject* self)
+{
+    int err;
+    u_int32_t nelem;
+
+    CHECK_DB_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->get_h_nelem(self->db, &nelem);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(nelem);
+}
 
 static PyObject*
 DB_set_lorder(DBObject* self, PyObject* args)
@@ -2564,6 +2939,20 @@ DB_set_lorder(DBObject* self, PyObject*
     RETURN_NONE();
 }
 
+static PyObject*
+DB_get_lorder(DBObject* self)
+{
+    int err;
+    int lorder;
+
+    CHECK_DB_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->get_lorder(self->db, &lorder);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(lorder);
+}
 
 static PyObject*
 DB_set_pagesize(DBObject* self, PyObject* args)
@@ -2581,6 +2970,20 @@ DB_set_pagesize(DBObject* self, PyObject
     RETURN_NONE();
 }
 
+static PyObject*
+DB_get_pagesize(DBObject* self)
+{
+    int err;
+    u_int32_t pagesize;
+
+    CHECK_DB_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->get_pagesize(self->db, &pagesize);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(pagesize);
+}
 
 static PyObject*
 DB_set_re_delim(DBObject* self, PyObject* args)
@@ -2604,6 +3007,20 @@ DB_set_re_delim(DBObject* self, PyObject
 }
 
 static PyObject*
+DB_get_re_delim(DBObject* self)
+{
+    int err, re_delim;
+
+    CHECK_DB_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->get_re_delim(self->db, &re_delim);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(re_delim);
+}
+
+static PyObject*
 DB_set_re_len(DBObject* self, PyObject* args)
 {
     int err, len;
@@ -2619,6 +3036,20 @@ DB_set_re_len(DBObject* self, PyObject*
     RETURN_NONE();
 }
 
+static PyObject*
+DB_get_re_len(DBObject* self)
+{
+    int err;
+    u_int32_t re_len;
+
+    CHECK_DB_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->get_re_len(self->db, &re_len);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(re_len);
+}
 
 static PyObject*
 DB_set_re_pad(DBObject* self, PyObject* args)
@@ -2640,40 +3071,50 @@ DB_set_re_pad(DBObject* self, PyObject*
     RETURN_NONE();
 }
 
+static PyObject*
+DB_get_re_pad(DBObject* self)
+{
+    int err, re_pad;
+
+    CHECK_DB_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->get_re_pad(self->db, &re_pad);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(re_pad);
+}
 
 static PyObject*
 DB_set_re_source(DBObject* self, PyObject* args)
 {
     int err;
-    char *re_source;
+    char *source;
 
-    if (!PyArg_ParseTuple(args,"s:set_re_source", &re_source))
+    if (!PyArg_ParseTuple(args,"s:set_re_source", &source))
         return NULL;
     CHECK_DB_NOT_CLOSED(self);
 
     MYDB_BEGIN_ALLOW_THREADS;
-    err = self->db->set_re_source(self->db, re_source);
+    err = self->db->set_re_source(self->db, source);
     MYDB_END_ALLOW_THREADS;
     RETURN_IF_ERR();
     RETURN_NONE();
 }
 
-
 static PyObject*
-DB_set_q_extentsize(DBObject* self, PyObject* args)
+DB_get_re_source(DBObject* self)
 {
     int err;
-    int extentsize;
+    const char *source;
 
-    if (!PyArg_ParseTuple(args,"i:set_q_extentsize", &extentsize))
-        return NULL;
     CHECK_DB_NOT_CLOSED(self);
 
     MYDB_BEGIN_ALLOW_THREADS;
-    err = self->db->set_q_extentsize(self->db, extentsize);
+    err = self->db->get_re_source(self->db, &source);
     MYDB_END_ALLOW_THREADS;
     RETURN_IF_ERR();
-    RETURN_NONE();
+    return PyBytes_FromString(source);
 }
 
 static PyObject*
@@ -2711,8 +3152,6 @@ DB_stat(DBObject* self, PyObject* args,
     MYDB_END_ALLOW_THREADS;
     RETURN_IF_ERR();
 
-    self->haveStat = 1;
-
     /* Turn the stat structure into a dictionary */
     type = _DB_get_type(self);
     if ((type == -1) || ((d = PyDict_New()) == NULL)) {
@@ -2734,9 +3173,6 @@ DB_stat(DBObject* self, PyObject* args,
         MAKE_HASH_ENTRY(pagecnt);
 #endif
         MAKE_HASH_ENTRY(pagesize);
-#if (DBVER < 41)
-        MAKE_HASH_ENTRY(nelem);
-#endif
         MAKE_HASH_ENTRY(ffactor);
         MAKE_HASH_ENTRY(buckets);
         MAKE_HASH_ENTRY(free);
@@ -2783,9 +3219,7 @@ DB_stat(DBObject* self, PyObject* args,
         MAKE_QUEUE_ENTRY(nkeys);
         MAKE_QUEUE_ENTRY(ndata);
         MAKE_QUEUE_ENTRY(pagesize);
-#if (DBVER >= 41)
         MAKE_QUEUE_ENTRY(extentsize);
-#endif
         MAKE_QUEUE_ENTRY(pages);
         MAKE_QUEUE_ENTRY(re_len);
         MAKE_QUEUE_ENTRY(re_pad);
@@ -2811,12 +3245,35 @@ DB_stat(DBObject* self, PyObject* args,
     return d;
 }
 
+#if (DBVER >= 43)
 static PyObject*
-DB_sync(DBObject* self, PyObject* args)
+DB_stat_print(DBObject* self, PyObject* args, PyObject *kwargs)
 {
     int err;
-    int flags = 0;
-
+    int flags=0;
+    static char* kwnames[] = { "flags", NULL };
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:stat_print",
+                kwnames, &flags))
+    {
+        return NULL;
+    }
+    CHECK_DB_NOT_CLOSED(self);
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->stat_print(self->db, flags);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+#endif
+
+
+static PyObject*
+DB_sync(DBObject* self, PyObject* args)
+{
+    int err;
+    int flags = 0;
+
     if (!PyArg_ParseTuple(args,"|i:sync", &flags ))
         return NULL;
     CHECK_DB_NOT_CLOSED(self);
@@ -2896,7 +3353,7 @@ DB_verify(DBObject* self, PyObject* args
         PyObject *error;
 
         error=DB_close_internal(self, 0, 1);
-        if (error ) {
+        if (error) {
           return error;
         }
      }
@@ -2934,7 +3391,6 @@ DB_set_get_returns_none(DBObject* self,
     return NUMBER_FromLong(oldValue);
 }
 
-#if (DBVER >= 41)
 static PyObject*
 DB_set_encrypt(DBObject* self, PyObject* args, PyObject* kwargs)
 {
@@ -2955,7 +3411,22 @@ DB_set_encrypt(DBObject* self, PyObject*
     RETURN_IF_ERR();
     RETURN_NONE();
 }
-#endif /* DBVER >= 41 */
+
+static PyObject*
+DB_get_encrypt_flags(DBObject* self)
+{
+    int err;
+    u_int32_t flags;
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->get_encrypt_flags(self->db, &flags);
+    MYDB_END_ALLOW_THREADS;
+
+    RETURN_IF_ERR();
+
+    return NUMBER_FromLong(flags);
+}
+
 
 
 /*-------------------------------------------------------------- */
@@ -2965,7 +3436,6 @@ Py_ssize_t DB_length(PyObject* _self)
 {
     int err;
     Py_ssize_t size = 0;
-    int flags = 0;
     void* sp;
     DBObject* self = (DBObject*)_self;
 
@@ -2978,41 +3448,21 @@ Py_ssize_t DB_length(PyObject* _self)
         return -1;
     }
 
-    if (self->haveStat) {  /* Has the stat function been called recently?  If
-                              so, we can use the cached value. */
-        flags = DB_FAST_STAT;
-    }
-
     MYDB_BEGIN_ALLOW_THREADS;
-redo_stat_for_length:
 #if (DBVER >= 43)
-    err = self->db->stat(self->db, /*txnid*/ NULL, &sp, flags);
+    err = self->db->stat(self->db, /*txnid*/ NULL, &sp, 0);
 #else
-    err = self->db->stat(self->db, &sp, flags);
+    err = self->db->stat(self->db, &sp, 0);
 #endif
+    MYDB_END_ALLOW_THREADS;
 
     /* All the stat structures have matching fields upto the ndata field,
        so we can use any of them for the type cast */
     size = ((DB_BTREE_STAT*)sp)->bt_ndata;
 
-    /* A size of 0 could mean that Berkeley DB no longer had the stat values cached.
-     * redo a full stat to make sure.
-     *   Fixes SF python bug 1493322, pybsddb bug 1184012
-     */
-    if (size == 0 && (flags & DB_FAST_STAT)) {
-        flags = 0;
-        if (!err)
-            free(sp);
-        goto redo_stat_for_length;
-    }
-
-    MYDB_END_ALLOW_THREADS;
-
     if (err)
         return -1;
 
-    self->haveStat = 1;
-
     free(sp);
     return size;
 }
@@ -3101,18 +3551,11 @@ DB_ass_sub(DBObject* self, PyObject* key
 
 
 static PyObject*
-DB_has_key(DBObject* self, PyObject* args, PyObject* kwargs)
+_DB_has_key(DBObject* self, PyObject* keyobj, PyObject* txnobj)
 {
     int err;
-    PyObject* keyobj;
-    DBT key, data;
-    PyObject* txnobj = NULL;
+    DBT key;
     DB_TXN *txn = NULL;
-    static char* kwnames[] = {"key","txn", NULL};
-
-    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O:has_key", kwnames,
-                &keyobj, &txnobj))
-        return NULL;
 
     CHECK_DB_NOT_CLOSED(self);
     if (!make_key_dbt(self, keyobj, &key, NULL))
@@ -3122,28 +3565,77 @@ DB_has_key(DBObject* self, PyObject* arg
         return NULL;
     }
 
+#if (DBVER < 46)
     /* This causes DB_BUFFER_SMALL to be returned when the db has the key because
        it has a record but can't allocate a buffer for the data.  This saves
        having to deal with data we won't be using.
      */
-    CLEAR_DBT(data);
-    data.flags = DB_DBT_USERMEM;
+    {
+        DBT data ;
+        CLEAR_DBT(data);
+        data.flags = DB_DBT_USERMEM;
 
+        MYDB_BEGIN_ALLOW_THREADS;
+        err = self->db->get(self->db, txn, &key, &data, 0);
+        MYDB_END_ALLOW_THREADS;
+    }
+#else
     MYDB_BEGIN_ALLOW_THREADS;
-    err = self->db->get(self->db, txn, &key, &data, 0);
+    err = self->db->exists(self->db, txn, &key, 0);
     MYDB_END_ALLOW_THREADS;
+#endif
+
     FREE_DBT(key);
 
+    /*
+    ** DB_BUFFER_SMALL is only used if we use "get".
+    ** We can drop it when we only use "exists",
+    ** when we drop suport for Berkeley DB < 4.6.
+    */
     if (err == DB_BUFFER_SMALL || err == 0) {
-        return NUMBER_FromLong(1);
+        Py_INCREF(Py_True);
+        return Py_True;
     } else if (err == DB_NOTFOUND || err == DB_KEYEMPTY) {
-        return NUMBER_FromLong(0);
+        Py_INCREF(Py_False);
+        return Py_False;
     }
 
     makeDBError(err);
     return NULL;
 }
 
+static PyObject*
+DB_has_key(DBObject* self, PyObject* args, PyObject* kwargs)
+{
+    PyObject* keyobj;
+    PyObject* txnobj = NULL;
+    static char* kwnames[] = {"key","txn", NULL};
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O:has_key", kwnames,
+                &keyobj, &txnobj))
+        return NULL;
+
+    return _DB_has_key(self, keyobj, txnobj);
+}
+
+
+static int DB_contains(DBObject* self, PyObject* keyobj)
+{
+    PyObject* result;
+    int result2 = 0;
+
+    result = _DB_has_key(self, keyobj, NULL) ;
+    if (result == NULL) {
+        return -1; /* Propague exception */
+    }
+    if (result != Py_False) {
+        result2 = 1;
+    }
+
+    Py_DECREF(result);
+    return result2;
+}
+
 
 #define _KEYS_LIST      1
 #define _VALUES_LIST    2
@@ -3297,6 +3789,116 @@ DB_values(DBObject* self, PyObject* args
 }
 
 /* --------------------------------------------------------------------- */
+/* DBLogCursor methods */
+
+
+static PyObject*
+DBLogCursor_close_internal(DBLogCursorObject* self)
+{
+    int err = 0;
+
+    if (self->logc != NULL) {
+        EXTRACT_FROM_DOUBLE_LINKED_LIST(self);
+
+        MYDB_BEGIN_ALLOW_THREADS;
+        err = self->logc->close(self->logc, 0);
+        MYDB_END_ALLOW_THREADS;
+        self->logc = NULL;
+    }
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DBLogCursor_close(DBLogCursorObject* self)
+{
+    return DBLogCursor_close_internal(self);
+}
+
+
+static PyObject*
+_DBLogCursor_get(DBLogCursorObject* self, int flag, DB_LSN *lsn2)
+{
+    int err;
+    DBT data;
+    DB_LSN lsn = {0, 0};
+    PyObject *dummy, *retval;
+
+    CLEAR_DBT(data);
+    data.flags = DB_DBT_MALLOC; /* Berkeley DB must do the malloc */
+
+    CHECK_LOGCURSOR_NOT_CLOSED(self);
+
+    if (lsn2)
+        lsn = *lsn2;
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->logc->get(self->logc, &lsn, &data, flag);
+    MYDB_END_ALLOW_THREADS;
+
+    if (err == DB_NOTFOUND) {
+        Py_INCREF(Py_None);
+        retval = Py_None;
+    }
+    else if (makeDBError(err)) {
+        retval = NULL;
+    }
+    else {
+        retval = dummy = BuildValue_S(data.data, data.size);
+        if (dummy) {
+            retval = Py_BuildValue("(ii)O", lsn.file, lsn.offset, dummy);
+            Py_DECREF(dummy);
+        }
+    }
+
+    FREE_DBT(data);
+    return retval;
+}
+
+static PyObject*
+DBLogCursor_current(DBLogCursorObject* self)
+{
+    return _DBLogCursor_get(self, DB_CURRENT, NULL);
+}
+
+static PyObject*
+DBLogCursor_first(DBLogCursorObject* self)
+{
+    return _DBLogCursor_get(self, DB_FIRST, NULL);
+}
+
+static PyObject*
+DBLogCursor_last(DBLogCursorObject* self)
+{
+    return _DBLogCursor_get(self, DB_LAST, NULL);
+}
+
+static PyObject*
+DBLogCursor_next(DBLogCursorObject* self)
+{
+    return _DBLogCursor_get(self, DB_NEXT, NULL);
+}
+
+static PyObject*
+DBLogCursor_prev(DBLogCursorObject* self)
+{
+    return _DBLogCursor_get(self, DB_PREV, NULL);
+}
+
+static PyObject*
+DBLogCursor_set(DBLogCursorObject* self, PyObject* args)
+{
+    DB_LSN lsn;
+
+    if (!PyArg_ParseTuple(args, "(ii):set", &lsn.file, &lsn.offset))
+        return NULL;
+
+    return _DBLogCursor_get(self, DB_SET, &lsn);
+}
+
+
+
+/* --------------------------------------------------------------------- */
 /* DBCursor methods */
 
 
@@ -3371,7 +3973,6 @@ DBC_delete(DBCursorObject* self, PyObjec
     MYDB_END_ALLOW_THREADS;
     RETURN_IF_ERR();
 
-    self->mydb->haveStat = 0;
     RETURN_NONE();
 }
 
@@ -3659,7 +4260,6 @@ DBC_put(DBCursorObject* self, PyObject*
     MYDB_END_ALLOW_THREADS;
     FREE_DBT(key);  /* 'make_key_dbt' could do a 'malloc' */
     RETURN_IF_ERR();
-    self->mydb->haveStat = 0;
     RETURN_NONE();
 }
 
@@ -3974,6 +4574,13 @@ DBC_next_nodup(DBCursorObject* self, PyO
     return _DBCursor_get(self,DB_NEXT_NODUP,args,kwargs,"|iii:next_nodup");
 }
 
+#if (DBVER >= 46)
+static PyObject*
+DBC_prev_dup(DBCursorObject* self, PyObject* args, PyObject *kwargs)
+{
+    return _DBCursor_get(self,DB_PREV_DUP,args,kwargs,"|iii:prev_dup");
+}
+#endif
 
 static PyObject*
 DBC_prev_nodup(DBCursorObject* self, PyObject* args, PyObject *kwargs)
@@ -4016,6 +4623,44 @@ DBC_join_item(DBCursorObject* self, PyOb
 }
 
 
+#if (DBVER >= 46)
+static PyObject*
+DBC_set_priority(DBCursorObject* self, PyObject* args, PyObject* kwargs)
+{
+    int err, priority;
+    static char* kwnames[] = { "priority", NULL };
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "i:set_priority", kwnames,
+                                     &priority))
+        return NULL;
+
+    CHECK_CURSOR_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->dbc->set_priority(self->dbc, priority);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+
+static PyObject*
+DBC_get_priority(DBCursorObject* self)
+{
+    int err;
+    DB_CACHE_PRIORITY priority;
+
+    CHECK_CURSOR_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->dbc->get_priority(self->dbc, &priority);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(priority);
+}
+#endif
+
+
 
 /* --------------------------------------------------------------------- */
 /* DBEnv methods */
@@ -4029,12 +4674,16 @@ DBEnv_close_internal(DBEnvObject* self,
 
     if (!self->closed) {      /* Don't close more than once */
         while(self->children_txns) {
-          dummy=DBTxn_abort_discard_internal(self->children_txns,0);
-          Py_XDECREF(dummy);
+            dummy = DBTxn_abort_discard_internal(self->children_txns, 0);
+            Py_XDECREF(dummy);
         }
         while(self->children_dbs) {
-          dummy=DB_close_internal(self->children_dbs, 0, 0);
-          Py_XDECREF(dummy);
+            dummy = DB_close_internal(self->children_dbs, 0, 0);
+            Py_XDECREF(dummy);
+        }
+        while(self->children_logcursors) {
+            dummy = DBLogCursor_close_internal(self->children_logcursors);
+            Py_XDECREF(dummy);
         }
     }
 
@@ -4084,24 +4733,212 @@ DBEnv_open(DBEnvObject* self, PyObject*
 
 
 static PyObject*
-DBEnv_remove(DBEnvObject* self, PyObject* args)
+DBEnv_memp_stat(DBEnvObject* self, PyObject* args, PyObject *kwargs)
 {
-    int err, flags=0;
-    char *db_home;
+    int err;
+    DB_MPOOL_STAT *gsp;
+    DB_MPOOL_FSTAT **fsp, **fsp2;
+    PyObject* d = NULL, *d2, *d3, *r;
+    u_int32_t flags = 0;
+    static char* kwnames[] = { "flags", NULL };
 
-    if (!PyArg_ParseTuple(args, "s|i:remove", &db_home, &flags))
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:memp_stat",
+                kwnames, &flags))
         return NULL;
+
     CHECK_ENV_NOT_CLOSED(self);
+
     MYDB_BEGIN_ALLOW_THREADS;
-    err = self->db_env->remove(self->db_env, db_home, flags);
+    err = self->db_env->memp_stat(self->db_env, &gsp, &fsp, flags);
     MYDB_END_ALLOW_THREADS;
     RETURN_IF_ERR();
-    RETURN_NONE();
+
+    /* Turn the stat structure into a dictionary */
+    d = PyDict_New();
+    if (d == NULL) {
+        if (gsp)
+            free(gsp);
+        return NULL;
+    }
+
+#define MAKE_ENTRY(name)  _addIntToDict(d, #name, gsp->st_##name)
+
+    MAKE_ENTRY(gbytes);
+    MAKE_ENTRY(ncache);
+#if (DBVER >= 46)
+    MAKE_ENTRY(max_ncache);
+#endif
+    MAKE_ENTRY(regsize);
+#if (DBVER >= 43)
+    MAKE_ENTRY(mmapsize);
+    MAKE_ENTRY(maxopenfd);
+    MAKE_ENTRY(maxwrite);
+    MAKE_ENTRY(maxwrite_sleep);
+#endif
+    MAKE_ENTRY(map);
+    MAKE_ENTRY(cache_hit);
+    MAKE_ENTRY(cache_miss);
+    MAKE_ENTRY(page_create);
+    MAKE_ENTRY(page_in);
+    MAKE_ENTRY(page_out);
+    MAKE_ENTRY(ro_evict);
+    MAKE_ENTRY(rw_evict);
+    MAKE_ENTRY(page_trickle);
+    MAKE_ENTRY(pages);
+    MAKE_ENTRY(page_clean);
+    MAKE_ENTRY(page_dirty);
+    MAKE_ENTRY(hash_buckets);
+    MAKE_ENTRY(hash_searches);
+    MAKE_ENTRY(hash_longest);
+    MAKE_ENTRY(hash_examined);
+    MAKE_ENTRY(hash_nowait);
+    MAKE_ENTRY(hash_wait);
+#if (DBVER >= 45)
+    MAKE_ENTRY(hash_max_nowait);
+#endif
+    MAKE_ENTRY(hash_max_wait);
+    MAKE_ENTRY(region_wait);
+    MAKE_ENTRY(region_nowait);
+#if (DBVER >= 45)
+    MAKE_ENTRY(mvcc_frozen);
+    MAKE_ENTRY(mvcc_thawed);
+    MAKE_ENTRY(mvcc_freed);
+#endif
+    MAKE_ENTRY(alloc);
+    MAKE_ENTRY(alloc_buckets);
+    MAKE_ENTRY(alloc_max_buckets);
+    MAKE_ENTRY(alloc_pages);
+    MAKE_ENTRY(alloc_max_pages);
+#if (DBVER >= 45)
+    MAKE_ENTRY(io_wait);
+#endif
+#if (DBVER >= 48)
+    MAKE_ENTRY(sync_interrupted);
+#endif
+
+#undef MAKE_ENTRY
+    free(gsp);
+
+    d2 = PyDict_New();
+    if (d2 == NULL) {
+        Py_DECREF(d);
+        if (fsp)
+            free(fsp);
+        return NULL;
+    }
+#define MAKE_ENTRY(name)  _addIntToDict(d3, #name, (*fsp2)->st_##name)
+    for(fsp2=fsp;*fsp2; fsp2++) {
+        d3 = PyDict_New();
+        if (d3 == NULL) {
+            Py_DECREF(d);
+            Py_DECREF(d2);
+            if (fsp)
+                free(fsp);
+            return NULL;
+        }
+        MAKE_ENTRY(pagesize);
+        MAKE_ENTRY(cache_hit);
+        MAKE_ENTRY(cache_miss);
+        MAKE_ENTRY(map);
+        MAKE_ENTRY(page_create);
+        MAKE_ENTRY(page_in);
+        MAKE_ENTRY(page_out);
+        if(PyDict_SetItemString(d2, (*fsp2)->file_name, d3)) {
+            Py_DECREF(d);
+            Py_DECREF(d2);
+            Py_DECREF(d3);
+            if (fsp)
+                free(fsp);
+            return NULL;
+        }
+        Py_DECREF(d3);
+    }
+
+#undef MAKE_ENTRY
+    free(fsp);
+
+    r = Py_BuildValue("(OO)", d, d2);
+    Py_DECREF(d);
+    Py_DECREF(d2);
+    return r;
 }
 
-#if (DBVER >= 41)
+#if (DBVER >= 43)
 static PyObject*
-DBEnv_dbremove(DBEnvObject* self, PyObject* args, PyObject* kwargs)
+DBEnv_memp_stat_print(DBEnvObject* self, PyObject* args, PyObject *kwargs)
+{
+    int err;
+    int flags=0;
+    static char* kwnames[] = { "flags", NULL };
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:memp_stat_print",
+                kwnames, &flags))
+    {
+        return NULL;
+    }
+    CHECK_ENV_NOT_CLOSED(self);
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->memp_stat_print(self->db_env, flags);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+#endif
+
+
+static PyObject*
+DBEnv_memp_trickle(DBEnvObject* self, PyObject* args)
+{
+    int err, percent, nwrotep;
+
+    if (!PyArg_ParseTuple(args, "i:memp_trickle", &percent))
+        return NULL;
+    CHECK_ENV_NOT_CLOSED(self);
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->memp_trickle(self->db_env, percent, &nwrotep);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(nwrotep);
+}
+
+static PyObject*
+DBEnv_memp_sync(DBEnvObject* self, PyObject* args)
+{
+    int err;
+    DB_LSN lsn = {0, 0};
+    DB_LSN *lsn_p = NULL;
+
+    if (!PyArg_ParseTuple(args, "|(ii):memp_sync", &lsn.file, &lsn.offset))
+        return NULL;
+    if ((lsn.file!=0) || (lsn.offset!=0)) {
+        lsn_p = &lsn;
+    }
+    CHECK_ENV_NOT_CLOSED(self);
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->memp_sync(self->db_env, lsn_p);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DBEnv_remove(DBEnvObject* self, PyObject* args)
+{
+    int err, flags=0;
+    char *db_home;
+
+    if (!PyArg_ParseTuple(args, "s|i:remove", &db_home, &flags))
+        return NULL;
+    CHECK_ENV_NOT_CLOSED(self);
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->remove(self->db_env, db_home, flags);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DBEnv_dbremove(DBEnvObject* self, PyObject* args, PyObject* kwargs)
 {
     int err;
     u_int32_t flags=0;
@@ -4121,78 +4958,451 @@ DBEnv_dbremove(DBEnvObject* self, PyObje
     }
     CHECK_ENV_NOT_CLOSED(self);
     MYDB_BEGIN_ALLOW_THREADS;
-    err = self->db_env->dbremove(self->db_env, txn, file, database, flags);
+    err = self->db_env->dbremove(self->db_env, txn, file, database, flags);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DBEnv_dbrename(DBEnvObject* self, PyObject* args, PyObject* kwargs)
+{
+    int err;
+    u_int32_t flags=0;
+    char *file = NULL;
+    char *database = NULL;
+    char *newname = NULL;
+    PyObject *txnobj = NULL;
+    DB_TXN *txn = NULL;
+    static char* kwnames[] = { "file", "database", "newname", "txn",
+                                     "flags", NULL };
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "szs|Oi:dbrename", kwnames,
+                &file, &database, &newname, &txnobj, &flags)) {
+        return NULL;
+    }
+    if (!checkTxnObj(txnobj, &txn)) {
+        return NULL;
+    }
+    CHECK_ENV_NOT_CLOSED(self);
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->dbrename(self->db_env, txn, file, database, newname,
+                                 flags);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+
+
+static PyObject*
+DBEnv_set_encrypt(DBEnvObject* self, PyObject* args, PyObject* kwargs)
+{
+    int err;
+    u_int32_t flags=0;
+    char *passwd = NULL;
+    static char* kwnames[] = { "passwd", "flags", NULL };
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s|i:set_encrypt", kwnames,
+                &passwd, &flags)) {
+        return NULL;
+    }
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->set_encrypt(self->db_env, passwd, flags);
+    MYDB_END_ALLOW_THREADS;
+
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DBEnv_get_encrypt_flags(DBEnvObject* self)
+{
+    int err;
+    u_int32_t flags;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_encrypt_flags(self->db_env, &flags);
+    MYDB_END_ALLOW_THREADS;
+
+    RETURN_IF_ERR();
+
+    return NUMBER_FromLong(flags);
+}
+
+static PyObject*
+DBEnv_get_timeout(DBEnvObject* self, PyObject* args, PyObject* kwargs)
+{
+    int err;
+    int flag;
+    u_int32_t timeout;
+    static char* kwnames[] = {"flag", NULL };
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "i:get_timeout", kwnames,
+                &flag)) {
+        return NULL;
+    }
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_timeout(self->db_env, &timeout, flag);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(timeout);
+}
+
+
+static PyObject*
+DBEnv_set_timeout(DBEnvObject* self, PyObject* args, PyObject* kwargs)
+{
+    int err;
+    u_int32_t flags=0;
+    u_int32_t timeout = 0;
+    static char* kwnames[] = { "timeout", "flags", NULL };
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ii:set_timeout", kwnames,
+                &timeout, &flags)) {
+        return NULL;
+    }
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->set_timeout(self->db_env, (db_timeout_t)timeout, flags);
+    MYDB_END_ALLOW_THREADS;
+
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DBEnv_set_shm_key(DBEnvObject* self, PyObject* args)
+{
+    int err;
+    long shm_key = 0;
+
+    if (!PyArg_ParseTuple(args, "l:set_shm_key", &shm_key))
+        return NULL;
+    CHECK_ENV_NOT_CLOSED(self);
+
+    err = self->db_env->set_shm_key(self->db_env, shm_key);
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DBEnv_get_shm_key(DBEnvObject* self)
+{
+    int err;
+    long shm_key;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_shm_key(self->db_env, &shm_key);
+    MYDB_END_ALLOW_THREADS;
+
+    RETURN_IF_ERR();
+
+    return NUMBER_FromLong(shm_key);
+}
+
+#if (DBVER >= 46)
+static PyObject*
+DBEnv_set_cache_max(DBEnvObject* self, PyObject* args)
+{
+    int err, gbytes, bytes;
+
+    if (!PyArg_ParseTuple(args, "ii:set_cache_max",
+                          &gbytes, &bytes))
+        return NULL;
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->set_cache_max(self->db_env, gbytes, bytes);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DBEnv_get_cache_max(DBEnvObject* self)
+{
+    int err;
+    u_int32_t gbytes, bytes;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_cache_max(self->db_env, &gbytes, &bytes);
+    MYDB_END_ALLOW_THREADS;
+
+    RETURN_IF_ERR();
+
+    return Py_BuildValue("(ii)", gbytes, bytes);
+}
+#endif
+
+#if (DBVER >= 46)
+static PyObject*
+DBEnv_set_thread_count(DBEnvObject* self, PyObject* args)
+{
+    int err;
+    u_int32_t count;
+
+    if (!PyArg_ParseTuple(args, "i:set_thread_count", &count))
+        return NULL;
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->set_thread_count(self->db_env, count);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DBEnv_get_thread_count(DBEnvObject* self)
+{
+    int err;
+    u_int32_t count;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_thread_count(self->db_env, &count);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(count);
+}
+#endif
+
+static PyObject*
+DBEnv_set_cachesize(DBEnvObject* self, PyObject* args)
+{
+    int err, gbytes=0, bytes=0, ncache=0;
+
+    if (!PyArg_ParseTuple(args, "ii|i:set_cachesize",
+                          &gbytes, &bytes, &ncache))
+        return NULL;
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->set_cachesize(self->db_env, gbytes, bytes, ncache);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DBEnv_get_cachesize(DBEnvObject* self)
+{
+    int err;
+    u_int32_t gbytes, bytes;
+    int ncache;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_cachesize(self->db_env, &gbytes, &bytes, &ncache);
+    MYDB_END_ALLOW_THREADS;
+
+    RETURN_IF_ERR();
+
+    return Py_BuildValue("(iii)", gbytes, bytes, ncache);
+}
+
+
+static PyObject*
+DBEnv_set_flags(DBEnvObject* self, PyObject* args)
+{
+    int err, flags=0, onoff=0;
+
+    if (!PyArg_ParseTuple(args, "ii:set_flags",
+                          &flags, &onoff))
+        return NULL;
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->set_flags(self->db_env, flags, onoff);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DBEnv_get_flags(DBEnvObject* self)
+{
+    int err;
+    u_int32_t flags;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_flags(self->db_env, &flags);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(flags);
+}
+
+#if (DBVER >= 47)
+static PyObject*
+DBEnv_log_set_config(DBEnvObject* self, PyObject* args)
+{
+    int err, flags, onoff;
+
+    if (!PyArg_ParseTuple(args, "ii:log_set_config",
+                          &flags, &onoff))
+        return NULL;
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->log_set_config(self->db_env, flags, onoff);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DBEnv_log_get_config(DBEnvObject* self, PyObject* args)
+{
+    int err, flag, onoff;
+
+    if (!PyArg_ParseTuple(args, "i:log_get_config", &flag))
+        return NULL;
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->log_get_config(self->db_env, flag, &onoff);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return PyBool_FromLong(onoff);
+}
+#endif /* DBVER >= 47 */
+
+#if (DBVER >= 44)
+static PyObject*
+DBEnv_mutex_set_max(DBEnvObject* self, PyObject* args)
+{
+    int err;
+    int value;
+
+    if (!PyArg_ParseTuple(args, "i:mutex_set_max", &value))
+        return NULL;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->mutex_set_max(self->db_env, value);
+    MYDB_END_ALLOW_THREADS;
+
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DBEnv_mutex_get_max(DBEnvObject* self)
+{
+    int err;
+    u_int32_t value;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->mutex_get_max(self->db_env, &value);
+    MYDB_END_ALLOW_THREADS;
+
+    RETURN_IF_ERR();
+
+    return NUMBER_FromLong(value);
+}
+
+static PyObject*
+DBEnv_mutex_set_align(DBEnvObject* self, PyObject* args)
+{
+    int err;
+    int align;
+
+    if (!PyArg_ParseTuple(args, "i:mutex_set_align", &align))
+        return NULL;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->mutex_set_align(self->db_env, align);
+    MYDB_END_ALLOW_THREADS;
+
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DBEnv_mutex_get_align(DBEnvObject* self)
+{
+    int err;
+    u_int32_t align;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->mutex_get_align(self->db_env, &align);
     MYDB_END_ALLOW_THREADS;
+
     RETURN_IF_ERR();
-    RETURN_NONE();
+
+    return NUMBER_FromLong(align);
 }
 
 static PyObject*
-DBEnv_dbrename(DBEnvObject* self, PyObject* args, PyObject* kwargs)
+DBEnv_mutex_set_increment(DBEnvObject* self, PyObject* args)
 {
     int err;
-    u_int32_t flags=0;
-    char *file = NULL;
-    char *database = NULL;
-    char *newname = NULL;
-    PyObject *txnobj = NULL;
-    DB_TXN *txn = NULL;
-    static char* kwnames[] = { "file", "database", "newname", "txn",
-                                     "flags", NULL };
+    int increment;
 
-    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "szs|Oi:dbrename", kwnames,
-                &file, &database, &newname, &txnobj, &flags)) {
-        return NULL;
-    }
-    if (!checkTxnObj(txnobj, &txn)) {
+    if (!PyArg_ParseTuple(args, "i:mutex_set_increment", &increment))
         return NULL;
-    }
+
     CHECK_ENV_NOT_CLOSED(self);
+
     MYDB_BEGIN_ALLOW_THREADS;
-    err = self->db_env->dbrename(self->db_env, txn, file, database, newname,
-                                 flags);
+    err = self->db_env->mutex_set_increment(self->db_env, increment);
     MYDB_END_ALLOW_THREADS;
+
     RETURN_IF_ERR();
     RETURN_NONE();
 }
 
 static PyObject*
-DBEnv_set_encrypt(DBEnvObject* self, PyObject* args, PyObject* kwargs)
+DBEnv_mutex_get_increment(DBEnvObject* self)
 {
     int err;
-    u_int32_t flags=0;
-    char *passwd = NULL;
-    static char* kwnames[] = { "passwd", "flags", NULL };
+    u_int32_t increment;
 
-    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s|i:set_encrypt", kwnames,
-                &passwd, &flags)) {
-        return NULL;
-    }
+    CHECK_ENV_NOT_CLOSED(self);
 
     MYDB_BEGIN_ALLOW_THREADS;
-    err = self->db_env->set_encrypt(self->db_env, passwd, flags);
+    err = self->db_env->mutex_get_increment(self->db_env, &increment);
     MYDB_END_ALLOW_THREADS;
 
     RETURN_IF_ERR();
-    RETURN_NONE();
+
+    return NUMBER_FromLong(increment);
 }
-#endif /* DBVER >= 41 */
 
 static PyObject*
-DBEnv_set_timeout(DBEnvObject* self, PyObject* args, PyObject* kwargs)
+DBEnv_mutex_set_tas_spins(DBEnvObject* self, PyObject* args)
 {
     int err;
-    u_int32_t flags=0;
-    u_int32_t timeout = 0;
-    static char* kwnames[] = { "timeout", "flags", NULL };
+    int tas_spins;
 
-    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ii:set_timeout", kwnames,
-                &timeout, &flags)) {
+    if (!PyArg_ParseTuple(args, "i:mutex_set_tas_spins", &tas_spins))
         return NULL;
-    }
+
+    CHECK_ENV_NOT_CLOSED(self);
 
     MYDB_BEGIN_ALLOW_THREADS;
-    err = self->db_env->set_timeout(self->db_env, (db_timeout_t)timeout, flags);
+    err = self->db_env->mutex_set_tas_spins(self->db_env, tas_spins);
     MYDB_END_ALLOW_THREADS;
 
     RETURN_IF_ERR();
@@ -4200,93 +5410,111 @@ DBEnv_set_timeout(DBEnvObject* self, PyO
 }
 
 static PyObject*
-DBEnv_set_shm_key(DBEnvObject* self, PyObject* args)
+DBEnv_mutex_get_tas_spins(DBEnvObject* self)
 {
     int err;
-    long shm_key = 0;
+    u_int32_t tas_spins;
 
-    if (!PyArg_ParseTuple(args, "l:set_shm_key", &shm_key))
-        return NULL;
     CHECK_ENV_NOT_CLOSED(self);
 
-    err = self->db_env->set_shm_key(self->db_env, shm_key);
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->mutex_get_tas_spins(self->db_env, &tas_spins);
+    MYDB_END_ALLOW_THREADS;
+
     RETURN_IF_ERR();
-    RETURN_NONE();
+
+    return NUMBER_FromLong(tas_spins);
 }
+#endif
 
 static PyObject*
-DBEnv_set_cachesize(DBEnvObject* self, PyObject* args)
+DBEnv_set_data_dir(DBEnvObject* self, PyObject* args)
 {
-    int err, gbytes=0, bytes=0, ncache=0;
+    int err;
+    char *dir;
 
-    if (!PyArg_ParseTuple(args, "ii|i:set_cachesize",
-                          &gbytes, &bytes, &ncache))
+    if (!PyArg_ParseTuple(args, "s:set_data_dir", &dir))
         return NULL;
     CHECK_ENV_NOT_CLOSED(self);
 
     MYDB_BEGIN_ALLOW_THREADS;
-    err = self->db_env->set_cachesize(self->db_env, gbytes, bytes, ncache);
+    err = self->db_env->set_data_dir(self->db_env, dir);
     MYDB_END_ALLOW_THREADS;
     RETURN_IF_ERR();
     RETURN_NONE();
 }
 
-
 static PyObject*
-DBEnv_set_flags(DBEnvObject* self, PyObject* args)
+DBEnv_get_data_dirs(DBEnvObject* self)
 {
-    int err, flags=0, onoff=0;
+    int err;
+    PyObject *tuple;
+    PyObject *item;
+    const char **dirpp;
+    int size, i;
 
-    if (!PyArg_ParseTuple(args, "ii:set_flags",
-                          &flags, &onoff))
-        return NULL;
     CHECK_ENV_NOT_CLOSED(self);
 
     MYDB_BEGIN_ALLOW_THREADS;
-    err = self->db_env->set_flags(self->db_env, flags, onoff);
+    err = self->db_env->get_data_dirs(self->db_env, &dirpp);
     MYDB_END_ALLOW_THREADS;
+
     RETURN_IF_ERR();
-    RETURN_NONE();
-}
 
+    /*
+    ** Calculate size. Python C API
+    ** actually allows for tuple resizing,
+    ** but this is simple enough.
+    */
+    for (size=0; *(dirpp+size) ; size++);
+
+    tuple = PyTuple_New(size);
+    if (!tuple)
+        return NULL;
 
-#if (DBVER >= 47)
+    for (i=0; i<size; i++) {
+        item = PyBytes_FromString (*(dirpp+i));
+        if (item == NULL) {
+            Py_DECREF(tuple);
+            tuple = NULL;
+            break;
+        }
+        PyTuple_SET_ITEM(tuple, i, item);
+    }
+    return tuple;
+}
+
+#if (DBVER >= 44)
 static PyObject*
-DBEnv_log_set_config(DBEnvObject* self, PyObject* args)
+DBEnv_set_lg_filemode(DBEnvObject* self, PyObject* args)
 {
-    int err, flags, onoff;
+    int err, filemode;
 
-    if (!PyArg_ParseTuple(args, "ii:log_set_config",
-                          &flags, &onoff))
+    if (!PyArg_ParseTuple(args, "i:set_lg_filemode", &filemode))
         return NULL;
     CHECK_ENV_NOT_CLOSED(self);
 
     MYDB_BEGIN_ALLOW_THREADS;
-    err = self->db_env->log_set_config(self->db_env, flags, onoff);
+    err = self->db_env->set_lg_filemode(self->db_env, filemode);
     MYDB_END_ALLOW_THREADS;
     RETURN_IF_ERR();
     RETURN_NONE();
 }
-#endif /* DBVER >= 47 */
-
 
 static PyObject*
-DBEnv_set_data_dir(DBEnvObject* self, PyObject* args)
+DBEnv_get_lg_filemode(DBEnvObject* self)
 {
-    int err;
-    char *dir;
+    int err, filemode;
 
-    if (!PyArg_ParseTuple(args, "s:set_data_dir", &dir))
-        return NULL;
     CHECK_ENV_NOT_CLOSED(self);
 
     MYDB_BEGIN_ALLOW_THREADS;
-    err = self->db_env->set_data_dir(self->db_env, dir);
+    err = self->db_env->get_lg_filemode(self->db_env, &filemode);
     MYDB_END_ALLOW_THREADS;
     RETURN_IF_ERR();
-    RETURN_NONE();
+    return NUMBER_FromLong(filemode);
 }
-
+#endif
 
 static PyObject*
 DBEnv_set_lg_bsize(DBEnvObject* self, PyObject* args)
@@ -4304,6 +5532,20 @@ DBEnv_set_lg_bsize(DBEnvObject* self, Py
     RETURN_NONE();
 }
 
+static PyObject*
+DBEnv_get_lg_bsize(DBEnvObject* self)
+{
+    int err;
+    u_int32_t lg_bsize;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_lg_bsize(self->db_env, &lg_bsize);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(lg_bsize);
+}
 
 static PyObject*
 DBEnv_set_lg_dir(DBEnvObject* self, PyObject* args)
@@ -4323,6 +5565,21 @@ DBEnv_set_lg_dir(DBEnvObject* self, PyOb
 }
 
 static PyObject*
+DBEnv_get_lg_dir(DBEnvObject* self)
+{
+    int err;
+    const char *dirp;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_lg_dir(self->db_env, &dirp);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return PyBytes_FromString(dirp);
+}
+
+static PyObject*
 DBEnv_set_lg_max(DBEnvObject* self, PyObject* args)
 {
     int err, lg_max;
@@ -4338,7 +5595,6 @@ DBEnv_set_lg_max(DBEnvObject* self, PyOb
     RETURN_NONE();
 }
 
-#if (DBVER >= 42)
 static PyObject*
 DBEnv_get_lg_max(DBEnvObject* self)
 {
@@ -4353,8 +5609,6 @@ DBEnv_get_lg_max(DBEnvObject* self)
     RETURN_IF_ERR();
     return NUMBER_FromLong(lg_max);
 }
-#endif
-
 
 static PyObject*
 DBEnv_set_lg_regionmax(DBEnvObject* self, PyObject* args)
@@ -4372,6 +5626,53 @@ DBEnv_set_lg_regionmax(DBEnvObject* self
     RETURN_NONE();
 }
 
+static PyObject*
+DBEnv_get_lg_regionmax(DBEnvObject* self)
+{
+    int err;
+    u_int32_t lg_regionmax;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_lg_regionmax(self->db_env, &lg_regionmax);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(lg_regionmax);
+}
+
+#if (DBVER >= 47)
+static PyObject*
+DBEnv_set_lk_partitions(DBEnvObject* self, PyObject* args)
+{
+    int err, lk_partitions;
+
+    if (!PyArg_ParseTuple(args, "i:set_lk_partitions", &lk_partitions))
+        return NULL;
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->set_lk_partitions(self->db_env, lk_partitions);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DBEnv_get_lk_partitions(DBEnvObject* self)
+{
+    int err;
+    u_int32_t lk_partitions;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_lk_partitions(self->db_env, &lk_partitions);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(lk_partitions);
+}
+#endif
 
 static PyObject*
 DBEnv_set_lk_detect(DBEnvObject* self, PyObject* args)
@@ -4389,6 +5690,20 @@ DBEnv_set_lk_detect(DBEnvObject* self, P
     RETURN_NONE();
 }
 
+static PyObject*
+DBEnv_get_lk_detect(DBEnvObject* self)
+{
+    int err;
+    u_int32_t lk_detect;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_lk_detect(self->db_env, &lk_detect);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(lk_detect);
+}
 
 #if (DBVER < 45)
 static PyObject*
@@ -4426,6 +5741,20 @@ DBEnv_set_lk_max_locks(DBEnvObject* self
     RETURN_NONE();
 }
 
+static PyObject*
+DBEnv_get_lk_max_locks(DBEnvObject* self)
+{
+    int err;
+    u_int32_t lk_max;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_lk_max_locks(self->db_env, &lk_max);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(lk_max);
+}
 
 static PyObject*
 DBEnv_set_lk_max_lockers(DBEnvObject* self, PyObject* args)
@@ -4443,6 +5772,20 @@ DBEnv_set_lk_max_lockers(DBEnvObject* se
     RETURN_NONE();
 }
 
+static PyObject*
+DBEnv_get_lk_max_lockers(DBEnvObject* self)
+{
+    int err;
+    u_int32_t lk_max;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_lk_max_lockers(self->db_env, &lk_max);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(lk_max);
+}
 
 static PyObject*
 DBEnv_set_lk_max_objects(DBEnvObject* self, PyObject* args)
@@ -4460,6 +5803,35 @@ DBEnv_set_lk_max_objects(DBEnvObject* se
     RETURN_NONE();
 }
 
+static PyObject*
+DBEnv_get_lk_max_objects(DBEnvObject* self)
+{
+    int err;
+    u_int32_t lk_max;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_lk_max_objects(self->db_env, &lk_max);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(lk_max);
+}
+
+static PyObject*
+DBEnv_get_mp_mmapsize(DBEnvObject* self)
+{
+    int err;
+    size_t mmapsize;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_mp_mmapsize(self->db_env, &mmapsize);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(mmapsize);
+}
 
 static PyObject*
 DBEnv_set_mp_mmapsize(DBEnvObject* self, PyObject* args)
@@ -4495,6 +5867,22 @@ DBEnv_set_tmp_dir(DBEnvObject* self, PyO
     RETURN_NONE();
 }
 
+static PyObject*
+DBEnv_get_tmp_dir(DBEnvObject* self)
+{
+    int err;
+    const char *dirpp;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_tmp_dir(self->db_env, &dirpp);
+    MYDB_END_ALLOW_THREADS;
+
+    RETURN_IF_ERR();
+
+    return PyBytes_FromString(dirpp);
+}
 
 static PyObject*
 DBEnv_txn_recover(DBEnvObject* self)
@@ -4535,7 +5923,7 @@ DBEnv_txn_recover(DBEnvObject* self)
                 Py_DECREF(list);
                 return NULL;
             }
-            txn=newDBTxnObject(self, NULL, preplist[i].txn, flags);
+            txn=newDBTxnObject(self, NULL, preplist[i].txn, 0);
             if (!txn) {
                 Py_DECREF(list);
                 Py_DECREF(gid);
@@ -4609,6 +5997,20 @@ DBEnv_txn_checkpoint(DBEnvObject* self,
     RETURN_NONE();
 }
 
+static PyObject*
+DBEnv_get_tx_max(DBEnvObject* self)
+{
+    int err;
+    u_int32_t max;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_tx_max(self->db_env, &max);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return PyLong_FromUnsignedLong(max);
+}
 
 static PyObject*
 DBEnv_set_tx_max(DBEnvObject* self, PyObject* args)
@@ -4619,12 +6021,28 @@ DBEnv_set_tx_max(DBEnvObject* self, PyOb
         return NULL;
     CHECK_ENV_NOT_CLOSED(self);
 
+    MYDB_BEGIN_ALLOW_THREADS;
     err = self->db_env->set_tx_max(self->db_env, max);
+    MYDB_END_ALLOW_THREADS;
     RETURN_IF_ERR();
     RETURN_NONE();
 }
 
-
+static PyObject*
+DBEnv_get_tx_timestamp(DBEnvObject* self)
+{
+    int err;
+    time_t timestamp;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_tx_timestamp(self->db_env, &timestamp);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(timestamp);
+}
+
 static PyObject*
 DBEnv_set_tx_timestamp(DBEnvObject* self, PyObject* args)
 {
@@ -4636,7 +6054,9 @@ DBEnv_set_tx_timestamp(DBEnvObject* self
         return NULL;
     CHECK_ENV_NOT_CLOSED(self);
     timestamp = (time_t)stamp;
+    MYDB_BEGIN_ALLOW_THREADS;
     err = self->db_env->set_tx_timestamp(self->db_env, &timestamp);
+    MYDB_END_ALLOW_THREADS;
     RETURN_IF_ERR();
     RETURN_NONE();
 }
@@ -4730,6 +6150,26 @@ DBEnv_lock_put(DBEnvObject* self, PyObje
 
 #if (DBVER >= 44)
 static PyObject*
+DBEnv_fileid_reset(DBEnvObject* self, PyObject* args, PyObject* kwargs)
+{
+    int err;
+    char *file;
+    u_int32_t flags = 0;
+    static char* kwnames[] = { "file", "flags", NULL};
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "z|i:fileid_reset", kwnames,
+                                     &file, &flags))
+        return NULL;
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->fileid_reset(self->db_env, file, flags);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
 DBEnv_lsn_reset(DBEnvObject* self, PyObject* args, PyObject* kwargs)
 {
     int err;
@@ -4750,6 +6190,30 @@ DBEnv_lsn_reset(DBEnvObject* self, PyObj
 }
 #endif /* DBVER >= 4.4 */
 
+
+#if (DBVER >= 43)
+static PyObject*
+DBEnv_stat_print(DBEnvObject* self, PyObject* args, PyObject *kwargs)
+{
+    int err;
+    int flags=0;
+    static char* kwnames[] = { "flags", NULL };
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:stat_print",
+                kwnames, &flags))
+    {
+        return NULL;
+    }
+    CHECK_ENV_NOT_CLOSED(self);
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->stat_print(self->db_env, flags);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+#endif
+
+
 static PyObject*
 DBEnv_log_stat(DBEnvObject* self, PyObject* args)
 {
@@ -4785,9 +6249,6 @@ DBEnv_log_stat(DBEnvObject* self, PyObje
     MAKE_ENTRY(lg_size);
     MAKE_ENTRY(record);
 #endif
-#if (DBVER < 41)
-    MAKE_ENTRY(lg_max);
-#endif
     MAKE_ENTRY(w_mbytes);
     MAKE_ENTRY(w_bytes);
     MAKE_ENTRY(wc_mbytes);
@@ -4814,6 +6275,29 @@ DBEnv_log_stat(DBEnvObject* self, PyObje
 } /* DBEnv_log_stat */
 
 
+#if (DBVER >= 43)
+static PyObject*
+DBEnv_log_stat_print(DBEnvObject* self, PyObject* args, PyObject *kwargs)
+{
+    int err;
+    int flags=0;
+    static char* kwnames[] = { "flags", NULL };
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:log_stat_print",
+                kwnames, &flags))
+    {
+        return NULL;
+    }
+    CHECK_ENV_NOT_CLOSED(self);
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->log_stat_print(self->db_env, flags);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+#endif
+
+
 static PyObject*
 DBEnv_lock_stat(DBEnvObject* self, PyObject* args)
 {
@@ -4840,13 +6324,8 @@ DBEnv_lock_stat(DBEnvObject* self, PyObj
 
 #define MAKE_ENTRY(name)  _addIntToDict(d, #name, sp->st_##name)
 
-#if (DBVER < 41)
-    MAKE_ENTRY(lastid);
-#endif
-#if (DBVER >=41)
     MAKE_ENTRY(id);
     MAKE_ENTRY(cur_maxid);
-#endif
     MAKE_ENTRY(nmodes);
     MAKE_ENTRY(maxlocks);
     MAKE_ENTRY(maxlockers);
@@ -4871,10 +6350,8 @@ DBEnv_lock_stat(DBEnvObject* self, PyObj
     MAKE_ENTRY(lock_wait);
 #endif
     MAKE_ENTRY(ndeadlocks);
-#if (DBVER >= 41)
     MAKE_ENTRY(locktimeout);
     MAKE_ENTRY(txntimeout);
-#endif
     MAKE_ENTRY(nlocktimeouts);
     MAKE_ENTRY(ntxntimeouts);
 #if (DBVER >= 46)
@@ -4900,6 +6377,45 @@ DBEnv_lock_stat(DBEnvObject* self, PyObj
     return d;
 }
 
+#if (DBVER >= 43)
+static PyObject*
+DBEnv_lock_stat_print(DBEnvObject* self, PyObject* args, PyObject *kwargs)
+{
+    int err;
+    int flags=0;
+    static char* kwnames[] = { "flags", NULL };
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:lock_stat_print",
+                kwnames, &flags))
+    {
+        return NULL;
+    }
+    CHECK_ENV_NOT_CLOSED(self);
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->lock_stat_print(self->db_env, flags);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+#endif
+
+
+static PyObject*
+DBEnv_log_cursor(DBEnvObject* self)
+{
+    int err;
+    DB_LOGC* dblogc;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->log_cursor(self->db_env, &dblogc, 0);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return (PyObject*) newDBLogCursorObject(dblogc, self);
+}
+
+
 static PyObject*
 DBEnv_log_flush(DBEnvObject* self)
 {
@@ -4916,6 +6432,86 @@ DBEnv_log_flush(DBEnvObject* self)
 }
 
 static PyObject*
+DBEnv_log_file(DBEnvObject* self, PyObject* args)
+{
+    int err;
+    DB_LSN lsn = {0, 0};
+    int size = 20;
+    char *name = NULL;
+    PyObject *retval;
+
+    if (!PyArg_ParseTuple(args, "(ii):log_file", &lsn.file, &lsn.offset))
+        return NULL;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    do {
+        name = malloc(size);
+        if (!name) {
+            PyErr_NoMemory();
+            return NULL;
+        }
+        MYDB_BEGIN_ALLOW_THREADS;
+        err = self->db_env->log_file(self->db_env, &lsn, name, size);
+        MYDB_END_ALLOW_THREADS;
+        if (err == EINVAL) {
+            free(name);
+            size *= 2;
+        } else if (err) {
+            free(name);
+            RETURN_IF_ERR();
+            assert(0);  /* Unreachable... supposely */
+            return NULL;
+        }
+/*
+** If the final buffer we try is too small, we will
+** get this exception:
+** DBInvalidArgError:
+**    (22, 'Invalid argument -- DB_ENV->log_file: name buffer is too short')
+*/
+    } while ((err == EINVAL) && (size<(1<<17)));
+
+    RETURN_IF_ERR();  /* Maybe the size is not the problem */
+
+    retval = Py_BuildValue("s", name);
+    free(name);
+    return retval;
+}
+
+
+#if (DBVER >= 44)
+static PyObject*
+DBEnv_log_printf(DBEnvObject* self, PyObject* args, PyObject *kwargs)
+{
+    int err;
+    char *string;
+    PyObject *txnobj = NULL;
+    DB_TXN *txn = NULL;
+    static char* kwnames[] = {"string", "txn", NULL };
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s|O:log_printf", kwnames,
+                &string, &txnobj))
+        return NULL;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    if (!checkTxnObj(txnobj, &txn))
+        return NULL;
+
+    /*
+    ** Do not use the format string directly, to avoid attacks.
+    */
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->log_printf(self->db_env, txn, "%s", string);
+    MYDB_END_ALLOW_THREADS;
+
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+#endif
+
+
+static PyObject*
 DBEnv_log_archive(DBEnvObject* self, PyObject* args)
 {
     int flags=0;
@@ -4963,6 +6559,99 @@ DBEnv_log_archive(DBEnvObject* self, PyO
 }
 
 
+#if (DBVER >= 44)
+static PyObject*
+DBEnv_mutex_stat(DBEnvObject* self, PyObject* args)
+{
+    int err;
+    DB_MUTEX_STAT* statp = NULL;
+    PyObject* d = NULL;
+    u_int32_t flags = 0;
+
+    if (!PyArg_ParseTuple(args, "|i:mutex_stat", &flags))
+        return NULL;
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->mutex_stat(self->db_env, &statp, flags);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+
+    /* Turn the stat structure into a dictionary */
+    d = PyDict_New();
+    if (d == NULL) {
+        if (statp)
+            free(statp);
+        return NULL;
+    }
+
+#define MAKE_ENTRY(name)  _addIntToDict(d, #name, statp->st_##name)
+
+    MAKE_ENTRY(mutex_align);
+    MAKE_ENTRY(mutex_tas_spins);
+    MAKE_ENTRY(mutex_cnt);
+    MAKE_ENTRY(mutex_free);
+    MAKE_ENTRY(mutex_inuse);
+    MAKE_ENTRY(mutex_inuse_max);
+    MAKE_ENTRY(regsize);
+    MAKE_ENTRY(region_wait);
+    MAKE_ENTRY(region_nowait);
+
+#undef MAKE_ENTRY
+    free(statp);
+    return d;
+}
+#endif
+
+
+#if (DBVER >= 44)
+static PyObject*
+DBEnv_mutex_stat_print(DBEnvObject* self, PyObject* args, PyObject *kwargs)
+{
+    int err;
+    int flags=0;
+    static char* kwnames[] = { "flags", NULL };
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:mutex_stat_print",
+                kwnames, &flags))
+    {
+        return NULL;
+    }
+    CHECK_ENV_NOT_CLOSED(self);
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->mutex_stat_print(self->db_env, flags);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+#endif
+
+
+#if (DBVER >= 43)
+static PyObject*
+DBEnv_txn_stat_print(DBEnvObject* self, PyObject* args, PyObject *kwargs)
+{
+    int err;
+    int flags=0;
+    static char* kwnames[] = { "flags", NULL };
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:stat_print",
+                kwnames, &flags))
+    {
+        return NULL;
+    }
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->txn_stat_print(self->db_env, flags);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+#endif
+
+
 static PyObject*
 DBEnv_txn_stat(DBEnvObject* self, PyObject* args)
 {
@@ -5045,15 +6734,64 @@ DBEnv_get_private(DBEnvObject* self)
 }
 
 static PyObject*
-DBEnv_set_private(DBEnvObject* self, PyObject* private_obj)
+DBEnv_set_private(DBEnvObject* self, PyObject* private_obj)
+{
+    /* We can set the private field even if dbenv is closed */
+    Py_DECREF(self->private_obj);
+    Py_INCREF(private_obj);
+    self->private_obj = private_obj;
+    RETURN_NONE();
+}
+
+#if (DBVER >= 47)
+static PyObject*
+DBEnv_set_intermediate_dir_mode(DBEnvObject* self, PyObject* args)
+{
+    int err;
+    const char *mode;
+
+    if (!PyArg_ParseTuple(args,"s:set_intermediate_dir_mode", &mode))
+        return NULL;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->set_intermediate_dir_mode(self->db_env, mode);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DBEnv_get_intermediate_dir_mode(DBEnvObject* self)
+{
+    int err;
+    const char *mode;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_intermediate_dir_mode(self->db_env, &mode);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return Py_BuildValue("s", mode);
+}
+#endif
+
+static PyObject*
+DBEnv_get_open_flags(DBEnvObject* self)
 {
-    /* We can set the private field even if dbenv is closed */
-    Py_DECREF(self->private_obj);
-    Py_INCREF(private_obj);
-    self->private_obj = private_obj;
-    RETURN_NONE();
-}
+    int err;
+    unsigned int flags;
 
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_open_flags(self->db_env, &flags);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(flags);
+}
 
 #if (DBVER < 48)
 static PyObject*
@@ -5079,6 +6817,83 @@ DBEnv_set_rpc_server(DBEnvObject* self,
 }
 #endif
 
+#if (DBVER >= 43)
+static PyObject*
+DBEnv_set_mp_max_openfd(DBEnvObject* self, PyObject* args)
+{
+    int err;
+    int maxopenfd;
+
+    if (!PyArg_ParseTuple(args, "i:set_mp_max_openfd", &maxopenfd)) {
+        return NULL;
+    }
+    CHECK_ENV_NOT_CLOSED(self);
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->set_mp_max_openfd(self->db_env, maxopenfd);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DBEnv_get_mp_max_openfd(DBEnvObject* self)
+{
+    int err;
+    int maxopenfd;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_mp_max_openfd(self->db_env, &maxopenfd);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(maxopenfd);
+}
+
+
+static PyObject*
+DBEnv_set_mp_max_write(DBEnvObject* self, PyObject* args)
+{
+    int err;
+    int maxwrite, maxwrite_sleep;
+
+    if (!PyArg_ParseTuple(args, "ii:set_mp_max_write", &maxwrite,
+                &maxwrite_sleep)) {
+        return NULL;
+    }
+    CHECK_ENV_NOT_CLOSED(self);
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->set_mp_max_write(self->db_env, maxwrite,
+            maxwrite_sleep);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DBEnv_get_mp_max_write(DBEnvObject* self)
+{
+    int err;
+    int maxwrite;
+#if (DBVER >= 46)
+    db_timeout_t maxwrite_sleep;
+#else
+    int maxwrite_sleep;
+#endif
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_mp_max_write(self->db_env, &maxwrite,
+            &maxwrite_sleep);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+
+    return Py_BuildValue("(ii)", maxwrite, (int)maxwrite_sleep);
+}
+#endif
+
+
 static PyObject*
 DBEnv_set_verbose(DBEnvObject* self, PyObject* args)
 {
@@ -5096,7 +6911,6 @@ DBEnv_set_verbose(DBEnvObject* self, PyO
     RETURN_NONE();
 }
 
-#if (DBVER >= 42)
 static PyObject*
 DBEnv_get_verbose(DBEnvObject* self, PyObject* args)
 {
@@ -5114,7 +6928,6 @@ DBEnv_get_verbose(DBEnvObject* self, PyO
     RETURN_IF_ERR();
     return PyBool_FromLong(verbose);
 }
-#endif
 
 #if (DBVER >= 45)
 static void
@@ -5196,9 +7009,7 @@ DBEnv_rep_process_message(DBEnvObject* s
     PyObject *control_py, *rec_py;
     DBT control, rec;
     int envid;
-#if (DBVER >= 42)
     DB_LSN lsn;
-#endif
 
     if (!PyArg_ParseTuple(args, "OOi:rep_process_message", &control_py,
                 &rec_py, &envid))
@@ -5215,13 +7026,8 @@ DBEnv_rep_process_message(DBEnvObject* s
     err = self->db_env->rep_process_message(self->db_env, &control, &rec,
             envid, &lsn);
 #else
-#if (DBVER >= 42)
     err = self->db_env->rep_process_message(self->db_env, &control, &rec,
             &envid, &lsn);
-#else
-    err = self->db_env->rep_process_message(self->db_env, &control, &rec,
-            &envid);
-#endif
 #endif
     MYDB_END_ALLOW_THREADS;
     switch (err) {
@@ -5250,12 +7056,10 @@ DBEnv_rep_process_message(DBEnvObject* s
                 return r;
                 break;
             }
-#if (DBVER >= 42)
         case DB_REP_NOTPERM :
         case DB_REP_ISPERM :
             return Py_BuildValue("(i(ll))", err, lsn.file, lsn.offset);
             break;
-#endif
     }
     RETURN_IF_ERR();
     return Py_BuildValue("(OO)", Py_None, Py_None);
@@ -5307,20 +7111,6 @@ _DBEnv_rep_transportCallback(DB_ENV* db_
     return ret;
 }
 
-#if (DBVER <= 41)
-static int
-_DBEnv_rep_transportCallbackOLD(DB_ENV* db_env, const DBT* control, const DBT* rec,
-        int envid, u_int32_t flags)
-{
-    DB_LSN lsn;
-
-    lsn.file = -1;  /* Dummy values */
-    lsn.offset = -1;
-    return _DBEnv_rep_transportCallback(db_env, control, rec, &lsn, envid,
-            flags);
-}
-#endif
-
 static PyObject*
 DBEnv_rep_set_transport(DBEnvObject* self, PyObject* args)
 {
@@ -5341,13 +7131,8 @@ DBEnv_rep_set_transport(DBEnvObject* sel
     err = self->db_env->rep_set_transport(self->db_env, envid,
             &_DBEnv_rep_transportCallback);
 #else
-#if (DBVER >= 42)
     err = self->db_env->set_rep_transport(self->db_env, envid,
             &_DBEnv_rep_transportCallback);
-#else
-    err = self->db_env->set_rep_transport(self->db_env, envid,
-            &_DBEnv_rep_transportCallbackOLD);
-#endif
 #endif
     MYDB_END_ALLOW_THREADS;
     RETURN_IF_ERR();
@@ -5478,7 +7263,7 @@ DBEnv_rep_elect(DBEnvObject* self, PyObj
     }
     CHECK_ENV_NOT_CLOSED(self);
     MYDB_BEGIN_ALLOW_THREADS;
-    err = self->db_env->rep_elect(self->db_env, nvotes, nvotes, 0);
+    err = self->db_env->rep_elect(self->db_env, nsites, nvotes, 0);
     MYDB_END_ALLOW_THREADS;
     RETURN_IF_ERR();
     RETURN_NONE();
@@ -5635,6 +7420,175 @@ DBEnv_rep_get_timeout(DBEnvObject* self,
 }
 #endif
 
+
+#if (DBVER >= 47)
+static PyObject*
+DBEnv_rep_set_clockskew(DBEnvObject* self, PyObject* args)
+{
+    int err;
+    unsigned int fast, slow;
+
+#if (PY_VERSION_HEX >= 0x02040000)
+    if (!PyArg_ParseTuple(args,"II:rep_set_clockskew", &fast, &slow))
+        return NULL;
+#else
+    if (!PyArg_ParseTuple(args,"ii:rep_set_clockskew", &fast, &slow))
+        return NULL;
+#endif
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->rep_set_clockskew(self->db_env, fast, slow);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DBEnv_rep_get_clockskew(DBEnvObject* self)
+{
+    int err;
+    unsigned int fast, slow;
+
+    CHECK_ENV_NOT_CLOSED(self);
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->rep_get_clockskew(self->db_env, &fast, &slow);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+#if (PY_VERSION_HEX >= 0x02040000)
+    return Py_BuildValue("(II)", fast, slow);
+#else
+    return Py_BuildValue("(ii)", fast, slow);
+#endif
+}
+#endif
+
+#if (DBVER >= 43)
+static PyObject*
+DBEnv_rep_stat_print(DBEnvObject* self, PyObject* args, PyObject *kwargs)
+{
+    int err;
+    int flags=0;
+    static char* kwnames[] = { "flags", NULL };
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:rep_stat_print",
+                kwnames, &flags))
+    {
+        return NULL;
+    }
+    CHECK_ENV_NOT_CLOSED(self);
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->rep_stat_print(self->db_env, flags);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+#endif
+
+static PyObject*
+DBEnv_rep_stat(DBEnvObject* self, PyObject* args, PyObject *kwargs)
+{
+    int err;
+    int flags=0;
+    DB_REP_STAT *statp;
+    PyObject *stats;
+    static char* kwnames[] = { "flags", NULL };
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:rep_stat",
+                kwnames, &flags))
+    {
+        return NULL;
+    }
+    CHECK_ENV_NOT_CLOSED(self);
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->rep_stat(self->db_env, &statp, flags);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+
+    stats=PyDict_New();
+    if (stats == NULL) {
+        free(statp);
+        return NULL;
+    }
+
+#define MAKE_ENTRY(name)  _addIntToDict(stats, #name, statp->st_##name)
+#define MAKE_DB_LSN_ENTRY(name) _addDB_lsnToDict(stats , #name, statp->st_##name)
+
+#if (DBVER >= 44)
+    MAKE_ENTRY(bulk_fills);
+    MAKE_ENTRY(bulk_overflows);
+    MAKE_ENTRY(bulk_records);
+    MAKE_ENTRY(bulk_transfers);
+    MAKE_ENTRY(client_rerequests);
+    MAKE_ENTRY(client_svc_miss);
+    MAKE_ENTRY(client_svc_req);
+#endif
+    MAKE_ENTRY(dupmasters);
+#if (DBVER >= 43)
+    MAKE_ENTRY(egen);
+    MAKE_ENTRY(election_nvotes);
+    MAKE_ENTRY(startup_complete);
+    MAKE_ENTRY(pg_duplicated);
+    MAKE_ENTRY(pg_records);
+    MAKE_ENTRY(pg_requested);
+    MAKE_ENTRY(next_pg);
+    MAKE_ENTRY(waiting_pg);
+#endif
+    MAKE_ENTRY(election_cur_winner);
+    MAKE_ENTRY(election_gen);
+    MAKE_DB_LSN_ENTRY(election_lsn);
+    MAKE_ENTRY(election_nsites);
+    MAKE_ENTRY(election_priority);
+#if (DBVER >= 44)
+    MAKE_ENTRY(election_sec);
+    MAKE_ENTRY(election_usec);
+#endif
+    MAKE_ENTRY(election_status);
+    MAKE_ENTRY(election_tiebreaker);
+    MAKE_ENTRY(election_votes);
+    MAKE_ENTRY(elections);
+    MAKE_ENTRY(elections_won);
+    MAKE_ENTRY(env_id);
+    MAKE_ENTRY(env_priority);
+    MAKE_ENTRY(gen);
+    MAKE_ENTRY(log_duplicated);
+    MAKE_ENTRY(log_queued);
+    MAKE_ENTRY(log_queued_max);
+    MAKE_ENTRY(log_queued_total);
+    MAKE_ENTRY(log_records);
+    MAKE_ENTRY(log_requested);
+    MAKE_ENTRY(master);
+    MAKE_ENTRY(master_changes);
+#if (DBVER >= 47)
+    MAKE_ENTRY(max_lease_sec);
+    MAKE_ENTRY(max_lease_usec);
+    MAKE_DB_LSN_ENTRY(max_perm_lsn);
+#endif
+    MAKE_ENTRY(msgs_badgen);
+    MAKE_ENTRY(msgs_processed);
+    MAKE_ENTRY(msgs_recover);
+    MAKE_ENTRY(msgs_send_failures);
+    MAKE_ENTRY(msgs_sent);
+    MAKE_ENTRY(newsites);
+    MAKE_DB_LSN_ENTRY(next_lsn);
+    MAKE_ENTRY(nsites);
+    MAKE_ENTRY(nthrottles);
+    MAKE_ENTRY(outdated);
+#if (DBVER >= 46)
+    MAKE_ENTRY(startsync_delayed);
+#endif
+    MAKE_ENTRY(status);
+    MAKE_ENTRY(txns_applied);
+    MAKE_DB_LSN_ENTRY(waiting_lsn);
+
+#undef MAKE_DB_LSN_ENTRY
+#undef MAKE_ENTRY
+
+    free(statp);
+    return stats;
+}
+
 /* --------------------------------------------------------------------- */
 /* REPLICATION METHODS: Replication Manager */
 
@@ -6076,6 +8030,76 @@ DBTxn_id(DBTxnObject* self)
     return NUMBER_FromLong(id);
 }
 
+
+static PyObject*
+DBTxn_set_timeout(DBTxnObject* self, PyObject* args, PyObject* kwargs)
+{
+    int err;
+    u_int32_t flags=0;
+    u_int32_t timeout = 0;
+    static char* kwnames[] = { "timeout", "flags", NULL };
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ii:set_timeout", kwnames,
+                &timeout, &flags)) {
+        return NULL;
+    }
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->txn->set_timeout(self->txn, (db_timeout_t)timeout, flags);
+    MYDB_END_ALLOW_THREADS;
+
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+
+#if (DBVER >= 44)
+static PyObject*
+DBTxn_set_name(DBTxnObject* self, PyObject* args)
+{
+    int err;
+    const char *name;
+
+    if (!PyArg_ParseTuple(args, "s:set_name", &name))
+        return NULL;
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->txn->set_name(self->txn, name);
+    MYDB_END_ALLOW_THREADS;
+
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+#endif
+
+
+#if (DBVER >= 44)
+static PyObject*
+DBTxn_get_name(DBTxnObject* self)
+{
+    int err;
+    const char *name;
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->txn->get_name(self->txn, &name);
+    MYDB_END_ALLOW_THREADS;
+
+    RETURN_IF_ERR();
+#if (PY_VERSION_HEX < 0x03000000)
+    if (!name) {
+        return PyString_FromString("");
+    }
+    return PyString_FromString(name);
+#else
+    if (!name) {
+        return PyUnicode_FromString("");
+    }
+    return PyUnicode_FromString(name);
+#endif
+}
+#endif
+
+
 #if (DBVER >= 43)
 /* --------------------------------------------------------------------- */
 /* DBSequence methods */
@@ -6179,12 +8203,12 @@ DBSequence_get_key(DBSequenceObject* sel
 }
 
 static PyObject*
-DBSequence_init_value(DBSequenceObject* self, PyObject* args)
+DBSequence_initial_value(DBSequenceObject* self, PyObject* args)
 {
     int err;
     PY_LONG_LONG value;
     db_seq_t value2;
-    if (!PyArg_ParseTuple(args,"L:init_value", &value))
+    if (!PyArg_ParseTuple(args,"L:initial_value", &value))
         return NULL;
     CHECK_SEQUENCE_NOT_CLOSED(self)
 
@@ -6350,16 +8374,39 @@ DBSequence_get_range(DBSequenceObject* s
     PY_LONG_LONG min, max;
     db_seq_t min2, max2;
 
-    CHECK_SEQUENCE_NOT_CLOSED(self)
+    CHECK_SEQUENCE_NOT_CLOSED(self)
+
+    MYDB_BEGIN_ALLOW_THREADS
+    err = self->sequence->get_range(self->sequence, &min2, &max2);
+    MYDB_END_ALLOW_THREADS
+
+    RETURN_IF_ERR();
+    min=min2;  /* If truncation, compiler should show a warning */
+    max=max2;
+    return Py_BuildValue("(LL)", min, max);
+}
+
+
+static PyObject*
+DBSequence_stat_print(DBSequenceObject* self, PyObject* args, PyObject *kwargs)
+{
+    int err;
+    int flags=0;
+    static char* kwnames[] = { "flags", NULL };
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:stat_print",
+                kwnames, &flags))
+    {
+        return NULL;
+    }
 
-    MYDB_BEGIN_ALLOW_THREADS
-    err = self->sequence->get_range(self->sequence, &min2, &max2);
-    MYDB_END_ALLOW_THREADS
+    CHECK_SEQUENCE_NOT_CLOSED(self);
 
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->sequence->stat_print(self->sequence, flags);
+    MYDB_END_ALLOW_THREADS;
     RETURN_IF_ERR();
-    min=min2;  /* If truncation, compiler should show a warning */
-    max=max2;
-    return Py_BuildValue("(LL)", min, max);
+    RETURN_NONE();
 }
 
 static PyObject*
@@ -6413,11 +8460,18 @@ static PyMethodDef DB_methods[] = {
     {"append",          (PyCFunction)DB_append,         METH_VARARGS|METH_KEYWORDS},
     {"associate",       (PyCFunction)DB_associate,      METH_VARARGS|METH_KEYWORDS},
     {"close",           (PyCFunction)DB_close,          METH_VARARGS},
+#if (DBVER >= 47)
+    {"compact",         (PyCFunction)DB_compact,        METH_VARARGS|METH_KEYWORDS},
+#endif
     {"consume",         (PyCFunction)DB_consume,        METH_VARARGS|METH_KEYWORDS},
     {"consume_wait",    (PyCFunction)DB_consume_wait,   METH_VARARGS|METH_KEYWORDS},
     {"cursor",          (PyCFunction)DB_cursor,         METH_VARARGS|METH_KEYWORDS},
     {"delete",          (PyCFunction)DB_delete,         METH_VARARGS|METH_KEYWORDS},
     {"fd",              (PyCFunction)DB_fd,             METH_NOARGS},
+#if (DBVER >= 46)
+    {"exists",          (PyCFunction)DB_exists,
+        METH_VARARGS|METH_KEYWORDS},
+#endif
     {"get",             (PyCFunction)DB_get,            METH_VARARGS|METH_KEYWORDS},
     {"pget",            (PyCFunction)DB_pget,           METH_VARARGS|METH_KEYWORDS},
     {"get_both",        (PyCFunction)DB_get_both,       METH_VARARGS|METH_KEYWORDS},
@@ -6434,24 +8488,48 @@ static PyMethodDef DB_methods[] = {
     {"remove",          (PyCFunction)DB_remove,         METH_VARARGS|METH_KEYWORDS},
     {"rename",          (PyCFunction)DB_rename,         METH_VARARGS},
     {"set_bt_minkey",   (PyCFunction)DB_set_bt_minkey,  METH_VARARGS},
+    {"get_bt_minkey",   (PyCFunction)DB_get_bt_minkey,  METH_NOARGS},
     {"set_bt_compare",  (PyCFunction)DB_set_bt_compare, METH_O},
     {"set_cachesize",   (PyCFunction)DB_set_cachesize,  METH_VARARGS},
-#if (DBVER >= 41)
+    {"get_cachesize",   (PyCFunction)DB_get_cachesize,  METH_NOARGS},
     {"set_encrypt",     (PyCFunction)DB_set_encrypt,    METH_VARARGS|METH_KEYWORDS},
-#endif
+    {"get_encrypt_flags", (PyCFunction)DB_get_encrypt_flags, METH_NOARGS},
     {"set_flags",       (PyCFunction)DB_set_flags,      METH_VARARGS},
+    {"get_flags",       (PyCFunction)DB_get_flags,      METH_NOARGS},
+#if (DBVER >= 43)
+    {"get_transactional", (PyCFunction)DB_get_transactional, METH_NOARGS},
+#endif
     {"set_h_ffactor",   (PyCFunction)DB_set_h_ffactor,  METH_VARARGS},
+    {"get_h_ffactor",   (PyCFunction)DB_get_h_ffactor,  METH_NOARGS},
     {"set_h_nelem",     (PyCFunction)DB_set_h_nelem,    METH_VARARGS},
+    {"get_h_nelem",     (PyCFunction)DB_get_h_nelem,    METH_NOARGS},
     {"set_lorder",      (PyCFunction)DB_set_lorder,     METH_VARARGS},
+    {"get_lorder",      (PyCFunction)DB_get_lorder,     METH_NOARGS},
     {"set_pagesize",    (PyCFunction)DB_set_pagesize,   METH_VARARGS},
+    {"get_pagesize",    (PyCFunction)DB_get_pagesize,   METH_NOARGS},
     {"set_re_delim",    (PyCFunction)DB_set_re_delim,   METH_VARARGS},
+    {"get_re_delim",    (PyCFunction)DB_get_re_delim,   METH_NOARGS},
     {"set_re_len",      (PyCFunction)DB_set_re_len,     METH_VARARGS},
+    {"get_re_len",      (PyCFunction)DB_get_re_len,     METH_NOARGS},
     {"set_re_pad",      (PyCFunction)DB_set_re_pad,     METH_VARARGS},
+    {"get_re_pad",      (PyCFunction)DB_get_re_pad,     METH_NOARGS},
     {"set_re_source",   (PyCFunction)DB_set_re_source,  METH_VARARGS},
+    {"get_re_source",   (PyCFunction)DB_get_re_source,  METH_NOARGS},
     {"set_q_extentsize",(PyCFunction)DB_set_q_extentsize, METH_VARARGS},
+    {"get_q_extentsize",(PyCFunction)DB_get_q_extentsize, METH_NOARGS},
     {"set_private",     (PyCFunction)DB_set_private,    METH_O},
     {"get_private",     (PyCFunction)DB_get_private,    METH_NOARGS},
+#if (DBVER >= 46)
+    {"set_priority",    (PyCFunction)DB_set_priority,   METH_VARARGS},
+    {"get_priority",    (PyCFunction)DB_get_priority,   METH_NOARGS},
+#endif
+    {"get_dbname",      (PyCFunction)DB_get_dbname,     METH_NOARGS},
+    {"get_open_flags",  (PyCFunction)DB_get_open_flags, METH_NOARGS},
     {"stat",            (PyCFunction)DB_stat,           METH_VARARGS|METH_KEYWORDS},
+#if (DBVER >= 43)
+    {"stat_print",      (PyCFunction)DB_stat_print,
+        METH_VARARGS|METH_KEYWORDS},
+#endif
     {"sync",            (PyCFunction)DB_sync,           METH_VARARGS},
     {"truncate",        (PyCFunction)DB_truncate,       METH_VARARGS|METH_KEYWORDS},
     {"type",            (PyCFunction)DB_get_type,       METH_NOARGS},
@@ -6463,6 +8541,20 @@ static PyMethodDef DB_methods[] = {
 };
 
 
+/* We need this to support __contains__() */
+static PySequenceMethods DB_sequence = {
+    0, /* sq_length, mapping wins here */
+    0, /* sq_concat */
+    0, /* sq_repeat */
+    0, /* sq_item */
+    0, /* sq_slice */
+    0, /* sq_ass_item */
+    0, /* sq_ass_slice */
+    (objobjproc)DB_contains, /* sq_contains */
+    0, /* sq_inplace_concat */
+    0, /* sq_inplace_repeat */
+};
+
 static PyMappingMethods DB_mapping = {
         DB_length,                   /*mp_length*/
         (binaryfunc)DB_subscript,    /*mp_subscript*/
@@ -6493,8 +8585,29 @@ static PyMethodDef DBCursor_methods[] =
     {"consume",         (PyCFunction)DBC_consume,       METH_VARARGS|METH_KEYWORDS},
     {"next_dup",        (PyCFunction)DBC_next_dup,      METH_VARARGS|METH_KEYWORDS},
     {"next_nodup",      (PyCFunction)DBC_next_nodup,    METH_VARARGS|METH_KEYWORDS},
+#if (DBVER >= 46)
+    {"prev_dup",        (PyCFunction)DBC_prev_dup,
+        METH_VARARGS|METH_KEYWORDS},
+#endif
     {"prev_nodup",      (PyCFunction)DBC_prev_nodup,    METH_VARARGS|METH_KEYWORDS},
     {"join_item",       (PyCFunction)DBC_join_item,     METH_VARARGS},
+#if (DBVER >= 46)
+    {"set_priority",    (PyCFunction)DBC_set_priority,
+        METH_VARARGS|METH_KEYWORDS},
+    {"get_priority",    (PyCFunction)DBC_get_priority, METH_NOARGS},
+#endif
+    {NULL,      NULL}       /* sentinel */
+};
+
+
+static PyMethodDef DBLogCursor_methods[] = {
+    {"close",   (PyCFunction)DBLogCursor_close,     METH_NOARGS},
+    {"current", (PyCFunction)DBLogCursor_current,   METH_NOARGS},
+    {"first",   (PyCFunction)DBLogCursor_first,     METH_NOARGS},
+    {"last",    (PyCFunction)DBLogCursor_last,      METH_NOARGS},
+    {"next",    (PyCFunction)DBLogCursor_next,      METH_NOARGS},
+    {"prev",    (PyCFunction)DBLogCursor_prev,      METH_NOARGS},
+    {"set",     (PyCFunction)DBLogCursor_set,       METH_VARARGS},
     {NULL,      NULL}       /* sentinel */
 };
 
@@ -6503,64 +8616,156 @@ static PyMethodDef DBEnv_methods[] = {
     {"close",           (PyCFunction)DBEnv_close,            METH_VARARGS},
     {"open",            (PyCFunction)DBEnv_open,             METH_VARARGS},
     {"remove",          (PyCFunction)DBEnv_remove,           METH_VARARGS},
-#if (DBVER >= 41)
     {"dbremove",        (PyCFunction)DBEnv_dbremove,         METH_VARARGS|METH_KEYWORDS},
     {"dbrename",        (PyCFunction)DBEnv_dbrename,         METH_VARARGS|METH_KEYWORDS},
+#if (DBVER >= 46)
+    {"set_thread_count", (PyCFunction)DBEnv_set_thread_count, METH_VARARGS},
+    {"get_thread_count", (PyCFunction)DBEnv_get_thread_count, METH_NOARGS},
+#endif
     {"set_encrypt",     (PyCFunction)DBEnv_set_encrypt,      METH_VARARGS|METH_KEYWORDS},
+    {"get_encrypt_flags", (PyCFunction)DBEnv_get_encrypt_flags, METH_NOARGS},
+    {"get_timeout",     (PyCFunction)DBEnv_get_timeout,
+        METH_VARARGS|METH_KEYWORDS},
+    {"set_timeout",     (PyCFunction)DBEnv_set_timeout,     METH_VARARGS|METH_KEYWORDS},
+    {"set_shm_key",     (PyCFunction)DBEnv_set_shm_key,     METH_VARARGS},
+    {"get_shm_key",     (PyCFunction)DBEnv_get_shm_key,     METH_NOARGS},
+#if (DBVER >= 46)
+    {"set_cache_max",   (PyCFunction)DBEnv_set_cache_max,   METH_VARARGS},
+    {"get_cache_max",   (PyCFunction)DBEnv_get_cache_max,   METH_NOARGS},
+#endif
+    {"set_cachesize",   (PyCFunction)DBEnv_set_cachesize,   METH_VARARGS},
+    {"get_cachesize",   (PyCFunction)DBEnv_get_cachesize,   METH_NOARGS},
+    {"memp_trickle",    (PyCFunction)DBEnv_memp_trickle,    METH_VARARGS},
+    {"memp_sync",       (PyCFunction)DBEnv_memp_sync,       METH_VARARGS},
+    {"memp_stat",       (PyCFunction)DBEnv_memp_stat,
+        METH_VARARGS|METH_KEYWORDS},
+#if (DBVER >= 43)
+    {"memp_stat_print", (PyCFunction)DBEnv_memp_stat_print,
+        METH_VARARGS|METH_KEYWORDS},
+#endif
+#if (DBVER >= 44)
+    {"mutex_set_max",   (PyCFunction)DBEnv_mutex_set_max,   METH_VARARGS},
+    {"mutex_get_max",   (PyCFunction)DBEnv_mutex_get_max,   METH_NOARGS},
+    {"mutex_set_align", (PyCFunction)DBEnv_mutex_set_align, METH_VARARGS},
+    {"mutex_get_align", (PyCFunction)DBEnv_mutex_get_align, METH_NOARGS},
+    {"mutex_set_increment", (PyCFunction)DBEnv_mutex_set_increment,
+        METH_VARARGS},
+    {"mutex_get_increment", (PyCFunction)DBEnv_mutex_get_increment,
+        METH_NOARGS},
+    {"mutex_set_tas_spins", (PyCFunction)DBEnv_mutex_set_tas_spins,
+        METH_VARARGS},
+    {"mutex_get_tas_spins", (PyCFunction)DBEnv_mutex_get_tas_spins,
+        METH_NOARGS},
+    {"mutex_stat",      (PyCFunction)DBEnv_mutex_stat,      METH_VARARGS},
+#if (DBVER >= 44)
+    {"mutex_stat_print", (PyCFunction)DBEnv_mutex_stat_print,
+                                         METH_VARARGS|METH_KEYWORDS},
 #endif
-    {"set_timeout",     (PyCFunction)DBEnv_set_timeout,      METH_VARARGS|METH_KEYWORDS},
-    {"set_shm_key",     (PyCFunction)DBEnv_set_shm_key,      METH_VARARGS},
-    {"set_cachesize",   (PyCFunction)DBEnv_set_cachesize,    METH_VARARGS},
-    {"set_data_dir",    (PyCFunction)DBEnv_set_data_dir,     METH_VARARGS},
-    {"set_flags",       (PyCFunction)DBEnv_set_flags,        METH_VARARGS},
-#if (DBVER >= 47)
-    {"log_set_config",  (PyCFunction)DBEnv_log_set_config,   METH_VARARGS},
 #endif
-    {"set_lg_bsize",    (PyCFunction)DBEnv_set_lg_bsize,     METH_VARARGS},
-    {"set_lg_dir",      (PyCFunction)DBEnv_set_lg_dir,       METH_VARARGS},
-    {"set_lg_max",      (PyCFunction)DBEnv_set_lg_max,       METH_VARARGS},
-#if (DBVER >= 42)
-    {"get_lg_max",      (PyCFunction)DBEnv_get_lg_max,       METH_NOARGS},
+    {"set_data_dir",    (PyCFunction)DBEnv_set_data_dir,    METH_VARARGS},
+    {"get_data_dirs",   (PyCFunction)DBEnv_get_data_dirs,   METH_NOARGS},
+    {"get_flags",       (PyCFunction)DBEnv_get_flags,       METH_NOARGS},
+    {"set_flags",       (PyCFunction)DBEnv_set_flags,       METH_VARARGS},
+#if (DBVER >= 47)
+    {"log_set_config",  (PyCFunction)DBEnv_log_set_config,  METH_VARARGS},
+    {"log_get_config",  (PyCFunction)DBEnv_log_get_config,  METH_VARARGS},
 #endif
+    {"set_lg_bsize",    (PyCFunction)DBEnv_set_lg_bsize,    METH_VARARGS},
+    {"get_lg_bsize",    (PyCFunction)DBEnv_get_lg_bsize,    METH_NOARGS},
+    {"set_lg_dir",      (PyCFunction)DBEnv_set_lg_dir,      METH_VARARGS},
+    {"get_lg_dir",      (PyCFunction)DBEnv_get_lg_dir,      METH_NOARGS},
+    {"set_lg_max",      (PyCFunction)DBEnv_set_lg_max,      METH_VARARGS},
+    {"get_lg_max",      (PyCFunction)DBEnv_get_lg_max,      METH_NOARGS},
     {"set_lg_regionmax",(PyCFunction)DBEnv_set_lg_regionmax, METH_VARARGS},
-    {"set_lk_detect",   (PyCFunction)DBEnv_set_lk_detect,    METH_VARARGS},
+    {"get_lg_regionmax",(PyCFunction)DBEnv_get_lg_regionmax, METH_NOARGS},
+#if (DBVER >= 44)
+    {"set_lg_filemode", (PyCFunction)DBEnv_set_lg_filemode, METH_VARARGS},
+    {"get_lg_filemode", (PyCFunction)DBEnv_get_lg_filemode, METH_NOARGS},
+#endif
+#if (DBVER >= 47)
+    {"set_lk_partitions", (PyCFunction)DBEnv_set_lk_partitions, METH_VARARGS},
+    {"get_lk_partitions", (PyCFunction)DBEnv_get_lk_partitions, METH_NOARGS},
+#endif
+    {"set_lk_detect",   (PyCFunction)DBEnv_set_lk_detect,   METH_VARARGS},
+    {"get_lk_detect",   (PyCFunction)DBEnv_get_lk_detect,   METH_NOARGS},
 #if (DBVER < 45)
-    {"set_lk_max",      (PyCFunction)DBEnv_set_lk_max,       METH_VARARGS},
+    {"set_lk_max",      (PyCFunction)DBEnv_set_lk_max,      METH_VARARGS},
 #endif
     {"set_lk_max_locks", (PyCFunction)DBEnv_set_lk_max_locks, METH_VARARGS},
+    {"get_lk_max_locks", (PyCFunction)DBEnv_get_lk_max_locks, METH_NOARGS},
     {"set_lk_max_lockers", (PyCFunction)DBEnv_set_lk_max_lockers, METH_VARARGS},
+    {"get_lk_max_lockers", (PyCFunction)DBEnv_get_lk_max_lockers, METH_NOARGS},
     {"set_lk_max_objects", (PyCFunction)DBEnv_set_lk_max_objects, METH_VARARGS},
-    {"set_mp_mmapsize", (PyCFunction)DBEnv_set_mp_mmapsize,  METH_VARARGS},
-    {"set_tmp_dir",     (PyCFunction)DBEnv_set_tmp_dir,      METH_VARARGS},
-    {"txn_begin",       (PyCFunction)DBEnv_txn_begin,        METH_VARARGS|METH_KEYWORDS},
-    {"txn_checkpoint",  (PyCFunction)DBEnv_txn_checkpoint,   METH_VARARGS},
-    {"txn_stat",        (PyCFunction)DBEnv_txn_stat,         METH_VARARGS},
-    {"set_tx_max",      (PyCFunction)DBEnv_set_tx_max,       METH_VARARGS},
+    {"get_lk_max_objects", (PyCFunction)DBEnv_get_lk_max_objects, METH_NOARGS},
+#if (DBVER >= 43)
+    {"stat_print",          (PyCFunction)DBEnv_stat_print,
+        METH_VARARGS|METH_KEYWORDS},
+#endif
+    {"set_mp_mmapsize", (PyCFunction)DBEnv_set_mp_mmapsize, METH_VARARGS},
+    {"get_mp_mmapsize", (PyCFunction)DBEnv_get_mp_mmapsize, METH_NOARGS},
+    {"set_tmp_dir",     (PyCFunction)DBEnv_set_tmp_dir,     METH_VARARGS},
+    {"get_tmp_dir",     (PyCFunction)DBEnv_get_tmp_dir,     METH_NOARGS},
+    {"txn_begin",       (PyCFunction)DBEnv_txn_begin,       METH_VARARGS|METH_KEYWORDS},
+    {"txn_checkpoint",  (PyCFunction)DBEnv_txn_checkpoint,  METH_VARARGS},
+    {"txn_stat",        (PyCFunction)DBEnv_txn_stat,        METH_VARARGS},
+#if (DBVER >= 43)
+    {"txn_stat_print",  (PyCFunction)DBEnv_txn_stat_print,
+        METH_VARARGS|METH_KEYWORDS},
+#endif
+    {"get_tx_max",      (PyCFunction)DBEnv_get_tx_max,      METH_NOARGS},
+    {"get_tx_timestamp", (PyCFunction)DBEnv_get_tx_timestamp, METH_NOARGS},
+    {"set_tx_max",      (PyCFunction)DBEnv_set_tx_max,      METH_VARARGS},
     {"set_tx_timestamp", (PyCFunction)DBEnv_set_tx_timestamp, METH_VARARGS},
-    {"lock_detect",     (PyCFunction)DBEnv_lock_detect,      METH_VARARGS},
-    {"lock_get",        (PyCFunction)DBEnv_lock_get,         METH_VARARGS},
-    {"lock_id",         (PyCFunction)DBEnv_lock_id,          METH_NOARGS},
-    {"lock_id_free",    (PyCFunction)DBEnv_lock_id_free,     METH_VARARGS},
-    {"lock_put",        (PyCFunction)DBEnv_lock_put,         METH_VARARGS},
-    {"lock_stat",       (PyCFunction)DBEnv_lock_stat,        METH_VARARGS},
-    {"log_archive",     (PyCFunction)DBEnv_log_archive,      METH_VARARGS},
-    {"log_flush",       (PyCFunction)DBEnv_log_flush,        METH_NOARGS},
-    {"log_stat",        (PyCFunction)DBEnv_log_stat,         METH_VARARGS},
+    {"lock_detect",     (PyCFunction)DBEnv_lock_detect,     METH_VARARGS},
+    {"lock_get",        (PyCFunction)DBEnv_lock_get,        METH_VARARGS},
+    {"lock_id",         (PyCFunction)DBEnv_lock_id,         METH_NOARGS},
+    {"lock_id_free",    (PyCFunction)DBEnv_lock_id_free,    METH_VARARGS},
+    {"lock_put",        (PyCFunction)DBEnv_lock_put,        METH_VARARGS},
+    {"lock_stat",       (PyCFunction)DBEnv_lock_stat,       METH_VARARGS},
+#if (DBVER >= 43)
+    {"lock_stat_print", (PyCFunction)DBEnv_lock_stat_print,
+        METH_VARARGS|METH_KEYWORDS},
+#endif
+    {"log_cursor",      (PyCFunction)DBEnv_log_cursor,      METH_NOARGS},
+    {"log_file",        (PyCFunction)DBEnv_log_file,        METH_VARARGS},
 #if (DBVER >= 44)
-    {"lsn_reset",       (PyCFunction)DBEnv_lsn_reset,        METH_VARARGS|METH_KEYWORDS},
+    {"log_printf",      (PyCFunction)DBEnv_log_printf,
+        METH_VARARGS|METH_KEYWORDS},
+#endif
+    {"log_archive",     (PyCFunction)DBEnv_log_archive,     METH_VARARGS},
+    {"log_flush",       (PyCFunction)DBEnv_log_flush,       METH_NOARGS},
+    {"log_stat",        (PyCFunction)DBEnv_log_stat,        METH_VARARGS},
+#if (DBVER >= 43)
+    {"log_stat_print",  (PyCFunction)DBEnv_log_stat_print,
+        METH_VARARGS|METH_KEYWORDS},
+#endif
+#if (DBVER >= 44)
+    {"fileid_reset",    (PyCFunction)DBEnv_fileid_reset,    METH_VARARGS|METH_KEYWORDS},
+    {"lsn_reset",       (PyCFunction)DBEnv_lsn_reset,       METH_VARARGS|METH_KEYWORDS},
 #endif
     {"set_get_returns_none",(PyCFunction)DBEnv_set_get_returns_none, METH_VARARGS},
-    {"txn_recover",     (PyCFunction)DBEnv_txn_recover,       METH_NOARGS},
+    {"txn_recover",     (PyCFunction)DBEnv_txn_recover,     METH_NOARGS},
 #if (DBVER < 48)
     {"set_rpc_server",  (PyCFunction)DBEnv_set_rpc_server,
-        METH_VARARGS||METH_KEYWORDS},
+        METH_VARARGS|METH_KEYWORDS},
 #endif
-    {"set_verbose",     (PyCFunction)DBEnv_set_verbose,       METH_VARARGS},
-#if (DBVER >= 42)
-    {"get_verbose",     (PyCFunction)DBEnv_get_verbose,       METH_VARARGS},
+#if (DBVER >= 43)
+    {"set_mp_max_openfd", (PyCFunction)DBEnv_set_mp_max_openfd, METH_VARARGS},
+    {"get_mp_max_openfd", (PyCFunction)DBEnv_get_mp_max_openfd, METH_NOARGS},
+    {"set_mp_max_write", (PyCFunction)DBEnv_set_mp_max_write, METH_VARARGS},
+    {"get_mp_max_write", (PyCFunction)DBEnv_get_mp_max_write, METH_NOARGS},
+#endif
+    {"set_verbose",     (PyCFunction)DBEnv_set_verbose,     METH_VARARGS},
+    {"get_verbose",     (PyCFunction)DBEnv_get_verbose,     METH_VARARGS},
+    {"set_private",     (PyCFunction)DBEnv_set_private,     METH_O},
+    {"get_private",     (PyCFunction)DBEnv_get_private,     METH_NOARGS},
+    {"get_open_flags",  (PyCFunction)DBEnv_get_open_flags,  METH_NOARGS},
+#if (DBVER >= 47)
+    {"set_intermediate_dir_mode", (PyCFunction)DBEnv_set_intermediate_dir_mode,
+        METH_VARARGS},
+    {"get_intermediate_dir_mode", (PyCFunction)DBEnv_get_intermediate_dir_mode,
+        METH_NOARGS},
 #endif
-    {"set_private",     (PyCFunction)DBEnv_set_private,       METH_O},
-    {"get_private",     (PyCFunction)DBEnv_get_private,       METH_NOARGS},
     {"rep_start",       (PyCFunction)DBEnv_rep_start,
         METH_VARARGS|METH_KEYWORDS},
     {"rep_set_transport", (PyCFunction)DBEnv_rep_set_transport, METH_VARARGS},
@@ -6593,6 +8798,17 @@ static PyMethodDef DBEnv_methods[] = {
     {"rep_set_timeout", (PyCFunction)DBEnv_rep_set_timeout, METH_VARARGS},
     {"rep_get_timeout", (PyCFunction)DBEnv_rep_get_timeout, METH_VARARGS},
 #endif
+#if (DBVER >= 47)
+    {"rep_set_clockskew", (PyCFunction)DBEnv_rep_set_clockskew, METH_VARARGS},
+    {"rep_get_clockskew", (PyCFunction)DBEnv_rep_get_clockskew, METH_VARARGS},
+#endif
+    {"rep_stat", (PyCFunction)DBEnv_rep_stat,
+        METH_VARARGS|METH_KEYWORDS},
+#if (DBVER >= 43)
+    {"rep_stat_print", (PyCFunction)DBEnv_rep_stat_print,
+        METH_VARARGS|METH_KEYWORDS},
+#endif
+
 #if (DBVER >= 45)
     {"repmgr_start", (PyCFunction)DBEnv_repmgr_start,
         METH_VARARGS|METH_KEYWORDS},
@@ -6623,6 +8839,12 @@ static PyMethodDef DBTxn_methods[] = {
     {"discard",         (PyCFunction)DBTxn_discard,     METH_NOARGS},
     {"abort",           (PyCFunction)DBTxn_abort,       METH_NOARGS},
     {"id",              (PyCFunction)DBTxn_id,          METH_NOARGS},
+    {"set_timeout",     (PyCFunction)DBTxn_set_timeout,
+        METH_VARARGS|METH_KEYWORDS},
+#if (DBVER >= 44)
+    {"set_name",        (PyCFunction)DBTxn_set_name, METH_VARARGS},
+    {"get_name",        (PyCFunction)DBTxn_get_name, METH_NOARGS},
+#endif
     {NULL,      NULL}       /* sentinel */
 };
 
@@ -6633,7 +8855,7 @@ static PyMethodDef DBSequence_methods[]
     {"get",             (PyCFunction)DBSequence_get,            METH_VARARGS|METH_KEYWORDS},
     {"get_dbp",         (PyCFunction)DBSequence_get_dbp,        METH_NOARGS},
     {"get_key",         (PyCFunction)DBSequence_get_key,        METH_NOARGS},
-    {"init_value",      (PyCFunction)DBSequence_init_value,     METH_VARARGS},
+    {"initial_value",   (PyCFunction)DBSequence_initial_value,  METH_VARARGS},
     {"open",            (PyCFunction)DBSequence_open,           METH_VARARGS|METH_KEYWORDS},
     {"remove",          (PyCFunction)DBSequence_remove,         METH_VARARGS|METH_KEYWORDS},
     {"set_cachesize",   (PyCFunction)DBSequence_set_cachesize,  METH_VARARGS},
@@ -6643,6 +8865,8 @@ static PyMethodDef DBSequence_methods[]
     {"set_range",       (PyCFunction)DBSequence_set_range,      METH_VARARGS},
     {"get_range",       (PyCFunction)DBSequence_get_range,      METH_NOARGS},
     {"stat",            (PyCFunction)DBSequence_stat,           METH_VARARGS|METH_KEYWORDS},
+    {"stat_print",      (PyCFunction)DBSequence_stat_print,
+        METH_VARARGS|METH_KEYWORDS},
     {NULL,      NULL}       /* sentinel */
 };
 #endif
@@ -6655,11 +8879,9 @@ DBEnv_db_home_get(DBEnvObject* self)
 
     CHECK_ENV_NOT_CLOSED(self);
 
-#if (DBVER >= 42)
+    MYDB_BEGIN_ALLOW_THREADS;
     self->db_env->get_home(self->db_env, &home);
-#else
-    home=self->db_env->db_home;
-#endif
+    MYDB_END_ALLOW_THREADS;
 
     if (home == NULL) {
         RETURN_NONE();
@@ -6691,7 +8913,7 @@ statichere PyTypeObject DB_Type = {
     0,          /*tp_compare*/
     0,          /*tp_repr*/
     0,          /*tp_as_number*/
-    0,          /*tp_as_sequence*/
+    &DB_sequence,/*tp_as_sequence*/
     &DB_mapping,/*tp_as_mapping*/
     0,          /*tp_hash*/
     0,                  /* tp_call */
@@ -6759,6 +8981,49 @@ statichere PyTypeObject DBCursor_Type =
 };
 
 
+statichere PyTypeObject DBLogCursor_Type = {
+#if (PY_VERSION_HEX < 0x03000000)
+    PyObject_HEAD_INIT(NULL)
+    0,                  /*ob_size*/
+#else
+    PyVarObject_HEAD_INIT(NULL, 0)
+#endif
+    "DBLogCursor",         /*tp_name*/
+    sizeof(DBLogCursorObject),  /*tp_basicsize*/
+    0,          /*tp_itemsize*/
+    /* methods */
+    (destructor)DBLogCursor_dealloc,/*tp_dealloc*/
+    0,          /*tp_print*/
+    0,          /*tp_getattr*/
+    0,          /*tp_setattr*/
+    0,          /*tp_compare*/
+    0,          /*tp_repr*/
+    0,          /*tp_as_number*/
+    0,          /*tp_as_sequence*/
+    0,          /*tp_as_mapping*/
+    0,          /*tp_hash*/
+    0,          /*tp_call*/
+    0,          /*tp_str*/
+    0,          /*tp_getattro*/
+    0,          /*tp_setattro*/
+    0,          /*tp_as_buffer*/
+#if (PY_VERSION_HEX < 0x03000000)
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_WEAKREFS,      /* tp_flags */
+#else
+    Py_TPFLAGS_DEFAULT,      /* tp_flags */
+#endif
+    0,          /* tp_doc */
+    0,          /* tp_traverse */
+    0,          /* tp_clear */
+    0,          /* tp_richcompare */
+    offsetof(DBLogCursorObject, in_weakreflist),   /* tp_weaklistoffset */
+    0,          /*tp_iter*/
+    0,          /*tp_iternext*/
+    DBLogCursor_methods, /*tp_methods*/
+    0,          /*tp_members*/
+};
+
+
 statichere PyTypeObject DBEnv_Type = {
 #if (PY_VERSION_HEX < 0x03000000)
     PyObject_HEAD_INIT(NULL)
@@ -6986,10 +9251,25 @@ bsddb_version(PyObject* self)
 {
     int major, minor, patch;
 
+    /* This should be instantaneous, no need to release the GIL */
     db_version(&major, &minor, &patch);
     return Py_BuildValue("(iii)", major, minor, patch);
 }
 
+#if (DBVER >= 50)
+static PyObject*
+bsddb_version_full(PyObject* self)
+{
+    char *version_string;
+    int family, release, major, minor, patch;
+
+    /* This should be instantaneous, no need to release the GIL */
+    version_string = db_full_version(&family, &release, &major, &minor, &patch);
+    return Py_BuildValue("(siiiii)",
+            version_string, family, release, major, minor, patch);
+}
+#endif
+
 
 /* List of functions defined in the module */
 static PyMethodDef bsddb_methods[] = {
@@ -6999,6 +9279,9 @@ static PyMethodDef bsddb_methods[] = {
     {"DBSequence",  (PyCFunction)DBSequence_construct,  METH_VARARGS | METH_KEYWORDS },
 #endif
     {"version",     (PyCFunction)bsddb_version,         METH_NOARGS, bsddb_version_doc},
+#if (DBVER >= 50)
+    {"full_version", (PyCFunction)bsddb_version_full, METH_NOARGS},
+#endif
     {NULL,      NULL}       /* sentinel */
 };
 
@@ -7016,6 +9299,11 @@ static BSDDB_api bsddb_api;
  */
 #define ADD_INT(dict, NAME)         _addIntToDict(dict, #NAME, NAME)
 
+/*
+** We can rename the module at import time, so the string allocated
+** must be big enough, and any use of the name must use this particular
+** string.
+*/
 #define MODULE_NAME_MAX_LEN     11
 static char _bsddbModuleName[MODULE_NAME_MAX_LEN+1] = "_bsddb";
 
@@ -7043,14 +9331,26 @@ PyMODINIT_FUNC  PyInit__bsddb(void)    /
 {
     PyObject* m;
     PyObject* d;
-    PyObject* pybsddb_version_s = PyBytes_FromString( PY_BSDDB_VERSION );
-    PyObject* db_version_s = PyBytes_FromString( DB_VERSION_STRING );
-    PyObject* cvsid_s = PyBytes_FromString( rcs_id );
     PyObject* py_api;
+    PyObject* pybsddb_version_s;
+    PyObject* db_version_s;
+    PyObject* cvsid_s;
+
+#if (PY_VERSION_HEX < 0x03000000)
+    pybsddb_version_s = PyString_FromString(PY_BSDDB_VERSION);
+    db_version_s = PyString_FromString(DB_VERSION_STRING);
+    cvsid_s = PyString_FromString(rcs_id);
+#else
+    /* This data should be ascii, so UTF-8 conversion is fine */
+    pybsddb_version_s = PyUnicode_FromString(PY_BSDDB_VERSION);
+    db_version_s = PyUnicode_FromString(DB_VERSION_STRING);
+    cvsid_s = PyUnicode_FromString(rcs_id);
+#endif
 
     /* Initialize object types */
     if ((PyType_Ready(&DB_Type) < 0)
         || (PyType_Ready(&DBCursor_Type) < 0)
+        || (PyType_Ready(&DBLogCursor_Type) < 0)
         || (PyType_Ready(&DBEnv_Type) < 0)
         || (PyType_Ready(&DBTxn_Type) < 0)
         || (PyType_Ready(&DBLock_Type) < 0)
@@ -7104,13 +9404,7 @@ PyMODINIT_FUNC  PyInit__bsddb(void)    /
     ADD_INT(d, DB_MAX_RECORDS);
 
 #if (DBVER < 48)
-#if (DBVER >= 42)
     ADD_INT(d, DB_RPCCLIENT);
-#else
-    ADD_INT(d, DB_CLIENT);
-    /* allow apps to be written using DB_RPCCLIENT on older Berkeley DB */
-    _addIntToDict(d, "DB_RPCCLIENT", DB_CLIENT);
-#endif
 #endif
 
 #if (DBVER < 48)
@@ -7153,6 +9447,18 @@ PyMODINIT_FUNC  PyInit__bsddb(void)    /
     ADD_INT(d, DB_TXN_SYNC);
     ADD_INT(d, DB_TXN_NOWAIT);
 
+#if (DBVER >= 51)
+    ADD_INT(d, DB_TXN_BULK);
+#endif
+
+#if (DBVER >= 48)
+    ADD_INT(d, DB_CURSOR_BULK);
+#endif
+
+#if (DBVER >= 46)
+    ADD_INT(d, DB_TXN_WAIT);
+#endif
+
     ADD_INT(d, DB_EXCL);
     ADD_INT(d, DB_FCNTL_LOCKING);
     ADD_INT(d, DB_ODDFILESIZE);
@@ -7164,6 +9470,7 @@ PyMODINIT_FUNC  PyInit__bsddb(void)    /
     ADD_INT(d, DB_VERIFY);
     ADD_INT(d, DB_UPGRADE);
 
+    ADD_INT(d, DB_PRINTABLE);
     ADD_INT(d, DB_AGGRESSIVE);
     ADD_INT(d, DB_NOORDERCHK);
     ADD_INT(d, DB_ORDERCHKONLY);
@@ -7232,9 +9539,7 @@ PyMODINIT_FUNC  PyInit__bsddb(void)    /
     ADD_INT(d, DB_ARCH_ABS);
     ADD_INT(d, DB_ARCH_DATA);
     ADD_INT(d, DB_ARCH_LOG);
-#if (DBVER >= 42)
     ADD_INT(d, DB_ARCH_REMOVE);
-#endif
 
     ADD_INT(d, DB_BTREE);
     ADD_INT(d, DB_HASH);
@@ -7249,6 +9554,10 @@ PyMODINIT_FUNC  PyInit__bsddb(void)    /
     ADD_INT(d, DB_REVSPLITOFF);
     ADD_INT(d, DB_SNAPSHOT);
 
+#if (DBVER >= 43)
+    ADD_INT(d, DB_INORDER);
+#endif
+
     ADD_INT(d, DB_JOIN_NOSORT);
 
     ADD_INT(d, DB_AFTER);
@@ -7258,15 +9567,6 @@ PyMODINIT_FUNC  PyInit__bsddb(void)    /
     ADD_INT(d, DB_CACHED_COUNTS);
 #endif
 
-#if (DBVER >= 41)
-    _addIntToDict(d, "DB_CHECKPOINT", 0);
-#else
-    ADD_INT(d, DB_CHECKPOINT);
-    ADD_INT(d, DB_CURLSN);
-#endif
-#if (DBVER <= 41)
-    ADD_INT(d, DB_COMMIT);
-#endif
     ADD_INT(d, DB_CONSUME);
     ADD_INT(d, DB_CONSUME_WAIT);
     ADD_INT(d, DB_CURRENT);
@@ -7274,6 +9574,7 @@ PyMODINIT_FUNC  PyInit__bsddb(void)    /
     ADD_INT(d, DB_FIRST);
     ADD_INT(d, DB_FLUSH);
     ADD_INT(d, DB_GET_BOTH);
+    ADD_INT(d, DB_GET_BOTH_RANGE);
     ADD_INT(d, DB_GET_RECNO);
     ADD_INT(d, DB_JOIN_ITEM);
     ADD_INT(d, DB_KEYFIRST);
@@ -7288,6 +9589,9 @@ PyMODINIT_FUNC  PyInit__bsddb(void)    /
     ADD_INT(d, DB_POSITION);
     ADD_INT(d, DB_PREV);
     ADD_INT(d, DB_PREV_NODUP);
+#if (DBVER >= 46)
+    ADD_INT(d, DB_PREV_DUP);
+#endif
 #if (DBVER < 45)
     ADD_INT(d, DB_RECORDCOUNT);
 #endif
@@ -7303,17 +9607,18 @@ PyMODINIT_FUNC  PyInit__bsddb(void)    /
     ADD_INT(d, DB_MULTIPLE_KEY);
 
 #if (DBVER >= 44)
+    ADD_INT(d, DB_IMMUTABLE_KEY);
     ADD_INT(d, DB_READ_UNCOMMITTED);    /* replaces DB_DIRTY_READ in 4.4 */
     ADD_INT(d, DB_READ_COMMITTED);
 #endif
 
+#if (DBVER >= 44)
+    ADD_INT(d, DB_FREELIST_ONLY);
+    ADD_INT(d, DB_FREE_SPACE);
+#endif
+
     ADD_INT(d, DB_DONOTINDEX);
 
-#if (DBVER >= 41)
-    _addIntToDict(d, "DB_INCOMPLETE", 0);
-#else
-    ADD_INT(d, DB_INCOMPLETE);
-#endif
     ADD_INT(d, DB_KEYEMPTY);
     ADD_INT(d, DB_KEYEXIST);
     ADD_INT(d, DB_LOCK_DEADLOCK);
@@ -7334,15 +9639,34 @@ PyMODINIT_FUNC  PyInit__bsddb(void)    /
     ADD_INT(d, DB_PANIC_ENVIRONMENT);
     ADD_INT(d, DB_NOPANIC);
 
-#if (DBVER >= 41)
     ADD_INT(d, DB_OVERWRITE);
+
+#if (DBVER >= 43)
+    ADD_INT(d, DB_STAT_SUBSYSTEM);
+    ADD_INT(d, DB_STAT_MEMP_HASH);
+    ADD_INT(d, DB_STAT_LOCK_CONF);
+    ADD_INT(d, DB_STAT_LOCK_LOCKERS);
+    ADD_INT(d, DB_STAT_LOCK_OBJECTS);
+    ADD_INT(d, DB_STAT_LOCK_PARAMS);
+#endif
+
+#if (DBVER >= 48)
+    ADD_INT(d, DB_OVERWRITE_DUP);
+#endif
+
+#if (DBVER >= 47)
+    ADD_INT(d, DB_FOREIGN_ABORT);
+    ADD_INT(d, DB_FOREIGN_CASCADE);
+    ADD_INT(d, DB_FOREIGN_NULLIFY);
 #endif
 
-#ifdef DB_REGISTER
+#if (DBVER >= 44)
     ADD_INT(d, DB_REGISTER);
 #endif
 
-#if (DBVER >= 42)
+    ADD_INT(d, DB_EID_INVALID);
+    ADD_INT(d, DB_EID_BROADCAST);
+
     ADD_INT(d, DB_TIME_NOTGRANTED);
     ADD_INT(d, DB_TXN_NOT_DURABLE);
     ADD_INT(d, DB_TXN_WRITE_NOSYNC);
@@ -7350,9 +9674,8 @@ PyMODINIT_FUNC  PyInit__bsddb(void)    /
     ADD_INT(d, DB_INIT_REP);
     ADD_INT(d, DB_ENCRYPT);
     ADD_INT(d, DB_CHKSUM);
-#endif
 
-#if (DBVER >= 42) && (DBVER < 47)
+#if (DBVER < 47)
     ADD_INT(d, DB_LOG_AUTOREMOVE);
     ADD_INT(d, DB_DIRECT_LOG);
 #endif
@@ -7385,6 +9708,20 @@ PyMODINIT_FUNC  PyInit__bsddb(void)    /
     ADD_INT(d, DB_VERB_REPLICATION);
     ADD_INT(d, DB_VERB_WAITSFOR);
 
+#if (DBVER >= 50)
+    ADD_INT(d, DB_VERB_REP_SYSTEM);
+#endif
+
+#if (DBVER >= 47)
+    ADD_INT(d, DB_VERB_REP_ELECT);
+    ADD_INT(d, DB_VERB_REP_LEASE);
+    ADD_INT(d, DB_VERB_REP_MISC);
+    ADD_INT(d, DB_VERB_REP_MSGS);
+    ADD_INT(d, DB_VERB_REP_SYNC);
+    ADD_INT(d, DB_VERB_REPMGR_CONNFAIL);
+    ADD_INT(d, DB_VERB_REPMGR_MISC);
+#endif
+
 #if (DBVER >= 45)
     ADD_INT(d, DB_EVENT_PANIC);
     ADD_INT(d, DB_EVENT_REP_CLIENT);
@@ -7400,20 +9737,59 @@ PyMODINIT_FUNC  PyInit__bsddb(void)    /
     ADD_INT(d, DB_EVENT_WRITE_FAILED);
 #endif
 
+#if (DBVER >= 50)
+    ADD_INT(d, DB_REPMGR_CONF_ELECTIONS);
+    ADD_INT(d, DB_EVENT_REP_MASTER_FAILURE);
+    ADD_INT(d, DB_EVENT_REP_DUPMASTER);
+    ADD_INT(d, DB_EVENT_REP_ELECTION_FAILED);
+#endif
+#if (DBVER >= 48)
+    ADD_INT(d, DB_EVENT_REG_ALIVE);
+    ADD_INT(d, DB_EVENT_REG_PANIC);
+#endif
+
     ADD_INT(d, DB_REP_DUPMASTER);
     ADD_INT(d, DB_REP_HOLDELECTION);
 #if (DBVER >= 44)
     ADD_INT(d, DB_REP_IGNORE);
     ADD_INT(d, DB_REP_JOIN_FAILURE);
 #endif
-#if (DBVER >= 42)
     ADD_INT(d, DB_REP_ISPERM);
     ADD_INT(d, DB_REP_NOTPERM);
-#endif
     ADD_INT(d, DB_REP_NEWSITE);
 
     ADD_INT(d, DB_REP_MASTER);
     ADD_INT(d, DB_REP_CLIENT);
+
+    ADD_INT(d, DB_REP_PERMANENT);
+
+#if (DBVER >= 44)
+#if (DBVER >= 50)
+    ADD_INT(d, DB_REP_CONF_AUTOINIT);
+#else
+    ADD_INT(d, DB_REP_CONF_NOAUTOINIT);
+#endif /* 5.0 */
+#endif /* 4.4 */
+#if (DBVER >= 44)
+    ADD_INT(d, DB_REP_CONF_DELAYCLIENT);
+    ADD_INT(d, DB_REP_CONF_BULK);
+    ADD_INT(d, DB_REP_CONF_NOWAIT);
+    ADD_INT(d, DB_REP_ANYWHERE);
+    ADD_INT(d, DB_REP_REREQUEST);
+#endif
+
+    ADD_INT(d, DB_REP_NOBUFFER);
+
+#if (DBVER >= 46)
+    ADD_INT(d, DB_REP_LEASE_EXPIRED);
+    ADD_INT(d, DB_IGNORE_LEASE);
+#endif
+
+#if (DBVER >= 47)
+    ADD_INT(d, DB_REP_CONF_LEASE);
+    ADD_INT(d, DB_REPMGR_CONF_2SITE_STRICT);
+#endif
+
 #if (DBVER >= 45)
     ADD_INT(d, DB_REP_ELECTION);
 
@@ -7425,6 +9801,11 @@ PyMODINIT_FUNC  PyInit__bsddb(void)    /
 #if (DBVER >= 46)
     ADD_INT(d, DB_REP_CHECKPOINT_DELAY);
     ADD_INT(d, DB_REP_FULL_ELECTION_TIMEOUT);
+    ADD_INT(d, DB_REP_LEASE_TIMEOUT);
+#endif
+#if (DBVER >= 47)
+    ADD_INT(d, DB_REP_HEARTBEAT_MONITOR);
+    ADD_INT(d, DB_REP_HEARTBEAT_SEND);
 #endif
 
 #if (DBVER >= 45)
@@ -7437,10 +9818,31 @@ PyMODINIT_FUNC  PyInit__bsddb(void)    /
     ADD_INT(d, DB_REPMGR_ACKS_QUORUM);
     ADD_INT(d, DB_REPMGR_CONNECTED);
     ADD_INT(d, DB_REPMGR_DISCONNECTED);
-    ADD_INT(d, DB_STAT_CLEAR);
     ADD_INT(d, DB_STAT_ALL);
 #endif
 
+#if (DBVER >= 51)
+    ADD_INT(d, DB_REPMGR_ACKS_ALL_AVAILABLE);
+#endif
+
+#if (DBVER >= 48)
+    ADD_INT(d, DB_REP_CONF_INMEM);
+#endif
+
+    ADD_INT(d, DB_TIMEOUT);
+
+#if (DBVER >= 50)
+    ADD_INT(d, DB_FORCESYNC);
+#endif
+
+#if (DBVER >= 48)
+    ADD_INT(d, DB_FAILCHK);
+#endif
+
+#if (DBVER >= 51)
+    ADD_INT(d, DB_HOTBACKUP_IN_PROGRESS);
+#endif
+
 #if (DBVER >= 43)
     ADD_INT(d, DB_BUFFER_SMALL);
     ADD_INT(d, DB_SEQ_DEC);
@@ -7453,12 +9855,16 @@ PyMODINIT_FUNC  PyInit__bsddb(void)    /
     ADD_INT(d, DB_DSYNC_LOG);
 #endif
 
-#if (DBVER >= 41)
     ADD_INT(d, DB_ENCRYPT_AES);
     ADD_INT(d, DB_AUTO_COMMIT);
-#else
-    /* allow Berkeley DB 4.1 aware apps to run on older versions */
-    _addIntToDict(d, "DB_AUTO_COMMIT", 0);
+    ADD_INT(d, DB_PRIORITY_VERY_LOW);
+    ADD_INT(d, DB_PRIORITY_LOW);
+    ADD_INT(d, DB_PRIORITY_DEFAULT);
+    ADD_INT(d, DB_PRIORITY_HIGH);
+    ADD_INT(d, DB_PRIORITY_VERY_HIGH);
+
+#if (DBVER >= 46)
+    ADD_INT(d, DB_PRIORITY_UNCHANGED);
 #endif
 
     ADD_INT(d, EINVAL);
@@ -7474,6 +9880,10 @@ PyMODINIT_FUNC  PyInit__bsddb(void)    /
     ADD_INT(d, DB_SET_LOCK_TIMEOUT);
     ADD_INT(d, DB_SET_TXN_TIMEOUT);
 
+#if (DBVER >= 48)
+    ADD_INT(d, DB_SET_REG_TIMEOUT);
+#endif
+
     /* The exception name must be correct for pickled exception *
      * objects to unpickle properly.                            */
 #ifdef PYBSDDB_STANDALONE  /* different value needed for standalone pybsddb */
@@ -7522,12 +9932,7 @@ PyMODINIT_FUNC  PyInit__bsddb(void)    /
     }
 #endif
 
-
-#if !INCOMPLETE_IS_WARNING
-    MAKE_EX(DBIncompleteError);
-#endif
     MAKE_EX(DBCursorClosedError);
-    MAKE_EX(DBKeyEmptyError);
     MAKE_EX(DBKeyExistError);
     MAKE_EX(DBLockDeadlockError);
     MAKE_EX(DBLockNotGrantedError);
@@ -7550,28 +9955,77 @@ PyMODINIT_FUNC  PyInit__bsddb(void)    /
     MAKE_EX(DBNoSuchFileError);
     MAKE_EX(DBPermissionsError);
 
-#if (DBVER >= 42)
     MAKE_EX(DBRepHandleDeadError);
+#if (DBVER >= 44)
+    MAKE_EX(DBRepLockoutError);
 #endif
 
     MAKE_EX(DBRepUnavailError);
 
+#if (DBVER >= 46)
+    MAKE_EX(DBRepLeaseExpiredError);
+#endif
+
+#if (DBVER >= 47)
+        MAKE_EX(DBForeignConflictError);
+#endif
+
 #undef MAKE_EX
 
-    /* Initiliase the C API structure and add it to the module */
-    bsddb_api.db_type         = &DB_Type;
-    bsddb_api.dbcursor_type   = &DBCursor_Type;
-    bsddb_api.dbenv_type      = &DBEnv_Type;
-    bsddb_api.dbtxn_type      = &DBTxn_Type;
-    bsddb_api.dblock_type     = &DBLock_Type;
+    /* Initialise the C API structure and add it to the module */
+    bsddb_api.api_version      = PYBSDDB_API_VERSION;
+    bsddb_api.db_type          = &DB_Type;
+    bsddb_api.dbcursor_type    = &DBCursor_Type;
+    bsddb_api.dblogcursor_type = &DBLogCursor_Type;
+    bsddb_api.dbenv_type       = &DBEnv_Type;
+    bsddb_api.dbtxn_type       = &DBTxn_Type;
+    bsddb_api.dblock_type      = &DBLock_Type;
 #if (DBVER >= 43)
-    bsddb_api.dbsequence_type = &DBSequence_Type;
+    bsddb_api.dbsequence_type  = &DBSequence_Type;
+#else
+    bsddb_api.dbsequence_type  = NULL;
 #endif
-    bsddb_api.makeDBError     = makeDBError;
+    bsddb_api.makeDBError      = makeDBError;
 
+    /*
+    ** Capsules exist from Python 2.7 and 3.1.
+    ** We don't support Python 3.0 anymore, so...
+    ** #if (PY_VERSION_HEX < ((PY_MAJOR_VERSION < 3) ? 0x02070000 : 0x03020000))
+    */
+#if (PY_VERSION_HEX < 0x02070000)
     py_api = PyCObject_FromVoidPtr((void*)&bsddb_api, NULL);
-    PyDict_SetItemString(d, "api", py_api);
-    Py_DECREF(py_api);
+#else
+    {
+        /*
+        ** The data must outlive the call!!. So, the static definition.
+        ** The buffer must be big enough...
+        */
+        static char py_api_name[MODULE_NAME_MAX_LEN+10];
+
+        strcpy(py_api_name, _bsddbModuleName);
+        strcat(py_api_name, ".api");
+
+        py_api = PyCapsule_New((void*)&bsddb_api, py_api_name, NULL);
+    }
+#endif
+
+    /* Check error control */
+    /*
+    ** PyErr_NoMemory();
+    ** py_api = NULL;
+    */
+
+    if (py_api) {
+        PyDict_SetItemString(d, "api", py_api);
+        Py_DECREF(py_api);
+    } else { /* Something bad happened */
+        PyErr_WriteUnraisable(m);
+        if(PyErr_Warn(PyExc_RuntimeWarning,
+                "_bsddb/_pybsddb C API will be not available")) {
+            PyErr_WriteUnraisable(m);
+        }
+        PyErr_Clear();
+    }
 
     /* Check for errors */
     if (PyErr_Occurred()) {
Index: python2.6-2.6.8/Lib/bsddb/test/test_queue.py
===================================================================
--- python2.6-2.6.8.orig/Lib/bsddb/test/test_queue.py
+++ python2.6-2.6.8/Lib/bsddb/test/test_queue.py
@@ -99,11 +99,6 @@ class SimpleQueueTestCase(unittest.TestC
             print '\n', '-=' * 30
             print "Running %s.test02_basicPost32..." % self.__class__.__name__
 
-        if db.version() < (3, 2, 0):
-            if verbose:
-                print "Test not run, DB not new enough..."
-            return
-
         d = db.DB()
         d.set_re_len(40)  # Queues must be fixed length
         d.open(self.filename, db.DB_QUEUE, db.DB_CREATE)
Index: python2.6-2.6.8/Modules/bsddb.h
===================================================================
--- python2.6-2.6.8.orig/Modules/bsddb.h
+++ python2.6-2.6.8/Modules/bsddb.h
@@ -70,6 +70,10 @@
  * DBLock       (A lock handle)
  * DBSequence   (Sequence)
  *
+ * New datatypes:
+ *
+ * DBLogCursor  (Log Cursor)
+ *
  */
 
 /* --------------------------------------------------------------------- */
@@ -105,7 +109,7 @@
 #error "eek! DBVER can't handle minor versions > 9"
 #endif
 
-#define PY_BSDDB_VERSION "4.7.3"
+#define PY_BSDDB_VERSION "5.1.2"
 
 /* Python object definitions */
 
@@ -122,6 +126,7 @@ struct behaviourFlags {
 
 struct DBObject;          /* Forward declaration */
 struct DBCursorObject;    /* Forward declaration */
+struct DBLogCursorObject; /* Forward declaration */
 struct DBTxnObject;       /* Forward declaration */
 struct DBSequenceObject;  /* Forward declaration */
 
@@ -134,6 +139,7 @@ typedef struct {
     PyObject*       event_notifyCallback;
     struct DBObject *children_dbs;
     struct DBTxnObject *children_txns;
+    struct DBLogCursorObject *children_logcursors;
     PyObject        *private_obj;
     PyObject        *rep_transport;
     PyObject        *in_weakreflist; /* List of weak references */
@@ -145,7 +151,6 @@ typedef struct DBObject {
     DBEnvObject*    myenvobj;  /* PyObject containing the DB_ENV */
     u_int32_t       flags;     /* saved flags from open() */
     u_int32_t       setflags;  /* saved flags from set_flags() */
-    int             haveStat;
     struct behaviourFlags moduleFlags;
     struct DBTxnObject *txn;
     struct DBCursorObject *children_cursors;
@@ -193,9 +198,20 @@ typedef struct DBTxnObject {
 } DBTxnObject;
 
 
+typedef struct DBLogCursorObject {
+    PyObject_HEAD
+    DB_LOGC*        logc;
+    DBEnvObject*    env;
+    struct DBLogCursorObject **sibling_prev_p;
+    struct DBLogCursorObject *sibling_next;
+    PyObject        *in_weakreflist; /* List of weak references */
+} DBLogCursorObject;
+
+
 typedef struct {
     PyObject_HEAD
     DB_LOCK         lock;
+    int             lock_initialized;  /* Signal if we actually have a lock */
     PyObject        *in_weakreflist; /* List of weak references */
 } DBLockObject;
 
@@ -220,6 +236,7 @@ typedef struct DBSequenceObject {
 /* To access the structure from an external module, use code like the
    following (error checking missed out for clarity):
 
+     // If you are using Python before 2.7:
      BSDDB_api* bsddb_api;
      PyObject*  mod;
      PyObject*  cobj;
@@ -231,23 +248,34 @@ typedef struct DBSequenceObject {
      Py_DECREF(cobj);
      Py_DECREF(mod);
 
+
+     // If you are using Python 2.7 or up: (except Python 3.0, unsupported)
+     BSDDB_api* bsddb_api;
+
+     // Use "bsddb3._pybsddb.api" if you're using
+     // the standalone pybsddb add-on.
+     bsddb_api = (void **)PyCapsule_Import("bsddb._bsddb.api", 1);
+
+
+   Check "api_version" number before trying to use the API.
+
    The structure's members must not be changed.
 */
 
+#define PYBSDDB_API_VERSION 1
 typedef struct {
+    unsigned int api_version;
     /* Type objects */
     PyTypeObject* db_type;
     PyTypeObject* dbcursor_type;
+    PyTypeObject* dblogcursor_type;
     PyTypeObject* dbenv_type;
     PyTypeObject* dbtxn_type;
     PyTypeObject* dblock_type;
-#if (DBVER >= 43)
-    PyTypeObject* dbsequence_type;
-#endif
+    PyTypeObject* dbsequence_type;  /* If DBVER < 43 -> NULL */
 
     /* Functions */
     int (*makeDBError)(int err);
-
 } BSDDB_api;
 
 
@@ -263,9 +291,9 @@ typedef struct {
 #define DBEnvObject_Check(v)    ((v)->ob_type == bsddb_api->dbenv_type)
 #define DBTxnObject_Check(v)    ((v)->ob_type == bsddb_api->dbtxn_type)
 #define DBLockObject_Check(v)   ((v)->ob_type == bsddb_api->dblock_type)
-#if (DBVER >= 43)
-#define DBSequenceObject_Check(v)  ((v)->ob_type == bsddb_api->dbsequence_type)
-#endif
+#define DBSequenceObject_Check(v)  \
+    ((bsddb_api->dbsequence_type) && \
+        ((v)->ob_type == bsddb_api->dbsequence_type))
 
 #endif /* COMPILING_BSDDB_C */
 
Index: python2.6-2.6.8/Modules/bsddbmodule.c
===================================================================
--- python2.6-2.6.8.orig/Modules/bsddbmodule.c
+++ python2.6-2.6.8/Modules/bsddbmodule.c
@@ -270,7 +270,8 @@ bsddb_subscript(bsddbobject *dp, PyObjec
 {
     int status;
     DBT krec, drec;
-    char *data,buf[4096];
+    char *data = NULL;
+    char buf[4096];
     int size;
     PyObject *result;
     recno_t recno;
@@ -503,7 +504,8 @@ bsddb_set_location(bsddbobject *dp, PyOb
 {
     int status;
     DBT krec, drec;
-    char *data,buf[4096];
+    char *data = NULL;
+    char buf[4096];
     int size;
     PyObject *result;
     recno_t recno;
@@ -635,7 +637,7 @@ bsddb_sync(bsddbobject *dp)
         PyErr_SetFromErrno(BsddbError);
         return NULL;
     }
-    return PyInt_FromLong(status = 0);
+    return PyInt_FromLong(0);
 }
 static PyMethodDef bsddb_methods[] = {
     {"close",                   (PyCFunction)bsddb_close, METH_NOARGS},
Index: python2.6-2.6.8/Lib/bsddb/test/test_fileid.py
===================================================================
--- /dev/null
+++ python2.6-2.6.8/Lib/bsddb/test/test_fileid.py
@@ -0,0 +1,61 @@
+"""TestCase for reseting File ID.
+"""
+
+import os
+import shutil
+import unittest
+
+from test_all import db, test_support, get_new_environment_path, get_new_database_path
+
+class FileidResetTestCase(unittest.TestCase):
+    def setUp(self):
+        self.db_path_1 = get_new_database_path()
+        self.db_path_2 = get_new_database_path()
+        self.db_env_path = get_new_environment_path()
+
+    def test_fileid_reset(self):
+        # create DB 1
+        self.db1 = db.DB()
+        self.db1.open(self.db_path_1, dbtype=db.DB_HASH, flags=(db.DB_CREATE|db.DB_EXCL))
+        self.db1.put('spam', 'eggs')
+        self.db1.close()
+
+        shutil.copy(self.db_path_1, self.db_path_2)
+
+        self.db2 = db.DB()
+        self.db2.open(self.db_path_2, dbtype=db.DB_HASH)
+        self.db2.put('spam', 'spam')
+        self.db2.close()
+
+        self.db_env = db.DBEnv()
+        self.db_env.open(self.db_env_path, db.DB_CREATE|db.DB_INIT_MPOOL)
+
+        # use fileid_reset() here
+        self.db_env.fileid_reset(self.db_path_2)
+
+        self.db1 = db.DB(self.db_env)
+        self.db1.open(self.db_path_1, dbtype=db.DB_HASH, flags=db.DB_RDONLY)
+        self.assertEqual(self.db1.get('spam'), 'eggs')
+
+        self.db2 = db.DB(self.db_env)
+        self.db2.open(self.db_path_2, dbtype=db.DB_HASH, flags=db.DB_RDONLY)
+        self.assertEqual(self.db2.get('spam'), 'spam')
+
+        self.db1.close()
+        self.db2.close()
+
+        self.db_env.close()
+
+    def tearDown(self):
+        test_support.unlink(self.db_path_1)
+        test_support.unlink(self.db_path_2)
+        test_support.rmtree(self.db_env_path)
+
+def test_suite():
+    suite = unittest.TestSuite()
+    if db.version() >= (4, 4):
+        suite.addTest(unittest.makeSuite(FileidResetTestCase))
+    return suite
+
+if __name__ == '__main__':
+    unittest.main(defaultTest='test_suite')
Index: python2.6-2.6.8/Lib/bsddb/test/test_db.py
===================================================================
--- /dev/null
+++ python2.6-2.6.8/Lib/bsddb/test/test_db.py
@@ -0,0 +1,172 @@
+import unittest
+import os, glob
+
+from test_all import db, test_support, get_new_environment_path, \
+        get_new_database_path
+
+#----------------------------------------------------------------------
+
+class DB(unittest.TestCase):
+    import sys
+    if sys.version_info < (2, 4) :
+        def assertTrue(self, expr, msg=None):
+            self.failUnless(expr,msg=msg)
+        def assertFalse(self, expr, msg=None):
+            self.failIf(expr,msg=msg)
+
+    def setUp(self):
+        self.path = get_new_database_path()
+        self.db = db.DB()
+
+    def tearDown(self):
+        self.db.close()
+        del self.db
+        test_support.unlink(self.path)
+
+class DB_general(DB) :
+    def test_get_open_flags(self) :
+        self.db.open(self.path, dbtype=db.DB_HASH, flags = db.DB_CREATE)
+        self.assertEqual(db.DB_CREATE, self.db.get_open_flags())
+
+    def test_get_open_flags2(self) :
+        self.db.open(self.path, dbtype=db.DB_HASH, flags = db.DB_CREATE |
+                db.DB_THREAD)
+        self.assertEqual(db.DB_CREATE | db.DB_THREAD, self.db.get_open_flags())
+
+    def test_get_dbname_filename(self) :
+        self.db.open(self.path, dbtype=db.DB_HASH, flags = db.DB_CREATE)
+        self.assertEqual((self.path, None), self.db.get_dbname())
+
+    def test_get_dbname_filename_database(self) :
+        name = "jcea-random-name"
+        self.db.open(self.path, dbname=name, dbtype=db.DB_HASH,
+                flags = db.DB_CREATE)
+        self.assertEqual((self.path, name), self.db.get_dbname())
+
+        def test_bt_minkey(self) :
+            for i in [17, 108, 1030] :
+                self.db.set_bt_minkey(i)
+                self.assertEqual(i, self.db.get_bt_minkey())
+
+        def test_lorder(self) :
+            self.db.set_lorder(1234)
+            self.assertEqual(1234, self.db.get_lorder())
+            self.db.set_lorder(4321)
+            self.assertEqual(4321, self.db.get_lorder())
+            self.assertRaises(db.DBInvalidArgError, self.db.set_lorder, 9182)
+
+    if db.version() >= (4, 6) :
+        def test_priority(self) :
+            flags = [db.DB_PRIORITY_VERY_LOW, db.DB_PRIORITY_LOW,
+                    db.DB_PRIORITY_DEFAULT, db.DB_PRIORITY_HIGH,
+                    db.DB_PRIORITY_VERY_HIGH]
+            for flag in flags :
+                self.db.set_priority(flag)
+                self.assertEqual(flag, self.db.get_priority())
+
+    if db.version() >= (4, 3) :
+        def test_get_transactional(self) :
+            self.assertFalse(self.db.get_transactional())
+            self.db.open(self.path, dbtype=db.DB_HASH, flags = db.DB_CREATE)
+            self.assertFalse(self.db.get_transactional())
+
+class DB_hash(DB) :
+        def test_h_ffactor(self) :
+            for ffactor in [4, 16, 256] :
+                self.db.set_h_ffactor(ffactor)
+                self.assertEqual(ffactor, self.db.get_h_ffactor())
+
+        def test_h_nelem(self) :
+            for nelem in [1, 2, 4] :
+                nelem = nelem*1024*1024  # Millions
+                self.db.set_h_nelem(nelem)
+                self.assertEqual(nelem, self.db.get_h_nelem())
+
+        def test_pagesize(self) :
+            for i in xrange(9, 17) :  # From 512 to 65536
+                i = 1<<i
+                self.db.set_pagesize(i)
+                self.assertEqual(i, self.db.get_pagesize())
+
+            # The valid values goes from 512 to 65536
+            # Test 131072 bytes...
+            self.assertRaises(db.DBInvalidArgError, self.db.set_pagesize, 1<<17)
+            # Test 256 bytes...
+            self.assertRaises(db.DBInvalidArgError, self.db.set_pagesize, 1<<8)
+
+class DB_txn(DB) :
+    def setUp(self) :
+        self.homeDir = get_new_environment_path()
+        self.env = db.DBEnv()
+        self.env.open(self.homeDir, db.DB_CREATE | db.DB_INIT_MPOOL |
+                db.DB_INIT_LOG | db.DB_INIT_TXN)
+        self.db = db.DB(self.env)
+
+    def tearDown(self) :
+        self.db.close()
+        del self.db
+        self.env.close()
+        del self.env
+        test_support.rmtree(self.homeDir)
+
+        def test_flags(self) :
+            self.db.set_flags(db.DB_CHKSUM)
+            self.assertEqual(db.DB_CHKSUM, self.db.get_flags())
+            self.db.set_flags(db.DB_TXN_NOT_DURABLE)
+            self.assertEqual(db.DB_TXN_NOT_DURABLE | db.DB_CHKSUM,
+                    self.db.get_flags())
+
+    if db.version() >= (4, 3) :
+        def test_get_transactional(self) :
+            self.assertFalse(self.db.get_transactional())
+            # DB_AUTO_COMMIT = Implicit transaction
+            self.db.open("XXX", dbtype=db.DB_HASH,
+                    flags = db.DB_CREATE | db.DB_AUTO_COMMIT)
+            self.assertTrue(self.db.get_transactional())
+
+class DB_recno(DB) :
+        def test_re_pad(self) :
+            for i in [' ', '*'] :  # Check chars
+                self.db.set_re_pad(i)
+                self.assertEqual(ord(i), self.db.get_re_pad())
+            for i in [97, 65] :  # Check integers
+                self.db.set_re_pad(i)
+                self.assertEqual(i, self.db.get_re_pad())
+
+        def test_re_delim(self) :
+            for i in [' ', '*'] :  # Check chars
+                self.db.set_re_delim(i)
+                self.assertEqual(ord(i), self.db.get_re_delim())
+            for i in [97, 65] :  # Check integers
+                self.db.set_re_delim(i)
+                self.assertEqual(i, self.db.get_re_delim())
+
+        def test_re_source(self) :
+            for i in ["test", "test2", "test3"] :
+                self.db.set_re_source(i)
+                self.assertEqual(i, self.db.get_re_source())
+
+class DB_queue(DB) :
+        def test_re_len(self) :
+            for i in [33, 65, 300, 2000] :
+                self.db.set_re_len(i)
+                self.assertEqual(i, self.db.get_re_len())
+
+        def test_q_extentsize(self) :
+            for i in [1, 60, 100] :
+                self.db.set_q_extentsize(i)
+                self.assertEqual(i, self.db.get_q_extentsize())
+
+def test_suite():
+    suite = unittest.TestSuite()
+
+    suite.addTest(unittest.makeSuite(DB_general))
+    suite.addTest(unittest.makeSuite(DB_txn))
+    suite.addTest(unittest.makeSuite(DB_hash))
+    suite.addTest(unittest.makeSuite(DB_recno))
+    suite.addTest(unittest.makeSuite(DB_queue))
+
+    return suite
+
+if __name__ == '__main__':
+    unittest.main(defaultTest='test_suite')
Index: python2.6-2.6.8/Lib/bsddb/test/test_dbenv.py
===================================================================
--- /dev/null
+++ python2.6-2.6.8/Lib/bsddb/test/test_dbenv.py
@@ -0,0 +1,535 @@
+import unittest
+import os, glob
+
+from test_all import db, test_support, get_new_environment_path, \
+        get_new_database_path
+
+#----------------------------------------------------------------------
+
+class DBEnv(unittest.TestCase):
+    import sys
+    if sys.version_info < (2, 4) :
+        def assertTrue(self, expr, msg=None):
+            self.failUnless(expr,msg=msg)
+
+        def assertFalse(self, expr, msg=None):
+            self.failIf(expr,msg=msg)
+
+    def setUp(self):
+        self.homeDir = get_new_environment_path()
+        self.env = db.DBEnv()
+
+    def tearDown(self):
+        self.env.close()
+        del self.env
+        test_support.rmtree(self.homeDir)
+
+class DBEnv_general(DBEnv) :
+    def test_get_open_flags(self) :
+        flags = db.DB_CREATE | db.DB_INIT_MPOOL
+        self.env.open(self.homeDir, flags)
+        self.assertEqual(flags, self.env.get_open_flags())
+
+    def test_get_open_flags2(self) :
+        flags = db.DB_CREATE | db.DB_INIT_MPOOL | \
+                db.DB_INIT_LOCK | db.DB_THREAD
+        self.env.open(self.homeDir, flags)
+        self.assertEqual(flags, self.env.get_open_flags())
+
+    if db.version() >= (4, 7) :
+        def test_lk_partitions(self) :
+            for i in [10, 20, 40] :
+                self.env.set_lk_partitions(i)
+                self.assertEqual(i, self.env.get_lk_partitions())
+
+        def test_getset_intermediate_dir_mode(self) :
+            self.assertEqual(None, self.env.get_intermediate_dir_mode())
+            for mode in ["rwx------", "rw-rw-rw-", "rw-r--r--"] :
+                self.env.set_intermediate_dir_mode(mode)
+                self.assertEqual(mode, self.env.get_intermediate_dir_mode())
+            self.assertRaises(db.DBInvalidArgError,
+                    self.env.set_intermediate_dir_mode, "abcde")
+
+    if db.version() >= (4, 6) :
+        def test_thread(self) :
+            for i in [16, 100, 1000] :
+                self.env.set_thread_count(i)
+                self.assertEqual(i, self.env.get_thread_count())
+
+        def test_cache_max(self) :
+            for size in [64, 128] :
+                size = size*1024*1024  # Megabytes
+                self.env.set_cache_max(0, size)
+                size2 = self.env.get_cache_max()
+                self.assertEqual(0, size2[0])
+                self.assertTrue(size <= size2[1])
+                self.assertTrue(2*size > size2[1])
+
+    if db.version() >= (4, 4) :
+        def test_mutex_stat(self) :
+            self.env.open(self.homeDir, db.DB_CREATE | db.DB_INIT_MPOOL |
+                    db.DB_INIT_LOCK)
+            stat = self.env.mutex_stat()
+            self.assertTrue("mutex_inuse_max" in stat)
+
+        def test_lg_filemode(self) :
+            for i in [0600, 0660, 0666] :
+                self.env.set_lg_filemode(i)
+                self.assertEqual(i, self.env.get_lg_filemode())
+
+    if db.version() >= (4, 3) :
+        def test_mp_max_openfd(self) :
+            for i in [17, 31, 42] :
+                self.env.set_mp_max_openfd(i)
+                self.assertEqual(i, self.env.get_mp_max_openfd())
+
+        def test_mp_max_write(self) :
+            for i in [100, 200, 300] :
+                for j in [1, 2, 3] :
+                    j *= 1000000
+                    self.env.set_mp_max_write(i, j)
+                    v=self.env.get_mp_max_write()
+                    self.assertEqual((i, j), v)
+
+        def test_invalid_txn(self) :
+            # This environment doesn't support transactions
+            self.assertRaises(db.DBInvalidArgError, self.env.txn_begin)
+
+        def test_mp_mmapsize(self) :
+            for i in [16, 32, 64] :
+                i *= 1024*1024
+                self.env.set_mp_mmapsize(i)
+                self.assertEqual(i, self.env.get_mp_mmapsize())
+
+        def test_tmp_dir(self) :
+            for i in ["a", "bb", "ccc"] :
+                self.env.set_tmp_dir(i)
+                self.assertEqual(i, self.env.get_tmp_dir())
+
+        def test_flags(self) :
+            self.env.set_flags(db.DB_AUTO_COMMIT, 1)
+            self.assertEqual(db.DB_AUTO_COMMIT, self.env.get_flags())
+            self.env.set_flags(db.DB_TXN_NOSYNC, 1)
+            self.assertEqual(db.DB_AUTO_COMMIT | db.DB_TXN_NOSYNC,
+                    self.env.get_flags())
+            self.env.set_flags(db.DB_AUTO_COMMIT, 0)
+            self.assertEqual(db.DB_TXN_NOSYNC, self.env.get_flags())
+            self.env.set_flags(db.DB_TXN_NOSYNC, 0)
+            self.assertEqual(0, self.env.get_flags())
+
+        def test_lk_max_objects(self) :
+            for i in [1000, 2000, 3000] :
+                self.env.set_lk_max_objects(i)
+                self.assertEqual(i, self.env.get_lk_max_objects())
+
+        def test_lk_max_locks(self) :
+            for i in [1000, 2000, 3000] :
+                self.env.set_lk_max_locks(i)
+                self.assertEqual(i, self.env.get_lk_max_locks())
+
+        def test_lk_max_lockers(self) :
+            for i in [1000, 2000, 3000] :
+                self.env.set_lk_max_lockers(i)
+                self.assertEqual(i, self.env.get_lk_max_lockers())
+
+        def test_lg_regionmax(self) :
+            for i in [128, 256, 1000] :
+                i = i*1024*1024
+                self.env.set_lg_regionmax(i)
+                j = self.env.get_lg_regionmax()
+                self.assertTrue(i <= j)
+                self.assertTrue(2*i > j)
+
+        def test_lk_detect(self) :
+            flags= [db.DB_LOCK_DEFAULT, db.DB_LOCK_EXPIRE, db.DB_LOCK_MAXLOCKS,
+                    db.DB_LOCK_MINLOCKS, db.DB_LOCK_MINWRITE,
+                    db.DB_LOCK_OLDEST, db.DB_LOCK_RANDOM, db.DB_LOCK_YOUNGEST]
+
+            if db.version() >= (4, 3) :
+                flags.append(db.DB_LOCK_MAXWRITE)
+
+            for i in flags :
+                self.env.set_lk_detect(i)
+                self.assertEqual(i, self.env.get_lk_detect())
+
+        def test_lg_dir(self) :
+            for i in ["a", "bb", "ccc", "dddd"] :
+                self.env.set_lg_dir(i)
+                self.assertEqual(i, self.env.get_lg_dir())
+
+        def test_lg_bsize(self) :
+            log_size = 70*1024
+            self.env.set_lg_bsize(log_size)
+            self.assertTrue(self.env.get_lg_bsize() >= log_size)
+            self.assertTrue(self.env.get_lg_bsize() < 4*log_size)
+            self.env.set_lg_bsize(4*log_size)
+            self.assertTrue(self.env.get_lg_bsize() >= 4*log_size)
+
+        def test_setget_data_dirs(self) :
+            dirs = ("a", "b", "c", "d")
+            for i in dirs :
+                self.env.set_data_dir(i)
+            self.assertEqual(dirs, self.env.get_data_dirs())
+
+        def test_setget_cachesize(self) :
+            cachesize = (0, 512*1024*1024, 3)
+            self.env.set_cachesize(*cachesize)
+            self.assertEqual(cachesize, self.env.get_cachesize())
+
+            cachesize = (0, 1*1024*1024, 5)
+            self.env.set_cachesize(*cachesize)
+            cachesize2 = self.env.get_cachesize()
+            self.assertEqual(cachesize[0], cachesize2[0])
+            self.assertEqual(cachesize[2], cachesize2[2])
+            # Berkeley DB expands the cache 25% accounting overhead,
+            # if the cache is small.
+            self.assertEqual(125, int(100.0*cachesize2[1]/cachesize[1]))
+
+            # You can not change configuration after opening
+            # the environment.
+            self.env.open(self.homeDir, db.DB_CREATE | db.DB_INIT_MPOOL)
+            cachesize = (0, 2*1024*1024, 1)
+            self.assertRaises(db.DBInvalidArgError,
+                              self.env.set_cachesize, *cachesize)
+            cachesize3 = self.env.get_cachesize()
+            self.assertEqual(cachesize2[0], cachesize3[0])
+            self.assertEqual(cachesize2[2], cachesize3[2])
+            # In Berkeley DB 5.1, the cachesize can change when opening the Env
+            self.assertTrue(cachesize2[1] <= cachesize3[1])
+
+        def test_set_cachesize_dbenv_db(self) :
+            # You can not configure the cachesize using
+            # the database handle, if you are using an environment.
+            d = db.DB(self.env)
+            self.assertRaises(db.DBInvalidArgError,
+                d.set_cachesize, 0, 1024*1024, 1)
+
+        def test_setget_shm_key(self) :
+            shm_key=137
+            self.env.set_shm_key(shm_key)
+            self.assertEqual(shm_key, self.env.get_shm_key())
+            self.env.set_shm_key(shm_key+1)
+            self.assertEqual(shm_key+1, self.env.get_shm_key())
+
+            # You can not change configuration after opening
+            # the environment.
+            self.env.open(self.homeDir, db.DB_CREATE | db.DB_INIT_MPOOL)
+            # If we try to reconfigure cache after opening the
+            # environment, core dump.
+            self.assertRaises(db.DBInvalidArgError,
+                self.env.set_shm_key, shm_key)
+            self.assertEqual(shm_key+1, self.env.get_shm_key())
+
+    if db.version() >= (4, 4) :
+        def test_mutex_setget_max(self) :
+            v = self.env.mutex_get_max()
+            v2 = v*2+1
+
+            self.env.mutex_set_max(v2)
+            self.assertEqual(v2, self.env.mutex_get_max())
+
+            self.env.mutex_set_max(v)
+            self.assertEqual(v, self.env.mutex_get_max())
+
+            # You can not change configuration after opening
+            # the environment.
+            self.env.open(self.homeDir, db.DB_CREATE)
+            self.assertRaises(db.DBInvalidArgError,
+                    self.env.mutex_set_max, v2)
+
+        def test_mutex_setget_increment(self) :
+            v = self.env.mutex_get_increment()
+            v2 = 127
+
+            self.env.mutex_set_increment(v2)
+            self.assertEqual(v2, self.env.mutex_get_increment())
+
+            self.env.mutex_set_increment(v)
+            self.assertEqual(v, self.env.mutex_get_increment())
+
+            # You can not change configuration after opening
+            # the environment.
+            self.env.open(self.homeDir, db.DB_CREATE)
+            self.assertRaises(db.DBInvalidArgError,
+                    self.env.mutex_set_increment, v2)
+
+        def test_mutex_setget_tas_spins(self) :
+            self.env.mutex_set_tas_spins(0)  # Default = BDB decides
+            v = self.env.mutex_get_tas_spins()
+            v2 = v*2+1
+
+            self.env.mutex_set_tas_spins(v2)
+            self.assertEqual(v2, self.env.mutex_get_tas_spins())
+
+            self.env.mutex_set_tas_spins(v)
+            self.assertEqual(v, self.env.mutex_get_tas_spins())
+
+            # In this case, you can change configuration
+            # after opening the environment.
+            self.env.open(self.homeDir, db.DB_CREATE)
+            self.env.mutex_set_tas_spins(v2)
+
+        def test_mutex_setget_align(self) :
+            v = self.env.mutex_get_align()
+            v2 = 64
+            if v == 64 :
+                v2 = 128
+
+            self.env.mutex_set_align(v2)
+            self.assertEqual(v2, self.env.mutex_get_align())
+
+            # Requires a nonzero power of two
+            self.assertRaises(db.DBInvalidArgError,
+                    self.env.mutex_set_align, 0)
+            self.assertRaises(db.DBInvalidArgError,
+                    self.env.mutex_set_align, 17)
+
+            self.env.mutex_set_align(2*v2)
+            self.assertEqual(2*v2, self.env.mutex_get_align())
+
+            # You can not change configuration after opening
+            # the environment.
+            self.env.open(self.homeDir, db.DB_CREATE)
+            self.assertRaises(db.DBInvalidArgError,
+                    self.env.mutex_set_align, v2)
+
+
+class DBEnv_log(DBEnv) :
+    def setUp(self):
+        DBEnv.setUp(self)
+        self.env.open(self.homeDir, db.DB_CREATE | db.DB_INIT_MPOOL | db.DB_INIT_LOG)
+
+    def test_log_file(self) :
+        log_file = self.env.log_file((1, 1))
+        self.assertEqual("log.0000000001", log_file[-14:])
+
+    if db.version() >= (4, 4) :
+        # The version with transactions is checked in other test object
+        def test_log_printf(self) :
+            msg = "This is a test..."
+            self.env.log_printf(msg)
+            logc = self.env.log_cursor()
+            self.assertTrue(msg in (logc.last()[1]))
+
+    if db.version() >= (4, 7) :
+        def test_log_config(self) :
+            self.env.log_set_config(db.DB_LOG_DSYNC | db.DB_LOG_ZERO, 1)
+            self.assertTrue(self.env.log_get_config(db.DB_LOG_DSYNC))
+            self.assertTrue(self.env.log_get_config(db.DB_LOG_ZERO))
+            self.env.log_set_config(db.DB_LOG_ZERO, 0)
+            self.assertTrue(self.env.log_get_config(db.DB_LOG_DSYNC))
+            self.assertFalse(self.env.log_get_config(db.DB_LOG_ZERO))
+
+
+class DBEnv_log_txn(DBEnv) :
+    def setUp(self):
+        DBEnv.setUp(self)
+        self.env.open(self.homeDir, db.DB_CREATE | db.DB_INIT_MPOOL |
+                db.DB_INIT_LOG | db.DB_INIT_TXN)
+
+    if db.version() >= (4, 5) :
+        def test_tx_max(self) :
+            txns=[]
+            def tx() :
+                for i in xrange(self.env.get_tx_max()) :
+                    txns.append(self.env.txn_begin())
+
+            tx()
+            self.assertRaises(MemoryError, tx)
+
+            # Abort the transactions before garbage collection,
+            # to avoid "warnings".
+            for i in txns :
+                i.abort()
+
+    if db.version() >= (4, 4) :
+        # The version without transactions is checked in other test object
+        def test_log_printf(self) :
+            msg = "This is a test..."
+            txn = self.env.txn_begin()
+            self.env.log_printf(msg, txn=txn)
+            txn.commit()
+            logc = self.env.log_cursor()
+            logc.last()  # Skip the commit
+            self.assertTrue(msg in (logc.prev()[1]))
+
+            msg = "This is another test..."
+            txn = self.env.txn_begin()
+            self.env.log_printf(msg, txn=txn)
+            txn.abort()  # Do not store the new message
+            logc.last()  # Skip the abort
+            self.assertTrue(msg not in (logc.prev()[1]))
+
+            msg = "This is a third test..."
+            txn = self.env.txn_begin()
+            self.env.log_printf(msg, txn=txn)
+            txn.commit()  # Do not store the new message
+            logc.last()  # Skip the commit
+            self.assertTrue(msg in (logc.prev()[1]))
+
+
+class DBEnv_memp(DBEnv):
+    def setUp(self):
+        DBEnv.setUp(self)
+        self.env.open(self.homeDir, db.DB_CREATE | db.DB_INIT_MPOOL | db.DB_INIT_LOG)
+        self.db = db.DB(self.env)
+        self.db.open("test", db.DB_HASH, db.DB_CREATE, 0660)
+
+    def tearDown(self):
+        self.db.close()
+        del self.db
+        DBEnv.tearDown(self)
+
+    def test_memp_1_trickle(self) :
+        self.db.put("hi", "bye")
+        self.assertTrue(self.env.memp_trickle(100) > 0)
+
+# Preserve the order, do "memp_trickle" test first
+    def test_memp_2_sync(self) :
+        self.db.put("hi", "bye")
+        self.env.memp_sync()  # Full flush
+        # Nothing to do...
+        self.assertTrue(self.env.memp_trickle(100) == 0)
+
+        self.db.put("hi", "bye2")
+        self.env.memp_sync((1, 0))  # NOP, probably
+        # Something to do... or not
+        self.assertTrue(self.env.memp_trickle(100) >= 0)
+
+        self.db.put("hi", "bye3")
+        self.env.memp_sync((123, 99))  # Full flush
+        # Nothing to do...
+        self.assertTrue(self.env.memp_trickle(100) == 0)
+
+    def test_memp_stat_1(self) :
+        stats = self.env.memp_stat()  # No param
+        self.assertTrue(len(stats)==2)
+        self.assertTrue("cache_miss" in stats[0])
+        stats = self.env.memp_stat(db.DB_STAT_CLEAR)  # Positional param
+        self.assertTrue("cache_miss" in stats[0])
+        stats = self.env.memp_stat(flags=0)  # Keyword param
+        self.assertTrue("cache_miss" in stats[0])
+
+    def test_memp_stat_2(self) :
+        stats=self.env.memp_stat()[1]
+        self.assertTrue(len(stats))==1
+        self.assertTrue("test" in stats)
+        self.assertTrue("page_in" in stats["test"])
+
+class DBEnv_logcursor(DBEnv):
+    def setUp(self):
+        DBEnv.setUp(self)
+        self.env.open(self.homeDir, db.DB_CREATE | db.DB_INIT_MPOOL |
+                db.DB_INIT_LOG | db.DB_INIT_TXN)
+        txn = self.env.txn_begin()
+        self.db = db.DB(self.env)
+        self.db.open("test", db.DB_HASH, db.DB_CREATE, 0660, txn=txn)
+        txn.commit()
+        for i in ["2", "8", "20"] :
+            txn = self.env.txn_begin()
+            self.db.put(key = i, data = i*int(i), txn=txn)
+            txn.commit()
+
+    def tearDown(self):
+        self.db.close()
+        del self.db
+        DBEnv.tearDown(self)
+
+    def _check_return(self, value) :
+        self.assertTrue(isinstance(value, tuple))
+        self.assertEqual(len(value), 2)
+        self.assertTrue(isinstance(value[0], tuple))
+        self.assertEqual(len(value[0]), 2)
+        self.assertTrue(isinstance(value[0][0], int))
+        self.assertTrue(isinstance(value[0][1], int))
+        self.assertTrue(isinstance(value[1], str))
+
+    # Preserve test order
+    def test_1_first(self) :
+        logc = self.env.log_cursor()
+        v = logc.first()
+        self._check_return(v)
+        self.assertTrue((1, 1) < v[0])
+        self.assertTrue(len(v[1])>0)
+
+    def test_2_last(self) :
+        logc = self.env.log_cursor()
+        lsn_first = logc.first()[0]
+        v = logc.last()
+        self._check_return(v)
+        self.assertTrue(lsn_first < v[0])
+
+    def test_3_next(self) :
+        logc = self.env.log_cursor()
+        lsn_last = logc.last()[0]
+        self.assertEqual(logc.next(), None)
+        lsn_first = logc.first()[0]
+        v = logc.next()
+        self._check_return(v)
+        self.assertTrue(lsn_first < v[0])
+        self.assertTrue(lsn_last > v[0])
+
+        v2 = logc.next()
+        self.assertTrue(v2[0] > v[0])
+        self.assertTrue(lsn_last > v2[0])
+
+        v3 = logc.next()
+        self.assertTrue(v3[0] > v2[0])
+        self.assertTrue(lsn_last > v3[0])
+
+    def test_4_prev(self) :
+        logc = self.env.log_cursor()
+        lsn_first = logc.first()[0]
+        self.assertEqual(logc.prev(), None)
+        lsn_last = logc.last()[0]
+        v = logc.prev()
+        self._check_return(v)
+        self.assertTrue(lsn_first < v[0])
+        self.assertTrue(lsn_last > v[0])
+
+        v2 = logc.prev()
+        self.assertTrue(v2[0] < v[0])
+        self.assertTrue(lsn_first < v2[0])
+
+        v3 = logc.prev()
+        self.assertTrue(v3[0] < v2[0])
+        self.assertTrue(lsn_first < v3[0])
+
+    def test_5_current(self) :
+        logc = self.env.log_cursor()
+        logc.first()
+        v = logc.next()
+        self.assertEqual(v, logc.current())
+
+    def test_6_set(self) :
+        logc = self.env.log_cursor()
+        logc.first()
+        v = logc.next()
+        self.assertNotEqual(v, logc.next())
+        self.assertNotEqual(v, logc.next())
+        self.assertEqual(v, logc.set(v[0]))
+
+    def test_explicit_close(self) :
+        logc = self.env.log_cursor()
+        logc.close()
+        self.assertRaises(db.DBCursorClosedError, logc.next)
+
+    def test_implicit_close(self) :
+        logc =  [self.env.log_cursor() for i in xrange(10)]
+        self.env.close()  # This close should close too all its tree
+        for i in logc :
+            self.assertRaises(db.DBCursorClosedError, i.next)
+
+def test_suite():
+    suite = unittest.TestSuite()
+
+    suite.addTest(unittest.makeSuite(DBEnv_general))
+    suite.addTest(unittest.makeSuite(DBEnv_memp))
+    suite.addTest(unittest.makeSuite(DBEnv_logcursor))
+    suite.addTest(unittest.makeSuite(DBEnv_log))
+    suite.addTest(unittest.makeSuite(DBEnv_log_txn))
+
+    return suite
+
+if __name__ == '__main__':
+    unittest.main(defaultTest='test_suite')
